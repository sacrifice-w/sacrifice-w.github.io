<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小吴的Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-20T08:32:36.046Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Wh&amp;CC</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Next.js</title>
    <link href="http://example.com/2023/03/14/Next-js/"/>
    <id>http://example.com/2023/03/14/Next-js/</id>
    <published>2023-03-14T06:52:51.000Z</published>
    <updated>2023-03-20T08:32:36.046Z</updated>
    
    <content type="html"><![CDATA[<p>官网：<a href="https://nextjs.org/">https://nextjs.org/</a></p><p><strong>为前端工程师提供全栈解决方案</strong></p><h3 id="React和next-js的区别"><a href="#React和next-js的区别" class="headerlink" title="React和next.js的区别"></a>React和next.js的区别</h3><ol><li><p>next.js基于React框架，React不解决路由、样式、状态这些，只是单纯的负责打通html和js</p></li><li><p>React是单页面应用，但是next.js会生成多个页面</p></li></ol><span id="more"></span><h2 id="create-next-app"><a href="#create-next-app" class="headerlink" title="create next-app"></a>create next-app</h2><ol><li><p>创建项目：<code>yarn create next-app</code></p></li><li><p><code>package.json</code>里可以查看一些选项：dev是开发模式；使用build构建脚本；start用于生产环境；全静态网页使用export命令</p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230314152116747.png" alt="image-20230314152116747"></p></li><li><p>生产模式（build &amp; start）的运行过程：</p><ol><li>将现有代码生成一份静态页面，比如生成了静态的Index.html</li><li>首先加载静态界面，然后加载js脚本，之后再通过js脚本将页面重新渲染一遍</li><li>所以说等于build的过程是生成静态页面和动态js脚本，是一个动静结合的过程</li></ol><p>所以说next.js生成的服务是需要运行在服务器上的，比如页面响应等内容是通过next来进行操作的，如果想生成纯静态页面，则需要使用<code>next export</code>命令</p></li></ol><h2 id="静态路由和动态路由"><a href="#静态路由和动态路由" class="headerlink" title="静态路由和动态路由"></a>静态路由和动态路由</h2><h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><p>next中的静态路由通过pages下面的页面来实现</p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230314155444669.png" alt="image-20230314155444669"></p><p>如上图所示，如果在pages页面中添加了一个about页面，则可以通过&#x2F;about来访问这个页面</p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230314155534736.png" alt="image-20230314155534736"></p><p>可以通过往pages目录中添加子文件夹来实现嵌套路由</p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230314155905260.png" alt="image-20230314155905260"></p><p>比如现在pages文件夹中存在名为posts的子文件夹，而这个文件夹中存在index和post</p><ul><li><p>通过<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230314160023786.png" alt="image-20230314160023786">来访问post</p></li><li><p>通过<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230314160057639.png" alt="image-20230314160057639">来访问posts&#x2F;index</p></li></ul><p><strong>嵌套路由可以一直叠加</strong></p><p>如果pages文件夹中存在404、500等特殊页面，则会替代它自动生成的特殊页面</p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>next使用带中括号的名称来标记动态路由。例如：<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230314160800455.png" alt="image-20230314160800455"></p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230314161235512.png" alt="image-20230314161235512"></p><p>通过next中提供的hook，即<code>useRouter()</code>便可以得到此时的路由参数</p><p>同理，文件夹也可以通过中括号的形式来完成动态路由</p><p>另一种方式可以通过<code>[...params].tsx</code>这种形式来实现动态路由</p><p>这种动态路由的好处就是可以获得多个参数</p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230314163632195.png" alt="image-20230314163632195"></p><p>例如上图就是有who和what两个参数</p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230314164034403.png" alt="image-20230314164034403"></p><p>同理，获得参数还是使用<code>useRouter()</code>这个hook</p><h2 id="页面加载时获取数据"><a href="#页面加载时获取数据" class="headerlink" title="页面加载时获取数据"></a>页面加载时获取数据</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useState,useEffect&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Page</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [dt,setDT] = <span class="title function_">useState</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> [data, setData] = useState&lt;<span class="built_in">any</span>[]&gt;([])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">fetchData</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">fetch</span>(<span class="string">&#x27;https://dummyjson.com/posts&#x27;</span>)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> response.<span class="title function_">json</span>()</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">reply</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">setData</span>(reply.<span class="property">posts</span>)</span><br><span class="line">            <span class="title function_">setDT</span>((<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">toString</span>())</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">fetchData</span>()</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>posts List Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;dt&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;data.map((item) =&gt; (</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                ))</span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过react中已有的一些hook去抓取数据，首先生成了静态页面，但是数据是动态抓取的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;官网：&lt;a href=&quot;https://nextjs.org/&quot;&gt;https://nextjs.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为前端工程师提供全栈解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;React和next-js的区别&quot;&gt;&lt;a href=&quot;#React和next-js的区别&quot; class=&quot;headerlink&quot; title=&quot;React和next.js的区别&quot;&gt;&lt;/a&gt;React和next.js的区别&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;next.js基于React框架，React不解决路由、样式、状态这些，只是单纯的负责打通html和js&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;React是单页面应用，但是next.js会生成多个页面&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>JS中的链表</title>
    <link href="http://example.com/2023/02/15/JS%E4%B8%AD%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2023/02/15/JS%E4%B8%AD%E7%9A%84%E9%93%BE%E8%A1%A8/</id>
    <published>2023-02-15T03:21:42.000Z</published>
    <updated>2023-03-20T08:32:35.030Z</updated>
    
    <content type="html"><![CDATA[<p>​链表格是一种线性数据结构，类似于数组，但不像数组的元素存储在特定的存储器位置或索引中，链表格的每个元素都是一个独立的对象，其中包含一个指针或链接指向列表中的下一个对象。</p><p>​每一个元素（通常 称为节点）包含两个项目：存储的数据和到下一个节点的链接，这些数据可以是任何有效数据类型 。下面的图表显示：</p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/1.jpg" alt="1"></p><span id="more"></span><p>​我们通常使用 “head” 作为链表入口，这个 “head” 是对链表中第一个节点的引用，而链表的最后一个节点指向 null。如果是空链表，则 head 的引用就是 null。</p><p>在 JavaScript 中，链表长这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = &#123;</span><br><span class="line">    <span class="attr">head</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">6</span></span><br><span class="line">        <span class="attr">next</span>: &#123;</span><br><span class="line">            <span class="attr">value</span>: <span class="number">10</span>                                             </span><br><span class="line">            <span class="attr">next</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">12</span></span><br><span class="line">                <span class="attr">next</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="number">3</span></span><br><span class="line">                    <span class="attr">next</span>: <span class="literal">null</span>    </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="链表的优点"><a href="#链表的优点" class="headerlink" title="链表的优点"></a>链表的优点</h2><p>可以很容易地从链表中删除或添加节点，而无需重组整个数据结构。这是它相对于数组的一个优势。</p><h2 id="链表的缺点"><a href="#链表的缺点" class="headerlink" title="链表的缺点"></a>链表的缺点</h2><ul><li>链表的搜索操作很慢，与数组不同，不允许随机访问数据元素，必须从第一个节点开始按顺序访问节点。</li><li>由于需要储存指针，相较于数组需要更多内存。</li></ul><h2 id="链表的类型"><a href="#链表的类型" class="headerlink" title="链表的类型"></a>链表的类型</h2><p>链表有以下三种类型：</p><ul><li>****单向链表****：每个节点只包含一个指向下一个节点的指针。也就是我们到上面一直在讨论的。</li><li>****双向链表****：每个节点包含两个指针，一个指向下一个节点，另一个指向前一个节点。</li><li>****循形链表****：循环链表是链表的一种变体，它的最后一个节点指向第一个节点或它之前的任何其他节点，从而形成一个循环。</li></ul><h2 id="用-JavaScript-实现一个表节点"><a href="#用-JavaScript-实现一个表节点" class="headerlink" title="用 JavaScript 实现一个表节点"></a>用 JavaScript 实现一个表节点</h2><p>前面我们讲到，列表节点包含两项：数据和指向下一个节点的指针。我们可以用 JavaScript 实现如下所示的列表节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">data</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span> = data</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用-JavaScript-实现一个链表"><a href="#用-JavaScript-实现一个链表" class="headerlink" title="用 JavaScript 实现一个链表"></a>用 JavaScript 实现一个链表</h2><p>下面的代码展示了使用构造函数实现链表类的方法。注意，如果未传递 “head” 节点，则它将初始化为 null：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">head = <span class="literal">null</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span> = head</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将它们合在一起"><a href="#将它们合在一起" class="headerlink" title="将它们合在一起"></a>将它们合在一起</h2><p>让我们用刚刚创建的类创建一个链表。 首先，我们创建两个表节点，<em>node1</em> 和 <em>node2</em>，以及他们之间的指针：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node1 = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> node2 = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>)</span><br><span class="line">node1.<span class="property">next</span> = node2</span><br></pre></td></tr></table></figure><p>接着，我们使用 <em>node1</em> 创建一个链表：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>(node1)        </span><br></pre></td></tr></table></figure><p>让我们尝试访问刚刚创建的列表中的节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(list.<span class="property">head</span>.<span class="property">next</span>.<span class="property">data</span>) <span class="comment">//returns 5    </span></span><br></pre></td></tr></table></figure><h2 id="一些链表方法："><a href="#一些链表方法：" class="headerlink" title="一些链表方法："></a>一些链表方法：</h2><p>接下来，我们将为链表实现四个 helper 方法：</p><ol><li>size()</li><li>clear()</li><li>getList()</li><li>getFirst()</li></ol><h3 id="1-size"><a href="#1-size" class="headerlink" title="1. size()"></a>1. size()</h3><p>该方法返回链表中存在的节点数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        node = node.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-clear"><a href="#2-clear" class="headerlink" title="2. clear()"></a>2. clear()</h3><p>该方法清空链表：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-getList"><a href="#3-getList" class="headerlink" title="3. getList()"></a>3. getList()</h3><p>该方法返回链表的最后一个节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getLast</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> lastNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastNode) &#123;</span><br><span class="line">        <span class="keyword">while</span> (lastNode.<span class="property">next</span>) &#123;</span><br><span class="line">            lastNode = lastNode.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lastNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-getFirst"><a href="#4-getFirst" class="headerlink" title="4. getFirst()"></a>4. getFirst()</h3><p>该方法返回链表第一个节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getFirst</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;​		链表格是一种线性数据结构，类似于数组，但不像数组的元素存储在特定的存储器位置或索引中，链表格的每个元素都是一个独立的对象，其中包含一个指针或链接指向列表中的下一个对象。&lt;/p&gt;
&lt;p&gt;​		每一个元素（通常 称为节点）包含两个项目：存储的数据和到下一个节点的链接，这些数据可以是任何有效数据类型 。下面的图表显示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogwh.oss-cn-beijing.aliyuncs.com/img/1.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>博客更新流程</title>
    <link href="http://example.com/2023/02/15/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B/"/>
    <id>http://example.com/2023/02/15/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B/</id>
    <published>2023-02-15T03:12:23.000Z</published>
    <updated>2023-03-20T08:32:38.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="博客更新流程"><a href="#博客更新流程" class="headerlink" title="博客更新流程"></a>博客更新流程</h2><ol><li>在hexo文件夹中的<code>source/_posts/</code>路径下右键打开git，即<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230215111444888.png" alt="image-20230215111444888"></li><li>在页面中输入<code>hexo new &lt;title&gt;</code>来进行文章的创建，title有空格的话需要有引号，比如<code>hexo new &quot;博客 更新 流程&quot;</code></li><li>如果需要调整博客的预设置，可以进入<code>scaffolds/post.md</code>中进行调整<ol><li><code>tags：</code>表示标签</li><li><code>categories：</code>表示种类，即大分类</li><li><code>&lt;!-- more --&gt;</code>表示分界线，即显示在主界面中的内容</li></ol></li></ol><span id="more"></span><ol start="4"><li>在博客更新完后，使用<code>hexo g &amp;&amp; hexo d</code>命令来将新的博客推送到远端主页</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;博客更新流程&quot;&gt;&lt;a href=&quot;#博客更新流程&quot; class=&quot;headerlink&quot; title=&quot;博客更新流程&quot;&gt;&lt;/a&gt;博客更新流程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在hexo文件夹中的&lt;code&gt;source/_posts/&lt;/code&gt;路径下右键打开git，即&lt;img src=&quot;https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230215111444888.png&quot; alt=&quot;image-20230215111444888&quot;&gt;&lt;/li&gt;
&lt;li&gt;在页面中输入&lt;code&gt;hexo new &amp;lt;title&amp;gt;&lt;/code&gt;来进行文章的创建，title有空格的话需要有引号，比如&lt;code&gt;hexo new &amp;quot;博客 更新 流程&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果需要调整博客的预设置，可以进入&lt;code&gt;scaffolds/post.md&lt;/code&gt;中进行调整&lt;ol&gt;
&lt;li&gt;&lt;code&gt;tags：&lt;/code&gt;表示标签&lt;/li&gt;
&lt;li&gt;&lt;code&gt;categories：&lt;/code&gt;表示种类，即大分类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;!-- more --&amp;gt;&lt;/code&gt;表示分界线，即显示在主界面中的内容&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo+github+PicGo+阿里云OSS博客搭建流程</title>
    <link href="http://example.com/2022/12/28/Hexo+github+PicGo+%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
    <id>http://example.com/2022/12/28/Hexo+github+PicGo+%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/</id>
    <published>2022-12-28T02:16:47.000Z</published>
    <updated>2023-03-20T08:32:34.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HEXO博客的本地搭建"><a href="#HEXO博客的本地搭建" class="headerlink" title="HEXO博客的本地搭建"></a>HEXO博客的本地搭建</h2><ol><li>下载node.js和Git</li><li>本地安装hexo，在你想要存放博客的文件夹根目录下右键，选择<code>Git Bash Here</code>，输入下列命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 安装hexo框架</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line">#初始化文件夹</span><br><span class="line">hexo init</span><br><span class="line"># 安装 hexo 依赖包</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>hexo官网：<a href="https://hexo.io/zh-cn/index.html">https://hexo.io/zh-cn/index.html</a></p><ol start="3"><li>在git bash命令行窗口里，依次执行</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 生成静态网站</span><br><span class="line">hexo g</span><br><span class="line"># 启动服务器</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>此时在<code>http://localhost:4000/</code>就能看到Hexo搭建的博客示例</p><p>我使用的主题：NEXT</p><p>Github主页：<a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a></p><p>如何更换主题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 下载主题仓库到 themes 文件夹， git clone &lt;仓库地址&gt; themes/&lt;主题名&gt; </span><br><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>然后用记事本打开博客根目录下的 _config.yml ，找到<code>theme</code>标签，默认值是<code>landscape</code>主题，把它改为要更换的主题名字<code>next</code>，然后执行启动命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: ayer</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 清理 &amp;&amp; 生成 &amp;&amp; 启动</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p>如何修改主题内容可以根据next主题中文官方文档查看：<a href="http://theme-next.iissnan.com/">http://theme-next.iissnan.com/</a></p><h2 id="从WORDPRESS迁移博客"><a href="#从WORDPRESS迁移博客" class="headerlink" title="从WORDPRESS迁移博客"></a>从WORDPRESS迁移博客</h2><p>如果需要从WordPress迁移自己的博客内容，可以通过插件来进行迁移</p><p>首先需要安装<code>hexo-migrator-wordpress</code> 插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-migrator-wordpress --save</span><br></pre></td></tr></table></figure><p>在 WordPress 仪表盘中导出数据(“Tools” → “Export” → “WordPress”)（详情参考<a href="https://wordpress.com/zh-cn/support/export/">WP支持页面</a>）。</p><p>插件安装完成后，执行下列命令来迁移所有文章。<code>source</code> 可以是 WordPress 导出的文件路径或网址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo migrate wordpress &lt;source&gt;</span><br></pre></td></tr></table></figure><p>这个迁移完成后会在<code>source/_posts/</code>目录下迁移完所有的文章，但是会有一些小问题，就是你之前引用的图片路径仍然是WordPress上的媒体路径，需要自己手动更新一下，这部分会在接下来详细讲解，我使用的是阿里云OSS方案</p><h2 id="Github-Pages建站"><a href="#Github-Pages建站" class="headerlink" title="Github Pages建站"></a>Github Pages建站</h2><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20201229224505117.png" alt="image-20201229224505117"></p><p>由于每个 GitHub 账户只能建立一个 GitHub Pages 页面，所以 Repository name 必须填<code>&lt;你的用户名&gt;.github.io</code>，否则就会建立一个普通仓库，GitHub Pages 功能不会生效。比如用户名是<code>jacksparrow</code>，Repository name 这里就填<code>jacksparrow.github.io</code>，不知道用户名是哪个，可以点击页面右上角头像，看到第一行“Signed in as <code>xxx</code>”字样， <code>xxx</code>即为这里的用户名。</p><p>Description 填写仓库描述，比如 <code>jacksparrow&#39;s blog</code>等，可不填。</p><p>注意勾选 <code>Public</code> ，否则 GitHub Pages 功能不会生效。建议勾选 <code>Add a README file</code>，会自动生成一个 <code>readme.md</code>文件。</p><p>最后点击Create repository创建仓库。</p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20201229224741804.png" alt="image-20201229224741804"></p><p>配置完参数后需要配置git参数，这部分网上教程一大堆，就不详细累述了。</p><p>大概流程就是配置用户名和邮箱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 其中 username 和 username@XXX.com 是你注册 GitHub 的用户名和邮箱</span><br><span class="line">git config --global user.name &quot;username&quot;</span><br><span class="line">git config --global user.email &quot;username@XXX.com&quot;</span><br></pre></td></tr></table></figure><p>生成SSH keys和github相互认证，认证完后通过<code>ssh -T git@github.com</code>命令进行测试是否成功</p><p>测试成功后，在在博客根目录下，右键，打开Git Bash Here。</p><p>输入下面的命令，安装<code>hexo-deployer-git</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure><p>打开博客<code>根目录配置文件</code>(<code>D:\MyBlog\_config.yaml</code>)，拉到文件最后一行，修改为下面的配置（没有的配置项自行添加），保存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 其中 xxxxxx 是前面多次用到的你的GitHub用户名</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:xxxxxx/xxxxxx.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 注意最后变成d了，原来的s表示服务起在本地，现在的d表示部署在远端</span><br><span class="line">hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>这里有一些需要注意的地方，就是如果你明明更新了博客的内容，但是没有显示，可以尝试两种方法来进行刷新</p><ol><li><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>通过清除缓存再重新部署</li><li>在浏览器端<code>shift+F5</code>强制刷新，清除浏览器端缓存来看更新</li><li>当然你上传到github上的页面会有一定的延迟，所以不用很着急，隔几分钟再看看</li></ol><h2 id="PicGo-阿里云OSS图床"><a href="#PicGo-阿里云OSS图床" class="headerlink" title="PicGo+阿里云OSS图床"></a>PicGo+阿里云OSS图床</h2><p>这部分是消耗我时间最长的东西，尝试了Gitee图床和Github图床都不是很好用，所以还是选择使用金钱的力量(滑稽)。当然，阿里云OSS服务有个坑，就是你包月包年了它的标准流量包，但那个只负责储存，但是不负责下行流量，但是你自己博客的话，也不会使用多少下行流量，0.5元&#x2F;GB的价格，见仁见智吧。</p><p> <strong>如果是自己简单的写个博客或 公众号，平时可能没有特别大的访问量，所以选择默认的按量计费，如果访问量较大的，可以考虑包年包月</strong></p><p><a href="https://picgo.github.io/PicGo-Doc/zh/">PicGo下载链接</a></p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20221228105817341.png" alt="image-20221228105817341"></p><p>具体设置如图所示，需要在阿里云里设置keyid和keysecret，<a href="https://zhuanlan.zhihu.com/p/104152479">一篇很棒的教程</a></p><p>需要注意的点：</p><ol><li>阿里云那里在创建bucket时，读写权限需要时<strong>公共读</strong>，这样才能通过链接访问到这个图片。</li><li>KeyId和KeySecret只能显示一次，所以需要<strong>妥善保管</strong>，复制粘贴到别处哦。</li></ol><p>剩下就可以愉快的上传自己的图片了。</p><p>当然据说使用Gihub+国内CDN加速也可以很丝滑的使用图床，但是我不知道怎么也弄不好，所以还是算咧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HEXO博客的本地搭建&quot;&gt;&lt;a href=&quot;#HEXO博客的本地搭建&quot; class=&quot;headerlink&quot; title=&quot;HEXO博客的本地搭建&quot;&gt;&lt;/a&gt;HEXO博客的本地搭建&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;下载node.js和Git&lt;/li&gt;
&lt;li&gt;本地安装h</summary>
      
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>React脚手架</title>
    <link href="http://example.com/2022/12/26/react%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <id>http://example.com/2022/12/26/react%E8%84%9A%E6%89%8B%E6%9E%B6/</id>
    <published>2022-12-26T10:00:00.000Z</published>
    <updated>2023-03-20T08:32:37.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、使用-create-react-app-创建-react-应用"><a href="#一、使用-create-react-app-创建-react-应用" class="headerlink" title="一、使用 create-react-app 创建 react 应用"></a>一、使用 create-react-app 创建 react 应用</h1><h2 id="1-1-react-脚手架"><a href="#1-1-react-脚手架" class="headerlink" title="1.1 react 脚手架"></a>1.1 react 脚手架</h2><ol><li>脚手架就是用来帮助快速创建一个基于 xxx 库的模板项目<ol><li>包含所有需要的配置(语法检查，jsx 编译，devServer…)</li><li>下载好了所有相关的依赖</li><li>可以直接运行一个简单效果</li></ol></li><li>react 提供了一个用于创建 react 项目的脚手架库:create-react-app</li><li>项目的整体技术架构为：react+webpack+es6+eslint</li><li>使用脚手架开发的项目的特点：模块化，组件化，工程化</li></ol><span id="more"></span><h2 id="1-2-配置"><a href="#1-2-配置" class="headerlink" title="1.2 配置"></a>1.2 配置</h2><p>比较古老的方式：<code>npm install -g create-react-app</code><br>但是这种方式可能会出现一些小 bug，比如说显示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mayankthakur@<span class="title class_">Mayanks</span>-<span class="title class_">MacBook</span>-<span class="title class_">Air</span> ~ % npm install -g create-react-app</span><br><span class="line"></span><br><span class="line">npm <span class="variable constant_">WARN</span> deprecated tar@<span class="number">2.2</span><span class="number">.2</span>: <span class="title class_">This</span> version <span class="keyword">of</span> tar is no longer supported, and will not receive security updates. <span class="title class_">Please</span> upgrade asap.</span><br><span class="line"></span><br><span class="line">changed <span class="number">67</span> packages, and audited <span class="number">68</span> packages <span class="keyword">in</span> 1s</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> packages are looking <span class="keyword">for</span> funding</span><br><span class="line">  run <span class="string">`npm fund`</span> <span class="keyword">for</span> details</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> high severity vulnerabilities</span><br><span class="line"></span><br><span class="line"><span class="title class_">To</span> address all issues, <span class="attr">run</span>:</span><br><span class="line">  npm audit fix</span><br><span class="line"></span><br><span class="line"><span class="title class_">Run</span> <span class="string">`npm audit`</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>但是这不是 error，是一个 warning。就是告诉你的 tar 版本太低咧。但是没啥事儿。我试着更新了一下 tar 的版本，但是好像没啥用。<br>之后再创建项目<code>create-react-app react-staging</code>类似于这样就行了。</p><p>或者说，可以使用新的方法：<br><code>npx create-react-app my-app</code><br><strong>这条命令会临时安装 create-react-app 包，命令完成后 create-react-app 会删掉，不会出现在 global 中。下次再执行，还是会重新临时安装。</strong></p><p>之后在安装完成后，进入已经创建好的项目目录，<code>npm start</code>启动项目。</p><p><strong>在使用包管理器时，需要注意，在一个项目中只使用一个包管理器，比如只使用 npm 或者只使用 yarn。尽量不要使用多个包管理器，否则可能会出现未知问题</strong></p><h2 id="1-3-内容"><a href="#1-3-内容" class="headerlink" title="1.3 内容"></a>1.3 内容</h2><ol><li>node_modules 存放脚手架所需的依赖</li><li>public 存放静态资源文件。包括 favicon.ico 的网页图标，index.html 为 react 提供节点。</li></ol><p>以下是 index.html 文件中自带的一些设置<br><code>&lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot;/&gt;</code>这里的这个路径<code>%PUBLIC_URL%</code>表示的是 public 这个文件夹的路径<br><code>&lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot; /&gt;</code>用于配置浏览器页签+地址栏的颜色（仅安卓手机浏览器），兼容性不好，不常用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Web site created using create-react-app&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>上面这个标签为网页提供一个描述，告诉浏览者们网页的用处<br><code>&lt;link rel=&quot;apple-touch-icon&quot; href=&quot;%PUBLIC_URL%/logo192.png&quot; /&gt;</code>这个的作用比较奇怪，就是在 ios 端，当你想要将一个网页放到主屏幕时，会显示这个图片。也就是在主屏幕上显示的，类似于 app 图标的图片。<br>可以在网页外面加壳，从而将一个网页变成一个 apk 文件。<code>&lt;link rel=&quot;manifest&quot; href=&quot;%PUBLIC_URL%/manifest.json&quot; /&gt;</code>这个 json 文件决定了网页加壳时的一些设置。<br><code>&lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;</code>若浏览器不支持 js，则显示标签内的内容<br><code>robots.txt</code>决定了爬虫的规则，是爬虫规则文件</p><ol start="3"><li>src 文件夹中：<ol><li>app.js 和 app.css 组成了一个 app 组件。因为在 public 文件夹里的 index.html 中有一个<code>&lt;div id=&#39;root&#39;&gt;&lt;/div&gt;</code>，这个就是虚拟 dom 需要渲染的节点，而 app 组件就是渲染到这个这个节点上的唯一组件。其他组件需要当作 app 的子组件。</li><li>app.test.js 用做测试 app 组件</li><li>index.js 是入口文件。这里引入了 app 组件，并在页面上进行渲染。index.css 是他的样式文件。</li><li><code>&lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;</code>这个的目的是检查 App 组件，会提醒一些写的不合理的东西</li><li>reportWebVital.js 是做页面性能检测的</li><li>setupTests.js 是做组件检测的</li></ol></li><li>主要编写的内容就是 public&#x2F;index.html 和 src&#x2F;App.js 和 src&#x2F;index.js</li></ol><h1 id="二、脚手架学习"><a href="#二、脚手架学习" class="headerlink" title="二、脚手架学习"></a>二、脚手架学习</h1><h2 id="2-1-基本内容的编写"><a href="#2-1-基本内容的编写" class="headerlink" title="2.1 基本内容的编写"></a>2.1 基本内容的编写</h2><p>首先是<code>public/index,html</code>，因为这部分只负责引入一个用于渲染的节点。所以内容比较简单。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello-React<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其次是<code>src/App.js</code>，这部分是组件的主要内容,也是组件最后汇总的地方</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建“外壳”组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="comment">// 引用，但是js后缀可以省略</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Hello</span> <span class="keyword">from</span> <span class="string">&quot;./components/Hello/Hello.js&quot;</span>;</span><br><span class="line"><span class="comment">// 省略型引用</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Welcome</span> <span class="keyword">from</span> <span class="string">&quot;./components/Welcome&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并暴露App组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Hello</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Welcome</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过引入两个子组件来完成组件的设置。子组件的引用有两种方式，一种是通过直接引用。另一种是如果文件夹中的 js&#x2F;jsx 文件命名为 index.js，则可以省略。<br>并通过暴露这个 App 组件使得能被 index.js 调用<br><code>src/index.js</code>主要负责的就是渲染组件到页面上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure><p>子组件以<code>Hello.js</code>为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./Hello.css&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">className</span>=<span class="string">&quot;title&quot;</span>&gt;</span>Hello,react!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-1-React18-的一些新特性"><a href="#2-1-1-React18-的一些新特性" class="headerlink" title="2.1.1 React18 的一些新特性"></a>2.1.1 React18 的一些新特性</h3><p><code>ReactDOM.render</code>在 React18 中被废弃了，取而代之的是<code>createRoot render</code><br>现在需要首先提取出这个节点，在这个节点上使用 createRoot 方法，之后在将其渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染</span></span><br><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"><span class="comment">// Create a root.</span></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(container);</span><br><span class="line"><span class="comment">// Initial render: Render an element to the root.</span></span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure><p>并且需要注意的是：<code>import ReactDOM from &#39;react-dom/client&#39;</code>引用改成了这种形式。</p><h2 id="2-2-样式的模块化"><a href="#2-2-样式的模块化" class="headerlink" title="2.2 样式的模块化"></a>2.2 样式的模块化</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> hello <span class="keyword">from</span> <span class="string">&quot;./Hello.module.css&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">className</span>=<span class="string">&#123;hello.title&#125;</span>&gt;</span>Hello,react!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过给 css 文件命名为<code>xxx.module.css</code>来将样式文件进行模块化。之后就能在 js 文件中进行 import 调用了。<br>在下面的样式引用时，可以通过调用<code>className=&#123;hello.title&#125;</code>这种类型来进行样式的调用。</p><h2 id="2-3-vscode-中的-React-插件"><a href="#2-3-vscode-中的-React-插件" class="headerlink" title="2.3 vscode 中的 React 插件"></a>2.3 vscode 中的 React 插件</h2><p><code>ES7+ React/Redux/React-Native snippets</code><br>提供 rcc&#x2F;rfc&#x2F;等快捷键<br><code>React Native Tools</code><br>提供 ren 等快捷键 0<br><code>React Style Helper</code></p><p>比较推荐这三个插件。-.-</p><h2 id="2-5-组件化编码流程"><a href="#2-5-组件化编码流程" class="headerlink" title="2.5 组件化编码流程"></a>2.5 组件化编码流程</h2><ol><li>拆分组件：拆分界面，抽取组件</li><li>实现静态组件：使用组件实现静态页面效果</li><li>实现动态组件<ol><li>动态显示初始化数据<ol><li>数据类型</li><li>数据名称</li><li>保存在哪个组件</li></ol></li><li>交互（从绑定事件监听开始）</li></ol></li></ol><h1 id="三、react-ajax"><a href="#三、react-ajax" class="headerlink" title="三、react ajax"></a>三、react ajax</h1><ol><li>React 本身只关注于界面，并不发送 ajax 请求的代码</li><li>前端应用需要通过 ajax 请求与后台进行交互（json 数据）</li><li>react 应用需要集成第三方 ajax 库或自己封装</li><li>不建议使用 ajax。建议使用<strong>axios</strong>，可以在浏览器端和 node 服务器端</li></ol><h2 id="3-1-axios"><a href="#3-1-axios" class="headerlink" title="3.1 axios"></a>3.1 axios</h2><p>为了使用 axios，应该使用 yarn 或者 npm 添加 axios<br><code>yarn add axios</code>或者是<code>npm install axios</code><br>ajax 引擎因为有同源策略，所以说不好使用跨域请求。<br>如果想要给其他端口发送请求，需要开启一个<strong>中间服务器</strong>，比如浏览器端口为 3000，需要请求的端口是 5000。就可以通过一个开在 3000 端口的中间服务器，而这个中间服务器是没有 ajax 引擎的。所以说不存在同源策略。首先浏览器发送请求到中间服务器，中间服务器转交到 5000 端口的后端服务器。之后再返回到 3000 的中间服务器。因为两个服务器的端口都是 3000，所以不会产生跨域请求，这时候就能把请求传回来咧。这样就完成了一次请求。</p><p>第一种方式：</p><ol><li>在<code>package.json</code>中添加<code>&quot;proxy&quot;:&quot;http://localhost:5000&quot;</code>，意思就是向 5000 端口进行代理。但是这种代理是有局限性的</li><li><code>axios.get(&#39;http://localhost:3000/students&#39;)</code>在 axios 端向 3000 端口发送请求，如果在 3000 端口没有这个文件，则会向 5000 端口进行转发</li><li>这种方式的局限性就是如果本来的端口就存在这个文件，则会首先请求本身端口的文件，而不是请求服务器端的文件。只有本身没有这个文件，才会向服务器端请求。</li></ol><p>说明：</p><ol><li>优点：配置简单，前端请求资源时可以不加任何前缀。</li><li>缺点：不能配置多个代理。</li><li>工作方式：上述方式配置代理，当请求了 3000 不存在的资源时，那么该请求会转发给 5000 （优先匹配前端资源）</li></ol><p>第二种方式：<br>在 src 文件夹中新建<code>setupProxy.js</code>,创建代理配置文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="built_in">require</span>(<span class="string">&quot;http-proxy-middleware&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">app</span>) &#123;</span><br><span class="line">app.<span class="title function_">use</span>(</span><br><span class="line"><span class="title function_">createProxyMiddleware</span>(<span class="string">&quot;/api1&quot;</span>, &#123;</span><br><span class="line"><span class="comment">//api1是需要转发的请求(所有带有/api1前缀的请求都会转发给5000)</span></span><br><span class="line"><span class="attr">target</span>: <span class="string">&quot;http://localhost:5000&quot;</span>, <span class="comment">//配置转发目标地址(能返回数据的服务器地址)</span></span><br><span class="line"><span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">//控制服务器接收到的请求头中host字段的值</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span></span><br><span class="line"><span class="comment">         changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:3000</span></span><br><span class="line"><span class="comment">         changeOrigin默认值为false，但我们一般将changeOrigin值设为true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="attr">pathRewrite</span>: &#123; <span class="string">&quot;^/api1&quot;</span>: <span class="string">&quot;&quot;</span> &#125;, <span class="comment">//去除请求前缀，保证交给后台服务器的是正常请求地址(必须配置)</span></span><br><span class="line">&#125;),</span><br><span class="line"><span class="title function_">createProxyMiddleware</span>(<span class="string">&quot;/api2&quot;</span>, &#123;</span><br><span class="line"><span class="attr">target</span>: <span class="string">&quot;http://localhost:5001&quot;</span>,</span><br><span class="line"><span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">pathRewrite</span>: &#123; <span class="string">&quot;^/api2&quot;</span>: <span class="string">&quot;&quot;</span> &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>优点：可以配置多个代理，可以灵活的控制请求是否走代理。</li><li>缺点：配置繁琐，前端请求资源时必须加前缀。</li></ol><h2 id="3-2-兄弟组件之间的数据通信"><a href="#3-2-兄弟组件之间的数据通信" class="headerlink" title="3.2 兄弟组件之间的数据通信"></a>3.2 兄弟组件之间的数据通信</h2><p>通过消息订阅——发布机制<br>通过工具库：PubSubJS 来实现<br>通过<code>yarn add pubsub-js</code>或<code>npm install pubsub-js</code>来添加这个库</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过这个表达发布机制，也就是通过其发布信息</span></span><br><span class="line"><span class="title class_">PubSub</span>.<span class="title function_">publish</span>(<span class="string">&quot;信息名&quot;</span>, &#123; <span class="attr">key</span>: value &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是订阅机制，也就是当在组件中接收到信息名，则会执行回调函数</span></span><br><span class="line"><span class="title class_">PubSub</span>.<span class="title function_">subscribe</span>(<span class="string">&quot;信息名&quot;</span>, <span class="function">(<span class="params">name, data</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><p>通过这两个就能够实现兄弟组件间的通信，比如在一个组件中进行信息的发布，之后在另一个组件中进行信息的订阅。<br>通过这样就能够简单的实现 state 的更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如说一个组件发布state的更新</span></span><br><span class="line"><span class="title class_">PubSub</span>.<span class="title function_">publish</span>(<span class="string">&#x27;data&#x27;</span>,&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个组件在组件挂载时，进行订阅并进行状态的更新</span></span><br><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">token</span> = <span class="title class_">PubSub</span>.<span class="title function_">subscribe</span>(<span class="string">&#x27;data&#x27;</span>,<span class="function">(<span class="params">_,stateObj</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(stateObj)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在被卸载时，将这个订阅取消掉</span></span><br><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">PubSub</span>.<span class="title function_">unsubscribe</span>(<span class="variable language_">this</span>.<span class="property">token</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以通过这种方式，可以进行任意组件间的通信，不光局限于父子组件或兄弟组件。</p><h2 id="3-3-fetch"><a href="#3-3-fetch" class="headerlink" title="3.3 fetch"></a>3.3 fetch</h2><p>特点：</p><ol><li>原生函数，和 xhr 是并列的。不使用 xhr 提交 ajax 请求</li><li>老版本浏览器可能不支持</li></ol><p>xhr 不符合关注分离的原则。<br>fetch 是符合 promise 的风格的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;联系服务器成功了&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>()&#125;</span><br><span class="line">).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取数据成功了&#x27;</span>,response);&#125;</span><br><span class="line">).<span class="title function_">catch</span>(</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求出错&#x27;</span>,error);</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面这个例子就是一个关注分离的例子，就是 fetch 请求可能能够连接服务器，但如果错误的调用，是不能够获取数据的。<br>要是连接服务器都失败，那么有可能是服务器离线。<br>最后通过 catch 来兜底，统一处理错误</p><p>或者可以使用<code>async</code>和<code>await</code>进行处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">xxx</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求出错&quot;</span>, error);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="四、React-路由"><a href="#四、React-路由" class="headerlink" title="四、React 路由"></a>四、React 路由</h1><h2 id="4-1-相关理解"><a href="#4-1-相关理解" class="headerlink" title="4.1 相关理解"></a>4.1 相关理解</h2><h3 id="4-1-1-SPA"><a href="#4-1-1-SPA" class="headerlink" title="4.1.1 SPA"></a>4.1.1 SPA</h3><ol><li>单页 web 应用（single page web application，SPA）</li><li>整个应用只有<strong>一个完整的页面</strong></li><li>点击页面中的链接<strong>不会刷新</strong>页面，只会做页面的<strong>局部更新</strong></li><li>数据都需要通过 ajax 请求获取，并在前端异步展现</li></ol><h3 id="4-1-2-路由-Route"><a href="#4-1-2-路由-Route" class="headerlink" title="4.1.2 路由(Route)"></a>4.1.2 路由(Route)</h3><ol><li>什么是路由？<ol><li>一个路由是一个映射关系(key:value)</li><li>key 为路径(path)，value 可能是 function 或是 component</li></ol></li><li>路由的种类：<ol><li>后端路由：<ol><li>理解：value 为 function，用来处理客户端提交的请求</li><li>注册路由：router.get(path,function(req,res))</li><li>工作过程：当 node 接收到一个请求时，根据请求路径找到匹配的路由，调用路由中的函数来处理请求，返回响应函数</li></ol></li><li>前端路由：<ol><li>浏览器端路由，value 是 component，用于展示页面内容</li><li>注册路由：<code>&lt;Route path=&#39;/test component=&#123;Test&#125;&#39;&gt;</code></li><li>工作过程：当浏览器的 path 变为&#x2F;test 时，当前路由组件就会变成 Test 组件</li></ol></li></ol></li><li>浏览器的历史记录是以栈的形式存在的，当浏览一条记录时，将这条记录压入栈中，当回退时，将当前记录出栈，则暴露了上一条记录。</li></ol><h2 id="4-2-history"><a href="#4-2-history" class="headerlink" title="4.2 history"></a>4.2 history</h2><ol><li>使用 H5 推出的 history 身上的 api 来操纵历史记录的前进和后退等</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> history = <span class="title class_">History</span>.<span class="title function_">createBrowserHistory</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">push</span>(<span class="params">path</span>) &#123;</span><br><span class="line">history.<span class="title function_">push</span>(path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">replace</span>(<span class="params">path</span>) &#123;</span><br><span class="line">history.<span class="title function_">replace</span>(path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">back</span>(<span class="params"></span>) &#123;</span><br><span class="line">history.<span class="title function_">goBack</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">forward</span>(<span class="params"></span>) &#123;</span><br><span class="line">history.<span class="title function_">goForward</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 hash 值(锚点)来操纵<code>let history = History.createHarshHistory()</code></li></ol><h2 id="4-3-react-router"><a href="#4-3-react-router" class="headerlink" title="4.3 react-router"></a>4.3 react-router</h2><ol><li>react 的一个插件库</li><li>专门用来实现一个 SPA 应用</li><li>共分为三部分，分别给 web、native、any 使用</li><li>前端使用的主要是 react-router-dom</li><li>下载：<code>npm i react-router-dom</code></li><li>引入 css 文件时要注意不要加<code>.</code>。应该使用<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;/bootstrap.css&quot;&gt;</code>或者用%形式写也行。负责会出现<strong>样式丢失</strong>的问题。</li><li>与 React Router 5.x 版本的区别：<ul><li>内置组件的变化：移除<code>&lt;Switch/&gt;</code>，新增<code>&lt;Routes/&gt;</code>……</li><li>语法变化：<code>component=&#123;About&#125;</code>变成<code>element=&#123;&lt;About/&gt;&#125;</code>……</li><li>新增 hook：useParams、useNavigate、useMatch……</li><li>官方明确表示推荐使用函数式组件</li></ul></li></ol><h3 id="4-3-1-一级路由"><a href="#4-3-1-一级路由" class="headerlink" title="4.3.1 一级路由"></a>4.3.1 一级路由</h3><p>首先下载并引入路由，在 index.js 中通过 BrowserRouter&#x2F;HashRouter 对 App 组件进行包裹，这意味着进行了路由的包裹<br>但是 HashRouter 传递的 path 为<code>localhost:3000/#/....</code>，#后面的参数都不会给服务器传递。所以最好还是用<code>BrowserRouter</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入库</span></span><br><span class="line"><span class="comment">// 从 react-dom/client 引入 ReactDOM</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&quot;react-dom/client&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BrowserRouter</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// React 18 的语法发生改变了</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>)).<span class="title function_">render</span>(</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>之后在 App.js 中进行路由链接和注册路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NavLink</span>, <span class="title class_">Routes</span>, <span class="title class_">Route</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&quot;./components/Home&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&quot;./components/About&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;list-group&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;/* 路由链接 */&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">About</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">Home</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 注册路由 */</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="title class_">Routes</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">About</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line">&lt;/<span class="title class_">Routes</span>&gt;;</span><br></pre></td></tr></table></figure><ol><li>路由链接：<ol><li>原生 html 中，靠<code>&lt;a&gt;</code>来跳转不同的页面。在 React 中靠路由链接实现切换组件<code>&lt;NavLink className=&quot;list-group-item&quot; to=&quot;/about&quot;&gt;About&lt;/NavLink&gt;</code></li><li>或者是<code>&lt;Link className=&quot;list-group-item&quot; to=&quot;/about&quot;&gt;About&lt;/Link&gt;</code>。</li><li>需要注意的是，to 后面跟的路径不能带<code>.</code></li><li>NavLink 默认会给链接添加一个 active 属性。或者可以添加一个属性<code>activeClassName = &#39;&#39;</code>从而对点击的链接添加一个独特的属性。</li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">BrowserRouter</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">About</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">BrowserRouter</span>&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>注册路由：</p><ol><li><code>&lt;Routes&gt;</code>用于对注册路由的组件进行包裹。当 url 变化时，<code>&lt;Routes&gt;</code>会查看所有子<code>&lt;Route&gt;</code>元素以找到最佳匹配并呈现组件</li><li>而<code>&lt;Route&gt;</code>组件的格式为固定的<code>&lt;Route path=&#39;/about&#39; element=&#123;&lt;About/&gt;&#125; /&gt;</code>，其中 path 前面不要加<code>.</code>。因为可能会出现格式加载的问题。element 里面是引用的组件。</li><li><code>&lt;Routes&gt;</code>和<code>&lt;Route&gt;</code>要配合使用，且必须用<code>&lt;Routes&gt;</code>包裹<code>&lt;Route&gt;</code></li><li><code>&lt;Route&gt;</code>相当于一个 if 语句，如果其路径与当前 url 匹配，则呈现对应的组件</li><li><code>&lt;Route caseSensitive&gt;</code>属性用于指定匹配时是否区分大小写（默认为 false）</li></ol></li><li><p>路由组件和一般组件的区别：</p><ol><li>接收到的 props 不同：路由组件的 props 传递了三组固定的属性（history、location、match），一般组件的 props 为传递的东西</li><li>写法不同：路由组件需要通过路由器进行渲染(<code>&lt;Route path=&#39;/home&#39; element=&#123;&lt;Home/&gt;&#125; /&gt;</code>)，一般组件是直接进行渲染(<code>&lt;Demo/&gt;</code>)</li><li>位置不同：一般组件位于 components 文件夹，路由组件位于 pages 文件夹</li></ol></li></ol><h3 id="4-3-2-封装-NavLink-组件"><a href="#4-3-2-封装-NavLink-组件" class="headerlink" title="4.3.2 封装 NavLink 组件"></a>4.3.2 封装 NavLink 组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>,&#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">NavLink</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">MyNavLink</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">activeClassName</span>=<span class="string">&#x27;xxx&#x27;</span> <span class="attr">className</span>=<span class="string">&#x27;xx&#x27;</span> &#123;<span class="attr">this.props</span>&#125;/&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样将其封装成一个一般组件，之后调用 NavLink 时就可以简单的调用咧。<code>&lt;MyNavLink to=&#39;xxx&#39; /&gt;</code></p><h3 id="4-3-3-重定向"><a href="#4-3-3-重定向" class="headerlink" title="4.3.3 重定向"></a>4.3.3 重定向</h3><p>使用<code>&lt;Navigate&gt;</code>组件可以完成重定向，其只要被渲染，就会修改路径，切换视图。<br>其可以添加 replace 属性，默认为 push。如果<code>replace=&#123;true&#125;</code>则为 replace 模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Navigate</span>&#125; <span class="keyword">from</span><span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> [sum,setSum ] = <span class="title function_">useState</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;sum ===1 ? <span class="tag">&lt;<span class="name">h4</span>&gt;</span>sum的值为&#123;sum&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span> : <span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span> = <span class="string">&#x27;/about&#x27;</span> <span class="attr">replace</span>= <span class="string">&#123;true&#125;</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setSum(2)&#125;&gt;点我将sum变为2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  )</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="4-3-4-路由表"><a href="#4-3-4-路由表" class="headerlink" title="4.3.4 路由表"></a>4.3.4 路由表</h3><p>通过 useRoutes 使用路由表<br>首先在.&#x2F;src 中建立一个 routes 文件夹用于存放路由规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&quot;../pages/About&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&quot;../pages/Home&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Navigate</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>,</span><br><span class="line"><span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">About</span> /&gt;</span></span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,</span><br><span class="line"><span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line"><span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span> /&gt;</span></span>,</span><br><span class="line">&#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>在这个路由规则文件中调用组件和其他，并将路由规则通过数组形式暴露出去。<br>之后在 App 中引用这个文件，使用 useRoutes 来调用这些规则，之后在返回时，就可以方便的调用这些组件了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">NavLink</span>,useRoutes&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">&#x27;./routes&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> element = <span class="title function_">useRoutes</span>(routes)</span><br><span class="line"><span class="keyword">return</span>&#123;</span><br><span class="line">&#123;element&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-5-嵌套路由"><a href="#4-3-5-嵌套路由" class="headerlink" title="4.3.5 嵌套路由"></a>4.3.5 嵌套路由</h3><p>嵌套路由中，需要使用<code>&lt;Outlet&gt;</code>设置子路由的路由出口，即在何处渲染子路由。<br>设置二级路由链接时，可以是 to&#x3D;”news”、to&#x3D;”.&#x2F;news”，但不能是 to&#x3D;”&#x2F;news”。<br>不使用路由表的嵌套路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;hello&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;about&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">About</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Hello</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;news&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">News</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;message&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Message</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;about&quot;</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用路由表的嵌套路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>,</span><br><span class="line"><span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">About</span> /&gt;</span></span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,</span><br><span class="line"><span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span>,</span><br><span class="line"><span class="comment">// 设置二级路由</span></span><br><span class="line"><span class="attr">children</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;news&quot;</span>,</span><br><span class="line"><span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">News</span> /&gt;</span></span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;message&quot;</span>,</span><br><span class="line"><span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Message</span> /&gt;</span></span>,</span><br><span class="line"><span class="comment">// 设置三级路由</span></span><br><span class="line"><span class="attr">children</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;detail&quot;</span>,</span><br><span class="line"><span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Detail</span> /&gt;</span></span>,</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line"><span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span> /&gt;</span></span>,</span><br><span class="line">&#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>使用时需要通过 Outlet 来决定嵌套路由的呈现位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NavLink</span>, <span class="title class_">Outlet</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Home组件内容<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">className</span>=<span class="string">&quot;nav nav-tabs&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">to</span>=<span class="string">&quot;news&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">News</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">to</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">Message</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;/* 指定路由组件的呈现位置 */&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Outlet</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-6-路由传参"><a href="#4-3-6-路由传参" class="headerlink" title="4.3.6 路由传参"></a>4.3.6 路由传参</h3><h4 id="4-3-6-1-传递-params-参数"><a href="#4-3-6-1-传递-params-参数" class="headerlink" title="4.3.6.1 传递 params 参数"></a>4.3.6.1 传递 params 参数</h4><p>注册路由时声明 params 参数，和 React Router 5 一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Hello</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;message&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Message</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;detail/:id/:name/:age&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Detail</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Link</span> to=&#123;<span class="string">`detail/<span class="subst">$&#123;item.id&#125;</span>/<span class="subst">$&#123;item.name&#125;</span>/<span class="subst">$&#123;item.age&#125;</span>`</span>&#125;&gt;&#123;item.<span class="property">name</span>&#125;&lt;/<span class="title class_">Link</span>&gt;</span><br></pre></td></tr></table></figure><p>使用 useParams() 接收 params 参数。useParams() 返回一个参数对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useParams, useMatch &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Detail</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line"><span class="keyword">const</span> &#123; id, name, age &#125; = <span class="title function_">useParams</span>();</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>id:&#123;id&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>name:&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>age:&#123;age&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是最麻烦的，需要在三个地方进行传参，如果不适用路由表，需要首先在 App 组件内传递参数。使用路由表则是在 routes&#x2F;index.js 中传参。<br>接下来需要在传递的组件中规定传递的参数。最后在接收的组件接收参数。</p><h4 id="4-3-6-2-传递-search-参数"><a href="#4-3-6-2-传递-search-参数" class="headerlink" title="4.3.6.2 传递 search 参数"></a>4.3.6.2 传递 search 参数</h4><p>传递参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Link</span> to=&#123;<span class="string">`detail?id=<span class="subst">$&#123;item.id&#125;</span>&amp;name=<span class="subst">$&#123;item.name&#125;</span>&amp;age=<span class="subst">$&#123;item.age&#125;</span>`</span>&#125;&gt;</span><br><span class="line">&#123;item.<span class="property">name</span>&#125;</span><br><span class="line">&lt;/<span class="title class_">Link</span>&gt;</span><br></pre></td></tr></table></figure><p>使用 useSearchParams() 接收参数。该方法返回一个包含两个元素的数组：search 参数和修改 search 参数的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useSearchParams &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Detail</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 数组的解构赋值</span></span><br><span class="line"><span class="keyword">const</span> [searchParams, setSearchParams] = <span class="title function_">useSearchParams</span>();</span><br><span class="line"><span class="comment">// 需要调用 get() 方法获取对应的参数值</span></span><br><span class="line"><span class="keyword">const</span> id = searchParams.<span class="title function_">get</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> name = searchParams.<span class="title function_">get</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> age = searchParams.<span class="title function_">get</span>(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">change</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">setSearchParams</span>(<span class="string">&quot;id=666&amp;name=Lily&amp;age=888&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>id:&#123;id&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>name:&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>age:&#123;age&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;change&#125;</span>&gt;</span>Change search params<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法会稍微好一点，因为他不需要修改 App 中或路由表中的内容，只需要对传递和接收的组件进行修改。</p><h4 id="4-3-6-3-传递-state-参数"><a href="#4-3-6-3-传递-state-参数" class="headerlink" title="4.3.6.3 传递 state 参数"></a>4.3.6.3 传递 state 参数</h4><p>传递 state 参数比较方便，只需要在 link 里添加一个 state 对象就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;messages.map((m) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">return (</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;m.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Link</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">to</span>=<span class="string">&quot;detail&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">state</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">id:</span> <span class="attr">m.id</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">title:</span> <span class="attr">m.title</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">content:</span> <span class="attr">m.content</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;m.title&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> showDetail(m)&#125;&gt;查看详情<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">);</span></span><br><span class="line"><span class="language-xml">&#125;)&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Outlet</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>之后在接收端，使用 useLocation() 接收参数。该方法返回路由组件的 location 对象，就是 5 版本路由组件的 location 属性，其中包含 state 参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useLocation &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Detail</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; state &#125; = <span class="title function_">useLocation</span>();</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>消息编号：&#123;state.id&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>消息标题：&#123;state.title&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>消息内容：&#123;state.content&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-7-编程式路由导航"><a href="#4-3-7-编程式路由导航" class="headerlink" title="4.3.7 编程式路由导航"></a>4.3.7 编程式路由导航</h3><p>此处使用了一个完整的例子。useNavigate() 返回一个函数，调用该函数实现编程式路由导航。函数有两种参数传递方式。</p><p>第一种方式传递两个参数：路由和相关参数。参数只能设置 replace 和 state。想要传递 params 和 search 参数直接在路由带上。</p><p>第二种方式传递数字，代表前进或后退几步。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Link</span>, <span class="title class_">Outlet</span>, useNavigate &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Message</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> navigate = <span class="title function_">useNavigate</span>();</span><br><span class="line"><span class="keyword">const</span> [messages] = <span class="title function_">useState</span>([</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="string">&quot;001&quot;</span>, <span class="attr">title</span>: <span class="string">&quot;消息1&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;锄禾日当午&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="string">&quot;002&quot;</span>, <span class="attr">title</span>: <span class="string">&quot;消息2&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;汗滴禾下土&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="string">&quot;003&quot;</span>, <span class="attr">title</span>: <span class="string">&quot;消息3&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;谁知盘中餐&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="string">&quot;004&quot;</span>, <span class="attr">title</span>: <span class="string">&quot;消息4&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;粒粒皆辛苦&quot;</span> &#125;,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showDetail</span>(<span class="params">m</span>) &#123;</span><br><span class="line"><span class="title function_">navigate</span>(<span class="string">&quot;detail&quot;</span>, &#123;</span><br><span class="line"><span class="attr">replace</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">state</span>: &#123;</span><br><span class="line"><span class="attr">id</span>: m.<span class="property">id</span>,</span><br><span class="line"><span class="attr">title</span>: m.<span class="property">title</span>,</span><br><span class="line"><span class="attr">content</span>: m.<span class="property">content</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;messages.map((m) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">return (</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;m.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Link</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">to</span>=<span class="string">&quot;detail&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">state</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">id:</span> <span class="attr">m.id</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">title:</span> <span class="attr">m.title</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">content:</span> <span class="attr">m.content</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;m.title&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> showDetail(m)&#125;&gt;查看详情<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">);</span></span><br><span class="line"><span class="language-xml">&#125;)&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Outlet</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是使用了给一般组件外带路由组件的属性。并通过绑定鼠标点击事件来给它赋予前进和后退的意义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useNavigate &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Header</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> navigate = <span class="title function_">useNavigate</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">back</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">navigate</span>(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">forward</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">navigate</span>(+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;col-xs-offset-2 col-xs-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;page-header&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>React Router Demo<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;back&#125;</span>&gt;</span>←后退<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;forward&#125;</span>&gt;</span>前进→<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-8-其他-HOOK"><a href="#4-3-8-其他-HOOK" class="headerlink" title="4.3.8 其他 HOOK"></a>4.3.8 其他 HOOK</h3><p><strong>useMatch()</strong><br>返回路由组件的 match 数据，即 5 版本中的 match 属性。</p><p>必须传入该组件对应的路由规则才能正确返回，否则返回 null。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Detail.jsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; useParams, useMatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Detail</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> match = <span class="title function_">useMatch</span>(<span class="string">&#x27;hello/message/detail/:id/:name/:age&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(match)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>id<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">params: &#123;id: &#x27;1&#x27;, name: &#x27;Bruce&#x27;, age: &#x27;33&#x27;&#125;</span></span><br><span class="line"><span class="comment">pathname: &quot;/hello/message/detail/1/Bruce/33&quot;</span></span><br><span class="line"><span class="comment">pathnameBase: &quot;/hello/message/detail/1/Bruce/33&quot;</span></span><br><span class="line"><span class="comment">pattern: &#123;path: &#x27;hello/message/detail/:id/:name/:age&#x27;, caseSensitive: false, end: true&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>useInRouterContext()</strong><br>如果组件在<code>&lt;Router&gt;</code>的上下文中呈现，则 useInRouterContext 钩子返回 true，否则返回 false。即组件有没有被包裹在<code>&lt;BrowserRouter&gt;</code>这种东西里面。这个对第三方组件库有用处。</p><p><strong>useNavigationType()</strong><br>返回当前的导航类型（用户是如何来到当前页面的）。</p><p>返回值：POP、PUSH、REPLACE。</p><p>POP 是指在浏览器中直接打开了这个路由组件（刷新页面）。</p><p><strong>useOutlet()</strong><br>用来呈现当前组件中渲染的嵌套路由。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="title function_">useOutlet</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line"><span class="comment">// 如果嵌套路由没有挂载,则返回 null</span></span><br><span class="line"><span class="comment">// 如果嵌套路由已经挂载,则展示嵌套的路由对象</span></span><br></pre></td></tr></table></figure><p><strong>useResolvedPath()</strong><br>给定一个 URL 值，解析其中的：path、search、hash 值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> res = <span class="title function_">useResolvedPath</span>(<span class="string">&#x27;/user?id=001&amp;name=Bruce#React&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hash: &#x27;#React&#x27;</span></span><br><span class="line"><span class="comment">pathname: &#x27;/user&#x27;</span></span><br><span class="line"><span class="comment">search: &#x27;?id=001&amp;name=Bruce&#x27;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="五、React-UI-组件库"><a href="#五、React-UI-组件库" class="headerlink" title="五、React UI 组件库"></a>五、React UI 组件库</h1><h2 id="5-1-material-ui"><a href="#5-1-material-ui" class="headerlink" title="5.1 material-ui"></a>5.1 material-ui</h2><p>官网：<a href="http://www.material-ui.com/">http://www.material-ui.com</a></p><h2 id="5-2-ant-design"><a href="#5-2-ant-design" class="headerlink" title="5.2 ant-design"></a>5.2 ant-design</h2><p>官网：<a href="https://ant.design/index-cn">https://ant.design/index-cn</a></p><h2 id="5-3-使用-antd"><a href="#5-3-使用-antd" class="headerlink" title="5.3 使用 antd"></a>5.3 使用 antd</h2><p>下载<code>npm i antd</code><br>感觉具体用法直接看官方文档用就完事了</p><p>要是需要暴露脚手架内容从而引用需要的 antd 样式。需要先使用 eject 将脚手架暴露，之后通过<code>react-app-rewired</code>和<code>customize-cra</code>来修改文件。<br>具体内容看官方文档吧</p><p>并且可以自定义主题</p><h1 id="六、redux"><a href="#六、redux" class="headerlink" title="六、redux"></a>六、redux</h1><h2 id="6-1-redux-理解"><a href="#6-1-redux-理解" class="headerlink" title="6.1 redux 理解"></a>6.1 redux 理解</h2><p>官方文档：<a href="https://redux.js.org/">https://redux.js.org/</a><br>中文文档：<a href="http://www.redux.org.cn/">http://www.redux.org.cn/</a></p><h3 id="6-1-1-redux-是什么"><a href="#6-1-1-redux-是什么" class="headerlink" title="6.1.1 redux 是什么"></a>6.1.1 redux 是什么</h3><ol><li>redux 是一个专门用于做<strong>状态管理</strong>的 js 库(不是 react 插件库)</li><li>可以在 react、angular、vue 等项目中，但基本使用与 react 中</li><li>作用：集中式管理 react 应用中多个组件共享的状态</li></ol><h3 id="6-1-2-什么情况下需要使用-redux"><a href="#6-1-2-什么情况下需要使用-redux" class="headerlink" title="6.1.2 什么情况下需要使用 redux"></a>6.1.2 什么情况下需要使用 redux</h3><ol><li>某个组件的状态，需要让其他组件可以随时拿到(共享)</li><li>一个组件需要改变另一个组件的状态(通信)</li><li>总体原则：能不用就不用，如果不用比较吃力才考虑使用</li></ol><h2 id="6-2-工作流程"><a href="#6-2-工作流程" class="headerlink" title="6.2 工作流程"></a>6.2 工作流程</h2><p><img src="/./../img/redux%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="redux"></p><h2 id="6-3-redux-使用"><a href="#6-3-redux-使用" class="headerlink" title="6.3 redux 使用"></a>6.3 redux 使用</h2><p>下载：<code>npm install --save redux</code><br>现在官方推荐使用 Redux Toolkit 使用 redux<br>官方文档：<a href="https://redux-toolkit.js.org/">https://redux-toolkit.js.org/</a><br>下载方式：<code>npm install @reduxjs/toolkit</code><br>或者可以使用 React 和 Redux 启动新应用程序的推荐方法是使用官方 Redux+JS 模板或 Redux+TS 模板来创建 React App，它利用了 Redux Toolkit 和 React Redux 与 React 组件的集成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Redux + Plain JS template</span><br><span class="line">npx create-react-app my-app --template redux</span><br><span class="line"></span><br><span class="line"># Redux + TypeScript template</span><br><span class="line">npx create-react-app my-app --template redux-typescript</span><br></pre></td></tr></table></figure><h1 id="七、-项目打包"><a href="#七、-项目打包" class="headerlink" title="七、 项目打包"></a>七、 项目打包</h1><p>首先执行<code>npm run build</code>，此时会生成一个 build 目录<br>可以通过 node 或者 js 放到服务器上打包<br>或者通过 serve 库来打包项目<code>npm i serve -g</code>。其的作用就是快速开启一台服务器<br>之后执行命令<code>serve build</code>来快速上线一个项目。当然这只是本地的一种简易方法，真实部署项目还是需要通过正经途径来滴。</p><h1 id="八、react-扩展内容"><a href="#八、react-扩展内容" class="headerlink" title="八、react 扩展内容"></a>八、react 扩展内容</h1><h2 id="8-1-setState-的两种方式"><a href="#8-1-setState-的两种方式" class="headerlink" title="8.1 setState 的两种方式"></a>8.1 setState 的两种方式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Count</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line">add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; count &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象式的setState</span></span><br><span class="line"><span class="comment">// this.setState(&#123;count: count + 1&#125;,()=&gt;&#123;</span></span><br><span class="line"><span class="comment">//     console.log(this.state.count);</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式的setState</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span> &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>当前求和为：&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.add&#125;</span>&gt;</span>点我加一<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>setState(stateChange,[callback])</code>————对象式的 setState<ol><li>stateChange 为状态改变对象（该对象可以体现出状态的更改）</li><li>callback 是可选的回调函数，它在状态更新完毕，界面也更新后（render 调用后）才被调用</li><li>因为 setState 是异步的，所以如果想在外部查看最新的值可能会失败，所以说如果想要查看最新的值或者进行什么操作应该写在回调函数里</li></ol></li><li><code>setState(updater,[callback])</code>————函数式的 setState<ol><li>updater 为返回 stateChange 对象的函数</li><li>updater 可以接收到 state 和 props</li><li>callback 是可选的回调函数，它在状态更新、界面更新后才被调用</li></ol></li><li>总结：<ol><li>对象式的 setState 是函数式的 setState 的简写方式（语法糖）</li><li>如果新状态不依赖于原状态&#x3D;&gt;使用对象方式</li><li>如果新状态依赖于原状态&#x3D;&gt;使用函数方式</li></ol></li></ol><h2 id="8-2-lazyLoad"><a href="#8-2-lazyLoad" class="headerlink" title="8.2 lazyLoad"></a>8.2 lazyLoad</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; lazy &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="comment">// import About from &#x27;../pages/About&#x27;</span></span><br><span class="line"><span class="comment">// import Home from &#x27;../pages/Home&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Navigate</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Home</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../pages/Home&quot;</span>));</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">About</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../pages/About&quot;</span>));</span><br></pre></td></tr></table></figure><p>通过引入 lazy 函数来实现懒加载。需要抛弃以前的引入形式，因为如果直接用 import 引入的话，就会直接加载咧。<br>所以要懒加载的话，需要通过 lazy 函数来调用加载。<br>调用懒加载的话，就需要指定一个 fallback 来指定当懒加载没有加载完毕时的<strong>等待组件或函数等</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Suspense</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NavLink</span>, useRoutes &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">&quot;./routes&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;panel-body&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;/* 注册路由 */&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">h1</span>&gt;</span>Loading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#125;&gt;&#123;element&#125;<span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>所以需要引入 Suspense 并通过其包裹注册路由的地方，给其加入 fallback 函数。<br>当然这个地方的函数可以是一个组件，也可以就是一个标签。<br>但是如果这里是一个组件的话，这个组件<strong>不能够使用懒加载</strong>，必须使用 import 进行引入</p><h2 id="8-3-Hooks"><a href="#8-3-Hooks" class="headerlink" title="8.3 Hooks"></a>8.3 Hooks</h2><ol><li>Hook 是 React 16.8 版本增加的新特性&#x2F;新语法</li><li>可以让你在函数组件中使用 state 以及其他的 React 组件</li><li>正是因为 Hook 的存在，所以说现在 React 更推荐使用函数式组件来进行编程</li></ol><h3 id="8-3-1-State-Hook"><a href="#8-3-1-State-Hook" class="headerlink" title="8.3.1 State Hook"></a>8.3.1 State Hook</h3><ol><li>State Hook 让函数组件也可以有 state 状态，并进行状态数据的读写操作</li><li>语法： <code>const[value,setValue] = React.useState(initValue)</code></li><li>useState()说明：<ol><li>参数：第一次初始化指定的值在内部作缓存</li><li>返回值：包含 2 个元素的数组，第一个为内部当前状态值，第二个为更新状态的函数</li></ol></li><li>setValue()的两种写法：<ol><li>setValue(newValue):参数为非函数值，直接指定新的状态值，内部用其覆盖原来的状态值</li><li>setValue(value &#x3D;&gt; newValue):参数为函数，接收原本的状态值，返回新的状态值，内部用其覆盖原来的状态值</li></ol></li></ol><h3 id="8-3-2-Effect-Hook"><a href="#8-3-2-Effect-Hook" class="headerlink" title="8.3.2 Effect Hook"></a>8.3.2 Effect Hook</h3><ol><li>Effect Hook 可以让你在函数组件中执行副作用操作（用于模拟类组件中的生命周期钩子）</li><li>React 中的副作用操作：<ol><li>发送 ajax 请求</li><li>设置订阅、启动定时器</li><li>手动更改真实 dom</li></ol></li><li>语法和说明：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 在此可以执行任何带副作用操作</span></span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 在组件卸载前执行</span></span><br><span class="line"><span class="comment">// 在此做一些收尾工作，比如清除定时器/取消订阅等</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;, []); <span class="comment">//如果指定的是[]，回调函数只会在第一次render()后执行</span></span><br></pre></td></tr></table></figure><ol start="4"><li>可以把 useEffect Hook 看做如下三个函数的组合：<ol><li>componentDidMount()</li><li>componentDidUpdate()</li><li>componentWillUnmount()</li></ol></li></ol><p>需要注意的是，在 react18 中，传统的卸载组件方式已经被弃用了，取而代之的是<code>unmount()</code>。<br>但是因为 react18 中，渲染方式也被重写了，所以需要注意一些地方。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 react-dom/client 引入 ReactDOM</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&quot;react-dom/client&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// React 18 的语法发生改变了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br><span class="line"></span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> root;</span><br></pre></td></tr></table></figure><p>首先需要将定义的 root 暴露出去，这样才能进行调用并卸载。<br>之后在需要进行卸载的地方，通过引入<code>index.js</code>并且调用<code>root.unmount()</code>来卸载组件</p><h3 id="8-3-3-Ref-Hook"><a href="#8-3-3-Ref-Hook" class="headerlink" title="8.3.3 Ref Hook"></a>8.3.3 Ref Hook</h3><ol><li>Ref Hook 可以在函数组件中存储&#x2F;查找组件内的标签或任意其他数据</li><li>语法：<code>const myRef = React.useRef()</code></li><li>作用：保存标签对象，功能与<code>React.createRef()</code>一样</li></ol><h3 id="8-3-4-示例"><a href="#8-3-4-示例" class="headerlink" title="8.3.4 示例"></a>8.3.4 示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> root <span class="keyword">from</span> <span class="string">&quot;./index&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myRef = <span class="title class_">React</span>.<span class="title function_">useRef</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">setCount</span>(<span class="function">(<span class="params">count</span>) =&gt;</span> count + <span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">clearInterval</span>(timer);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// setCount(count+1);</span></span><br><span class="line"><span class="title function_">setCount</span>(<span class="function">(<span class="params">count</span>) =&gt;</span> count + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">alert</span>(myRef.<span class="property">current</span>.<span class="property">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">remove</span>(<span class="params"></span>) &#123;</span><br><span class="line">root.<span class="title function_">unmount</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;myRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前求和为：&#123;count&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;add&#125;</span>&gt;</span>点我+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;remove&#125;</span>&gt;</span>点我卸载<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;show&#125;</span>&gt;</span>点我提示数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-4-Fragment"><a href="#8-4-Fragment" class="headerlink" title="8.4 Fragment"></a>8.4 Fragment</h2><p>React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Columns</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>World<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Fragments 能够正确的生成节点</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>World<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以像使用其他任意元素一样使用 &lt;&gt; &lt;&#x2F;&gt;，但它并不支持 key 或属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Columns</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>World<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Fragments 可以传递 key。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Glossary</span>(<span class="params">props</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;props.items.map((item) =&gt; (</span></span><br><span class="line"><span class="language-xml">// 没有`key`，React 会发出一个关键警告</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>&#123;item.term&#125;<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>&#123;item.description&#125;<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">))&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-5-Context"><a href="#8-5-Context" class="headerlink" title="8.5 Context"></a>8.5 Context</h2><p>一种组件间通信方式，常用于【祖组件】和【后代组件】间通信</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./index.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>();</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Provider</span>, <span class="title class_">Consumer</span> &#125; = <span class="title class_">MyContext</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">state = &#123; <span class="attr">username</span>: <span class="string">&quot;tom&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; username, age &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是A组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>我的用户名是：&#123;username&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;</span> <span class="attr">username</span>, <span class="attr">age</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">B</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是B组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>我的用户名是：<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">C</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class C extends Component &#123;</span></span><br><span class="line"><span class="comment">//     static contextType = MyContext;</span></span><br><span class="line"><span class="comment">//     render() &#123;</span></span><br><span class="line"><span class="comment">//         return (</span></span><br><span class="line"><span class="comment">//             &lt;div className=&quot;grand&quot;&gt;</span></span><br><span class="line"><span class="comment">//             &lt;h3&gt;我是C组件&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">//             &lt;h4&gt;我的用户名是：&#123;this.context&#125;&lt;/h4&gt;</span></span><br><span class="line"><span class="comment">//         &lt;/div&gt;</span></span><br><span class="line"><span class="comment">//         )</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;grand&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是C组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">我的用户名是：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Consumer</span>&gt;</span>&#123;(value) =&gt; `$&#123;value.username&#125;年龄是$&#123;value.age&#125;`&#125;<span class="tag">&lt;/<span class="name">Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><ol><li>创建 Context 容器：<code>const xxxContext = React.createContext()</code></li><li>渲染子组件时，外面包裹 XXXContext.Provider,通过 value 属性给后代组件传递数据：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Provider</span> value=&#123;&#123; username, age &#125;&#125;&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">B</span> /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Provider</span>&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>后代组件读取数据：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种：仅适用于类组件</span></span><br><span class="line"><span class="keyword">static</span> contextType = <span class="title class_">MyContext</span>; <span class="comment">//声明接收context</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">context</span> <span class="comment">//读取context中的value数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种：函数组件和类式组件都可以</span></span><br><span class="line">&lt;xxxContext.<span class="property">Consumer</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="params">value</span> =&gt;</span>&#123;   <span class="comment">//value就是context中的value数据</span></span><br><span class="line">            要显示的内容</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/xxxContext.<span class="property">Consumer</span>&gt;</span><br></pre></td></tr></table></figure></li></ol><p><strong>在实际开发中，一般不用context，因为redux可以更好的替代它</strong></p><h2 id="8-6-组件优化"><a href="#8-6-组件优化" class="headerlink" title="8.6 组件优化"></a>8.6 组件优化</h2><p>问题：</p><ul><li>只要调用<code>setState()</code>，即使没有修改状态，组件也会重新<code>render()</code></li><li>只要父组件重新渲染，即使子组件没有使用父组件的状态，也会重新<code>render()</code></li></ul><p>原因：</p><ul><li><code>shouldComponentUpdate()</code>钩子默认总是返回 true</li></ul><p>改进：</p><ul><li>只有组件的<code>state</code>或<code>props</code>的数据发生改变时才重新渲染</li></ul><p>方式：</p><ul><li>手动重写<code>shouldComponentUpdate(nextProps, nextState)</code>的逻辑，只有数据发生改变才返回<code>true</code></li><li>使用<code>PureComponent</code>，它重写了<code>shouldComponentUpdate()</code>， 只有<code>state</code>或<code>props</code>数据有变化才返回<code>true</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">PureComponent</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">PureComponent</span> &#123;</span><br><span class="line">  addStu = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 不会渲染</span></span><br><span class="line">    <span class="keyword">const</span> &#123; stus &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">    stus.<span class="title function_">unshift</span>(<span class="string">&#x27;小刘&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; stus &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新渲染</span></span><br><span class="line">    <span class="keyword">const</span> &#123; stus &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">stus</span>: [<span class="string">&#x27;小刘&#x27;</span>, ...stus] &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>它只是进行<code>state</code>和<code>props</code>数据的浅比较, 如果只是数据对象内部数据变了, 返回<code>false</code>。即对于引用数据类型，比较的是地址引用</li><li>不要直接修改<code>state</code>数据, 而是要产生新数据</li></ul><h2 id="8-7-render-props-插槽"><a href="#8-7-render-props-插槽" class="headerlink" title="8.7 render props(插槽)"></a>8.7 render props(插槽)</h2><p>React中向组件内部动态传入带内容的结构（即标签或组件）</p><ol><li>使用<code>children props</code>：通过组件标签体传入结构</li><li>使用<code>render props</code>：通过组件标签属性传入结构，可携带数据</li></ol><h3 id="8-7-1-children-props方式"><a href="#8-7-1-children-props方式" class="headerlink" title="8.7.1 children props方式"></a>8.7.1 children props方式</h3><p>组件标签体内容会存储到<code>this.props.children</code>中<br>缺点：A 组件无法向 B 组件传递数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Parent组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">A</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">B</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">A</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123; <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span> &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>A组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>B组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-7-2-render-props方式"><a href="#8-7-2-render-props方式" class="headerlink" title="8.7.2 render props方式"></a>8.7.2 render props方式</h3><ul><li><code>&lt;A render=&#123;(name) =&gt; &lt;B name=&#123;name&#125; /&gt;&#125; /&gt;</code></li><li><code>&#123;this.props.render(name)&#125;</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Parent组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">A</span> <span class="attr">render</span>=<span class="string">&#123;(name)</span> =&gt;</span> <span class="tag">&lt;<span class="name">B</span> <span class="attr">name</span>=<span class="string">&#123;name&#125;</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123; <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span> &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>A组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.props.render(name)&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>B组件,&#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="8-8-错误边界"><a href="#8-8-错误边界" class="headerlink" title="8.8 错误边界"></a>8.8 错误边界</h2><p>错误边界(Error boundary)：用来捕获后代组件错误，渲染出备用页面。<br><strong>注意：只在生产环境（项目上线）起效</strong></p><p>特点：</p><ul><li>只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误</li><li>简单理解就是只能捕获后代组件生命周期钩子里面代码的错误</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="comment">//用于标识子组件是否产生错误</span></span><br><span class="line">    <span class="attr">hasError</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当子组件出现错误，会触发调用，并携带错误信息</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// render 之前触发</span></span><br><span class="line">    <span class="comment">// 返回新的 state</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: error &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子组件产生错误时调用该钩子</span></span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">error, info</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error, info)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;此处统计错误，反馈给服务器&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Parent组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.state.hasError ? <span class="tag">&lt;<span class="name">h2</span>&gt;</span>网络不稳定，稍后再试<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> : <span class="tag">&lt;<span class="name">Child</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、使用-create-react-app-创建-react-应用&quot;&gt;&lt;a href=&quot;#一、使用-create-react-app-创建-react-应用&quot; class=&quot;headerlink&quot; title=&quot;一、使用 create-react-app 创建 react 应用&quot;&gt;&lt;/a&gt;一、使用 create-react-app 创建 react 应用&lt;/h1&gt;&lt;h2 id=&quot;1-1-react-脚手架&quot;&gt;&lt;a href=&quot;#1-1-react-脚手架&quot; class=&quot;headerlink&quot; title=&quot;1.1 react 脚手架&quot;&gt;&lt;/a&gt;1.1 react 脚手架&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;脚手架就是用来帮助快速创建一个基于 xxx 库的模板项目&lt;ol&gt;
&lt;li&gt;包含所有需要的配置(语法检查，jsx 编译，devServer…)&lt;/li&gt;
&lt;li&gt;下载好了所有相关的依赖&lt;/li&gt;
&lt;li&gt;可以直接运行一个简单效果&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;react 提供了一个用于创建 react 项目的脚手架库:create-react-app&lt;/li&gt;
&lt;li&gt;项目的整体技术架构为：react+webpack+es6+eslint&lt;/li&gt;
&lt;li&gt;使用脚手架开发的项目的特点：模块化，组件化，工程化&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>React基础</title>
    <link href="http://example.com/2022/12/26/react/"/>
    <id>http://example.com/2022/12/26/react/</id>
    <published>2022-12-26T09:00:00.000Z</published>
    <updated>2023-03-20T08:32:36.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><ol><li>发送请求获取数据</li><li>处理数据（过滤、整理格式等）</li><li><strong>操作 DOM 呈现页面</strong>（这一步是 react 的主要目的）</li></ol><p>所以说 react 是一个将数据渲染为 HTML 视图的开源 js 库</p><p>原生 js 特点：</p><ol><li>原生 js 操作 dom 繁琐，效率低</li><li>使用 js 直接操作 dom，浏览器会进行大量的重绘重排</li><li>原生 js 没有<strong>组件化</strong>编码方案，代码复用率低</li></ol><p>react 特点：</p><ol><li>采用<strong>组件化</strong>模式，<strong>声明式</strong>编码，提高开发效率及组件复用率</li><li>在 React Native 中可以使用 React 语法进行移动端开发</li><li>使用<strong>虚拟 dom</strong>和优秀的<strong>diffing 算法</strong>，尽量减少与真实 dom 的交互</li></ol><p>中文官网：<code>https://react.docschina.org</code></p><span id="more"></span><h1 id="二、入门"><a href="#二、入门" class="headerlink" title="二、入门"></a>二、入门</h1><h2 id="2-1-引入-react"><a href="#2-1-引入-react" class="headerlink" title="2.1 引入 react"></a>2.1 引入 react</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jsx组件库，用于将jsx转为js</span></span><br><span class="line">&lt;script src=<span class="string">&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="comment">// react核心库</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@16/umd/react.development.js&quot;</span> <span class="attr">crossorigin</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">// react扩展库，用于支持react操作dom</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;</span> <span class="attr">crossorigin</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="2-2-虚拟-DOM-和真实-DOM"><a href="#2-2-虚拟-DOM-和真实-DOM" class="headerlink" title="2.2 虚拟 DOM 和真实 DOM"></a>2.2 虚拟 DOM 和真实 DOM</h2><p>创建一个虚拟 DOM：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">VDOM</span> = (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello,react<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol><li><strong>虚拟 DOM 的本质是 Object 类型的对象（一般对象）</strong></li><li>虚拟 DOM 比较轻，真实 DOM 比较“重”，因为虚拟 DOM 是 React 内部在用，无需真实 DOM 上那么多的属性</li><li>虚拟 DOM 最终会被转换为真实 DOM 并渲染在页面上</li></ol><h2 id="2-3-jsx-语法"><a href="#2-3-jsx-语法" class="headerlink" title="2.3 jsx 语法"></a>2.3 jsx 语法</h2><p>全称：JavaScriptXML<br>XML 早期用于存储和传输数据</p><ol><li>定义虚拟 DOM 时，不要写引号</li><li>标签混入 js<strong>表达式</strong>时要用{}</li><li>样式的类名指定不要用 class，要用 className</li><li>内联样式，要用<code>style=&#123;&#123;key:value&#125;&#125;</code>的形式去写</li><li>只能有一个根标签</li><li>标签必须闭合</li><li>标签首字母<ol><li>若小写字母开头，则将该标签转为 html 中同名元素，若 html 中无该标签对应的同名元素，则报错</li><li>若大写字母开头，react 就去渲染对应的组件，若组件没有定义，则报错</li></ol></li><li>对于 jsx 中的每个元素，都需要产生一个<strong>唯一对应</strong>的 key</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [<span class="string">&quot;Angular&quot;</span>, <span class="string">&quot;React&quot;</span>, <span class="string">&quot;Vue&quot;</span>];</span><br><span class="line"><span class="comment">// 1.创建虚拟DOM</span></span><br><span class="line"><span class="keyword">const</span> vDom = (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>前端js框架列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;data.map((item, index) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">return <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>;</span></span><br><span class="line"><span class="language-xml">&#125;)&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 2.渲染页面</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(vDom, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure><p>要注意区分 js 语句和 js 表达式</p><ol><li>表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方<ol><li>a</li><li>a+b</li><li>demo(1)</li><li>arr.map()</li><li>function test()</li></ol></li><li>语句：控制代码语句，不会产生值<ol><li>if(){}</li><li>for(){}</li><li>switch(){case:}</li></ol></li></ol><h2 id="2-4-组件与模块"><a href="#2-4-组件与模块" class="headerlink" title="2.4 组件与模块"></a>2.4 组件与模块</h2><h3 id="2-4-1-模块"><a href="#2-4-1-模块" class="headerlink" title="2.4.1 模块"></a>2.4.1 模块</h3><ol><li>模块就是向外提供特定功能的 js 程序，一般就是一个 js 文件</li><li>为什么要拆成模块：随着业务逻辑的增加，代码越来越多且复杂</li><li>作用：复用 js，简化 js 的编写，提高 js 的运行效率</li><li>当应用的 js 都以模块化来编写的，这个应用就是一个模块化的应用</li></ol><h3 id="2-4-2-组件"><a href="#2-4-2-组件" class="headerlink" title="2.4.2 组件"></a>2.4.2 组件</h3><ol><li>用来实现局部功能效果的代码和资源的集合（html&#x2F;css&#x2F;js&#x2F;image 等等）</li><li>通过组件化，可以复用编码，简化项目编码，提高运行效率</li></ol><h2 id="2-5-jsx-奇怪的注释方法"><a href="#2-5-jsx-奇怪的注释方法" class="headerlink" title="2.5 jsx 奇怪的注释方法"></a>2.5 jsx 奇怪的注释方法</h2><p>jsx 中写注释，平时没啥事儿，都是以<code>//</code>形式的，但是如果在一个有 html 结构的地方写注释就很奇怪了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* 就必须以这种方式写注释。也就是在注释外面包一个&#123;&#125;*/ &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、React-面向组件编程"><a href="#三、React-面向组件编程" class="headerlink" title="三、React 面向组件编程"></a>三、React 面向组件编程</h1><h2 id="3-1-函数式组件"><a href="#3-1-函数式组件" class="headerlink" title="3.1 函数式组件"></a>3.1 函数式组件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Demo</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">//此处的this是undefined，因为babel编译后开启了严格模式</span></span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello,React<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 渲染组件到页面</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Demo</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>)); <span class="comment">//这里的原理就是通过大写字母开头的标签去调用组件，之后在通过/来结束这个标签</span></span><br></pre></td></tr></table></figure><h2 id="3-2-类式组件"><a href="#3-2-类式组件" class="headerlink" title="3.2 类式组件"></a>3.2 类式组件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建类式组件,react中的类必须继承于react中内置的父类React.Component</span></span><br><span class="line"><span class="comment">//render中的this是MyComponent的实例对象 &lt;=&gt; MyComponent组件实例对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello,Class<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.渲染组件到页面</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 执行了ReactDOM.render(&lt;MyComponent/&gt;...之后，发生了什么？</span></span><br><span class="line"><span class="comment"> * 1.React解析组件标签，找到了MyComponent组件</span></span><br><span class="line"><span class="comment"> * 2.发现组件是用类定义的，随后new出来该类的实例，并通过该实例调用到原型上的render方法</span></span><br><span class="line"><span class="comment"> * 3.将render返回的虚拟DOM转为真实DOM，随后呈现在页面中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>很奇怪，这里出现了个奇怪的 bug，还没法复现，属于是莫名其妙，找了好久也没找到为啥。。。</p><h2 id="3-3-组件实例的三大核心"><a href="#3-3-组件实例的三大核心" class="headerlink" title="3.3 组件实例的三大核心"></a>3.3 组件实例的三大核心</h2><p>组件实例指的是类式组件，因为函数组件里都没有 this，没法玩实例。</p><h3 id="3-3-1-state"><a href="#3-3-1-state" class="headerlink" title="3.3.1 state"></a>3.3.1 state</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weather</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line"><span class="variable language_">super</span>(props);</span><br><span class="line"><span class="comment">// 2.初始化状态</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line"><span class="attr">isHot</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">wind</span>: <span class="string">&quot;微风&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 3.读取状态</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="comment">// 这里其实是错的，因为changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用</span></span><br><span class="line"><span class="comment">// 而且类中的方法默认开启了局部的严格模式，所以changeWeather中的this是undefined</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeWeather&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">今天天气很&#123;this.state.isHot ? &quot;炎热&quot; : &quot;凉爽&quot;&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">changeWeather</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4.渲染</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Weather</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure><p>state 的是以 key 和 value 成键值存在的。和 python 中的字典类似。其主要目的就是储存一些自定义的变量值，以便以后进行调用或修改。</p><p>其中存在 this 的调用问题，因为在 class 类里会自动设置<strong>严格模式</strong>，所以说，如果在外部调用 this 会显示 undefined。<br>就算在类里<strong>直接调用</strong>，也会显示 undefined。只有通过<strong>实例调用</strong>，才能正确的调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Weather</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="comment">// 构造器只调用1次</span></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line"><span class="variable language_">super</span>(props);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">isHot</span>: <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">demo</span> = <span class="variable language_">this</span>.<span class="property">test</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// render调用1+n次，1是初始化的那次，n是状态更新的次数</span></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.demo&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">今天天气很&#123;this.state.isHot ? &quot;炎热&quot; : &quot;凉爽&quot;&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 点几次，调用几次</span></span><br><span class="line"><span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> isHot = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">isHot</span>;</span><br><span class="line"><span class="comment">// 状态必须通过setState进行改变，并且这种状态改变是合并不是替换</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">isHot</span>: !isHot &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是正确的写法，为了好理解，我改变了函数的名称。test 函数会将其自身传递到原型链上，所以说<code>this.test</code>可以通过去寻找原型链找到 test 函数，但因为其是直接调用，所以说这时候的 this 还是 undefined。但是其通过<code>bind()</code>函数，将其转换成了一个新的函数，并且赋予了其一个新的 this，所以说这个时候<code>this.test.bind()</code>变成了一个拥有类的 this 的函数，所以说这时候通过赋值语句给<code>this.demo</code>,这时候就把 this 成功的传递了。</p><p><strong>状态必须通过<code>setState()</code>进行改变，并且这种状态改变是合并不是替换</strong></p><h4 id="3-3-1-1-简写方式"><a href="#3-3-1-1-简写方式" class="headerlink" title="3.3.1.1 简写方式"></a>3.3.1.1 简写方式</h4><p>类中可以直接写赋值语句，所以可以将 state 直接写到类里进行赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Weather</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">state = &#123; <span class="attr">isHot</span>: <span class="literal">false</span>, <span class="attr">wind</span>: <span class="string">&quot;微风&quot;</span> &#125;;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 这里通过定义一个对象就能够在下面直接进行调用了</span></span><br><span class="line"><span class="keyword">const</span> &#123; isHot, wind &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeWeather&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">今天天气很&#123;isHot ? &quot;炎热&quot; : &quot;凉爽&quot;&#125;,&#123;wind&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义方法</span></span><br><span class="line"><span class="comment">// 通过赋值语句和箭头函数来实现寻找this</span></span><br><span class="line">changeWeather = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 这里也是同理</span></span><br><span class="line"><span class="keyword">const</span> isHot = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">isHot</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">isHot</span>: !isHot &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件中 render 方法中的 this 为组件实例对象<br>组建中自定义方法的 this 为 undefined，必须通过<strong>bind 方法</strong>或者<strong>箭头函数</strong>来寻找 this。</p><h3 id="3-3-2-props"><a href="#3-3-2-props" class="headerlink" title="3.3.2 props"></a>3.3.2 props</h3><h4 id="3-3-2-1-…运算符的用法"><a href="#3-3-2-1-…运算符的用法" class="headerlink" title="3.3.2.1 …运算符的用法"></a>3.3.2.1 …运算符的用法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>];</span><br><span class="line"><span class="comment">// 1. 将一个数组展开</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...arr1); <span class="comment">//1,3,5,7,9</span></span><br><span class="line"><span class="comment">// 2. 合并两个数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...arr1, ...arr2); <span class="comment">//1,3,5,7,9,2,4,6,8,10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 运用在函数中，传递一系列参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...numbers</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> numbers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">preValue, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> currentValue + preValue;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: jack, <span class="attr">age</span>: <span class="number">20</span> &#125;;</span><br><span class="line"><span class="comment">// 4. 值的复制</span></span><br><span class="line"><span class="keyword">let</span> person2 = &#123; ...person &#125;; <span class="comment">// &#123;name:jack, age:20&#125;</span></span><br><span class="line"><span class="comment">// 5. 值的复制和修改</span></span><br><span class="line"><span class="keyword">let</span> person3 = &#123; ...person, <span class="attr">name</span>: <span class="string">&quot;tom&quot;</span> &#125;; <span class="comment">// &#123;name:tom, age:20&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-2-2-props-解析"><a href="#3-3-2-2-props-解析" class="headerlink" title="3.3.2.2 props 解析"></a>3.3.2.2 props 解析</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; name, age, sex &#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>性别：&#123;age&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>年龄：&#123;sex&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对标签属性进行类型、必要性的限制</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>, <span class="comment">//限制传递类型为string，必须传递</span></span><br><span class="line"><span class="attr">sex</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="title class_">PropTypes</span>.<span class="property">number</span>,</span><br><span class="line"><span class="attr">speak</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>, <span class="comment">//限制传递类型为函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 对标签默认值进行限制</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">defaultProps</span> = &#123;</span><br><span class="line"><span class="attr">sex</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="number">222</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 可以对输入数据进行赋值类型的传递</span></span><br><span class="line"><span class="keyword">const</span> p = &#123; <span class="attr">name</span>: <span class="string">&quot;wh&quot;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">sex</span>: <span class="string">&quot;man&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 在渲染时，可以通过&#123;...p&#125;这种类型来进行值的传递</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Person</span> &#123;<span class="attr">...p</span>&#125; /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>));</span><br><span class="line"><span class="comment">// 或者说可以通过在标签中内置属性来进行数据的传递</span></span><br><span class="line"><span class="comment">// 但其实这两种处理方式的本质是相同的，都是在标签里输入数据来传递</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&quot;whh&quot;</span> <span class="attr">sex</span>=<span class="string">&quot;man&quot;</span> /&gt;</span></span>,</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test1&quot;</span>)</span><br><span class="line">); <span class="comment">//因为没传入age，所以会有一个默认age</span></span><br><span class="line"><span class="comment">// 因为age是一个数字类型，不能够使用&#x27;&#x27;进行传入，只能够通过&#123;&#125;来传入</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&quot;haha&quot;</span> <span class="attr">age</span>=<span class="string">&#123;16&#125;</span> /&gt;</span></span>,</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test2&quot;</span>)</span><br><span class="line">); <span class="comment">//因为没有sex，会传入一个默认sex。</span></span><br></pre></td></tr></table></figure><p>需要注意的是，为了添加限制性语句，也就是<code>propTypes</code>类型的语句，必须添加下面的 script 标签。因为自从 react15 以来，就把这部分内容移出去了。<br>需要单独进行调用。<br><code>&lt;script src=&quot;https://unpkg.com/prop-types@15.6/prop-types.js&quot;&gt;&lt;/script&gt;</code></p><p>需要注意的是：props 是<strong>只读</strong>的，不能<strong>直接进行修改</strong></p><h4 id="3-3-2-3-props-简写"><a href="#3-3-2-3-props-简写" class="headerlink" title="3.3.2.3 props 简写"></a>3.3.2.3 props 简写</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; name, age, sex &#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>性别：&#123;age&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>年龄：&#123;sex&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> propTypes = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>, <span class="comment">//限制传递类型为string，必须传递</span></span><br><span class="line"><span class="attr">sex</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="title class_">PropTypes</span>.<span class="property">number</span>,</span><br><span class="line"><span class="attr">speak</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>, <span class="comment">//限制传递类型为函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line"><span class="attr">sex</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="number">222</span>,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>props 的简写核心就是将<code>propTypes</code>和<code>defaultProps</code>置入类内部，通过给其添加一个 <strong>静态属性</strong> <code>static</code>从而实现</p><h4 id="3-3-2-4-构造器与-props"><a href="#3-3-2-4-构造器与-props" class="headerlink" title="3.3.2.4 构造器与 props"></a>3.3.2.4 构造器与 props</h4><p>在 react 中，<strong>一般情况下 constructor 都可以进行省略</strong>。<br>只有两种情况需要使用构造器：</p><ol><li>通过给<code>this.state</code>赋值对象来初始化内部<code>state</code>。</li><li>为事件处理函数绑定实例</li></ol><p>但是初始化内部 state 可以通过在类中直接<code>state=&#123;&#125;</code>来进行<br>而自定义事件处理函数可以通过<code>demo = () =&gt;&#123;&#125;</code>这种箭头函数的形式来实现</p><p>但是如果使用构造器，一定不能省略<code>super()</code><br>但是几乎用不到这种情况，可能会出现未定义的 bug。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="comment">// 构造器是否接收props，是否传递给super，取决于：是否希望在构造器中通过this访问props</span></span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以说，开发过程中最好别写构造器</strong></p><h4 id="3-3-2-5-函数式组件使用-props"><a href="#3-3-2-5-函数式组件使用-props" class="headerlink" title="3.3.2.5 函数式组件使用 props"></a>3.3.2.5 函数式组件使用 props</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">props</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; name, age, sex &#125; = props;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>年龄：&#123;age&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>性别：&#123;sex&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&quot;wh&quot;</span> <span class="attr">age</span>=<span class="string">&#123;18&#125;</span> <span class="attr">sex</span>=<span class="string">&quot;male&quot;</span> /&gt;</span></span>,</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>因为函数能够传递参数，所以说能够使用 props，但是不能使用 state</p><h3 id="3-3-3-refs"><a href="#3-3-3-refs" class="headerlink" title="3.3.3 refs"></a>3.3.3 refs</h3><h4 id="3-3-3-1-字符串形式的-ref"><a href="#3-3-3-1-字符串形式的-ref" class="headerlink" title="3.3.3.1 字符串形式的 ref"></a>3.3.3.1 字符串形式的 ref</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;点击按钮提示数据&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;input1&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.showData&#125;</span> <span class="attr">ref</span>=<span class="string">&quot;button&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;&quot; &quot;&#125;</span></span><br><span class="line"><span class="language-xml">点击按钮显示数据</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">placeholder</span>=<span class="string">&quot;失去焦点显示数据&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">ref</span>=<span class="string">&quot;input2&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">onBlur</span>=<span class="string">&#123;this.showData2&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 展示左侧输入框的数据</span></span><br><span class="line">showData = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// console.log(this.refs.input1);</span></span><br><span class="line"><span class="keyword">const</span> &#123; input1 &#125; = <span class="variable language_">this</span>.<span class="property">refs</span>;</span><br><span class="line"><span class="title function_">alert</span>(input1.<span class="property">value</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//展示右侧输入框的数据</span></span><br><span class="line">showData2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; input2 &#125; = <span class="variable language_">this</span>.<span class="property">refs</span>;</span><br><span class="line"><span class="title function_">alert</span>(input2.<span class="property">value</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件内的标签可以定义 ref 属性来标识自己，和 id 类似<br>ref 的形式也是以 key,value 形式来进行的。<br>key 为 ref 的名字，value 为具体的某个标签<br><code>&lt;input type=&quot;text&quot; placeholder=&#39;点击按钮提示数据&#39; ref=&#39;input1&#39;/&gt;</code></p><p><strong>string 类型的 ref 已经过时了</strong>，可能未来会被移除掉。<br>其存在一些效率上的问题。具体情况可以在 github 讨论区中看。</p><h4 id="3-3-3-2-回调形式的-ref"><a href="#3-3-3-2-回调形式的-ref" class="headerlink" title="3.3.3.2 回调形式的 ref"></a>3.3.3.2 回调形式的 ref</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;(currentNode)</span> =&gt;</span> (this.input1 = currentNode)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.showInfo&#125;</span>&gt;</span>点击提示数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showInfo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; input1 &#125; = <span class="variable language_">this</span>;</span><br><span class="line"><span class="title function_">alert</span>(input1.<span class="property">value</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过回调函数的形式也可以定义 ref。<code>&lt;input type=&quot;text&quot; ref = &#123;currentNode =&gt; this.input1 = currentNode&#125;/&gt;</code><br>但是如果 ref 回调函数是以<strong>内联函数</strong>的方式定义的，在<strong>更新过程中</strong>它会被执行两次，第一次传入参数 null，然后第二次会传入参数 DOM 元素。<br>但如果是不会更新的元素是没有影响的。因为 render 的执行次数是 1+n 次，第一次是没有影响的。只有第二次开始为更新，会产生影响。<br>内联函数类似于：<code>&lt;input ref = &#123;(c) =&gt; &#123;this.input = c; console.log(c);&#125;&#125;/&gt;</code><br><strong>通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span> = <span class="string">&#123;this.saveInput&#125;/</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">saveInput</span>(<span class="params">c</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">input1</span> = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-3-createRef"><a href="#3-3-3-3-createRef" class="headerlink" title="3.3.3.3 createRef"></a>3.3.3.3 createRef</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="comment">// React.createRef 调用后可以返回一个容器，该容器可以储存被ref所标识的节点</span></span><br><span class="line"><span class="comment">// 该容器是专人专用的</span></span><br><span class="line"><span class="comment">// 所以说每一次使用都得创建一个新的容器，好麻烦啊</span></span><br><span class="line">myRef = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">myRef2 = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;HELLO&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef2&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.showData&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">点击获取</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showData = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">myRef</span>.<span class="property">current</span>.<span class="property">value</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>React.createRef</code>每次只能存储一个节点，也就是说每一个标签想使用都需要创建一个单独的容器。</p><p><strong>ref 有一个很重要的点，就是不要过渡使用 ref</strong></p><h4 id="3-3-3-4-react-的事件处理"><a href="#3-3-3-4-react-的事件处理" class="headerlink" title="3.3.3.4 react 的事件处理"></a>3.3.3.4 react 的事件处理</h4><ol><li>通过 onXxx 属性指定事件处理函数（注意大小写）<ol><li>React 使用的是自定义(合成)事件，而不是使用的原生 DOM 事件 ————为了更好的兼容性</li><li>React 中的事件是通过事件委托方式处理的(委托给组件最外层的元素) ————为了更高效</li></ol></li><li>通过<code>event.target</code>得到发生事件的 DOM 元素对象 ———— 通过这种方式可以有效的减少 ref 的使用<ol><li>当需要处理的事件和需要添加的 ref 位于相同标签内时，可以省略 ref，通过<code>event.target</code>来在事件内寻找所需的属性</li></ol></li></ol><h2 id="3-5-收集表单数据"><a href="#3-5-收集表单数据" class="headerlink" title="3.5 收集表单数据"></a>3.5 收集表单数据</h2><h3 id="3-5-1-受控组件"><a href="#3-5-1-受控组件" class="headerlink" title="3.5.1 受控组件"></a>3.5.1 受控组件</h3><p>页面中随着输入，不断更新和维护状态，就叫做受控组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Login</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="comment">// 初始化状态</span></span><br><span class="line">state = &#123;</span><br><span class="line"><span class="attr">username</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="attr">password</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//储存用户名，将用户名维护到state中</span></span><br><span class="line">saveUsername = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">username</span>: event.<span class="property">target</span>.<span class="property">value</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 储存密码，将密码维护到state中</span></span><br><span class="line">savePassword = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">password</span>: event.<span class="property">target</span>.<span class="property">value</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 提交请求,通过维护的状态来选取</span></span><br><span class="line">handleSubmit = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">event.<span class="title function_">preventDefault</span>();</span><br><span class="line"><span class="keyword">const</span> &#123; username, password &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">`用户名为：<span class="subst">$&#123;username&#125;</span>，密码为：<span class="subst">$&#123;password&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://whcoding.cc&quot;</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">用户名：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.saveUsername&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">密码：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.savePassword&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>受控组件比非受控组件更优秀一点,因为受控组件不使用 ref,所以应该尽量使用受控组件来进行开发</p><h3 id="3-5-2-非受控组件"><a href="#3-5-2-非受控组件" class="headerlink" title="3.5.2 非受控组件"></a>3.5.2 非受控组件</h3><p>页面中所有现用现取的组件就叫做非受控组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Login</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">handleSubmit = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">event.<span class="title function_">preventDefault</span>(); <span class="comment">//阻止默认事件</span></span><br><span class="line"><span class="keyword">const</span> &#123; inputUser, inputPass &#125; = <span class="variable language_">this</span>;</span><br><span class="line"><span class="title function_">alert</span>(</span><br><span class="line"><span class="string">`您输入的用户名是：<span class="subst">$&#123;inputUser.current.value&#125;</span>，您输入的密码是：<span class="subst">$&#123;inputPass.current.value&#125;</span>`</span></span><br><span class="line">);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inputUser = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">inputPass = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://whcoding.cc&quot;</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">用户名：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;this.inputUser&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">密码：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;this.inputPass&#125;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-高阶函数、函数柯里化"><a href="#3-6-高阶函数、函数柯里化" class="headerlink" title="3.6 高阶函数、函数柯里化"></a>3.6 高阶函数、函数柯里化</h2><p>高阶函数：如果一个函数符合下面两个规范中的任何一个，那该函数就是高阶函数：</p><ol><li>若 A 函数，接收的参数时一个函数，那么 A 就可以称之为高阶函数</li><li>若 A 函数，调用的返回值依然是一个函数，那么 A 就可以称之为高阶函数</li></ol><p>常见的高阶函数有：Promise、setTimeout、数组的一些方法，比如 arr.map()等等</p><p><strong>函数的柯里化</strong>：<br>通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">saveFormData = <span class="function">(<span class="params">dataType</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;[dataType]:event.<span class="property">target</span>.<span class="property">value</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://whcoding.cc&quot;</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        用户名：</span></span><br><span class="line"><span class="language-xml">        &#123;/*onChange的回调应该是一个函数*/&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.saveFormData(</span>&#x27;<span class="attr">username</span>&#x27;)&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">密码：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">type</span>=<span class="string">&quot;password&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">name</span>=<span class="string">&quot;password&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">onChange</span>=<span class="string">&#123;this.saveFormData(</span>&#x27;<span class="attr">password</span>&#x27;)&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 saveFormData 就运用了柯里化的概念，其首先回传了一个参数叫 dataType，也正是通过这个参数来实现了不同的数据需求。<br>之后在 return 中又返回了 event，通过 event 来寻找 value。所以说是多次接收参数最后统一处理。</p><h2 id="3-7-组件的生命周期"><a href="#3-7-组件的生命周期" class="headerlink" title="3.7 组件的生命周期"></a>3.7 组件的生命周期</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Life</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">state = &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">death = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 因为组件挂载之后，定时器一直存在，如果不在卸载组件时把定时器清除掉的话，那么就会导致把组件卸载后，定时器仍然存在，从而倒置bug</span></span><br><span class="line"><span class="comment">// 清除定时器</span></span><br><span class="line"><span class="comment">// clearInterval(this.timer);</span></span><br><span class="line"><span class="comment">// 卸载组件</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">unmountComponentAtNode</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;life&quot;</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件挂载之后，只执行一次</span></span><br><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">timer</span> = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> &#123; opacity &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">opacity -= <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">if</span> (opacity &lt;= <span class="number">0</span>) opacity = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; opacity &#125;);</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件将要卸载</span></span><br><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 在这里清除定时器也行</span></span><br><span class="line"><span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timer</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// render调用的时机：初始化渲染，状态更新之后</span></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">opacity:</span> <span class="attr">this.state.opacity</span> &#125;&#125;&gt;</span>React学不会怎么办？<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.death&#125;</span>&gt;</span>不活了<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挂载(mount),就是页面进行渲染的时候，也就是把组件挂载到了页面上。<br>卸载(unmount)，就是将组件从页面上移除，就是卸载。</p><h3 id="3-7-1-组件挂载流程"><a href="#3-7-1-组件挂载流程" class="headerlink" title="3.7.1 组件挂载流程"></a>3.7.1 组件挂载流程</h3><ol><li>组件从创建到死亡它会经历一些特定的阶段</li><li>React 组件中包含一系列钩子函数(生命周期回调函数)，会在特定的时刻调用</li><li>我们在定义组件时，会在特定的生命周期回调函数中，做特定的工作</li></ol><h4 id="3-7-1-1-react-生命周期-旧"><a href="#3-7-1-1-react-生命周期-旧" class="headerlink" title="3.7.1.1 react 生命周期(旧)"></a>3.7.1.1 react 生命周期(旧)</h4><p><img src="/../img/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%97%A7.jpg" alt="生命周期"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Count</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;count=constructor&quot;</span>);</span><br><span class="line"><span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化状态</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件将要挂载的钩子</span></span><br><span class="line"><span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Count-componentWillMount&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件挂载完毕的钩子</span></span><br><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;count-componentDidMount&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件将要卸载的钩子</span></span><br><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;count-componentWillUnmount&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制state更新的钩子</span></span><br><span class="line"><span class="title function_">shouldComponentUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;count-shouldComponentUpdate&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件将要更新的钩子</span></span><br><span class="line"><span class="title function_">componentWillUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;count-componentWillUpdate&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组件完成更新的钩子</span></span><br><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;count-componentDidUpdate&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调按钮</span></span><br><span class="line">add = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; count &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: count + <span class="number">1</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">death = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">unmountComponentAtNode</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强制更新</span></span><br><span class="line">    force = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">forceUpdate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; count &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;render&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前求和为&#123;count&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.add&#125;</span>&gt;</span>点我+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.death&#125;</span>&gt;</span>点我消失<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.force&#125;</span>&gt;</span>强制更新<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，当组件加载时，顺序为<code>constructor ---&gt; componentWillMount ---&gt; render ---&gt; componentDidMount</code></p><p>当组件将要卸载时，首先通过<code>componentWillUnmount</code>，之后再进行卸载操作</p><p><code>shouldComponentUpdate</code>是关于控制状态更新的重要钩子，如果不写的话，默认会返回 true，但如果它返回了 false，则不会执行下面的操作。<br>也就是不会执行后面的<code>setState</code>、<code>render</code>等操作。组件就会就此闭合</p><p>所以说，组件的更新周期的顺序为<code>shouldComponentUpdate ---&gt; componentWillUpdate ---&gt; render --&gt; componentDidUpdate</code><br>因为第一次不会调用<code>componentWillReceiveProps</code>,只有第二次更新才会调用这个钩子，这是个坑-。-</p><p>强制更新<code>forceUpdate()</code>，可以跳过<code>shouldComponentUpdate</code>，直接从<code>componentWillUpdate</code>开始。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    state = &#123;<span class="attr">carName</span>: <span class="string">&#x27;奔驰&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    changeCar = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">carName</span>: <span class="string">&#x27;奥拓&#x27;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是A组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeCar&#125;</span>&gt;</span>换车<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;/*通过在A中引用B让其作为子组件*/ &#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">B</span> <span class="attr">carName</span>=<span class="string">&#123;this.state.carName&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="comment">// 这里有个坑，就是第一次调用的时候，不会调用这个钩子</span></span><br><span class="line">    <span class="comment">// 只有再第二次开始调用，也就是接收新的props的钩子，才会调用这个钩子</span></span><br><span class="line">    <span class="title function_">componentWillReceiveProps</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;componentWillReceiveProps&#x27;</span>,props);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是B组件，接收到的车是：&#123;this.props.carName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-7-1-2-react生命周期（新）"><a href="#3-7-1-2-react生命周期（新）" class="headerlink" title="3.7.1.2 react生命周期（新）"></a>3.7.1.2 react生命周期（新）</h4><p>React17开始更新的了新的生命周期钩子函数，对旧版的钩子函数进行了一些改动，并且加入了一些新的钩子函数。</p><p><strong>新生命周期废弃了3个旧钩子，并添加了2个新钩子</strong><br><img src="/../img/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B0.jpg" alt="file"></p><p><strong>废弃改动：</strong></p><p><code>componentWillMount</code>、<code>componentWillReceiveProps</code>、<code>componentWillUpdate</code>这三个钩子被重命名了。<br>也就是所有带will的钩子都被改动了。除了卸载的那个钩子<br>而且在18版本，必须通过<code>UNSAFE_component...</code>才能够使用了。<br>属于是提前打预防针-。-</p><p><strong>新增改动：</strong></p><p><code>getDerivedStateFromProps</code>首先是一个静态方法，其在使用前必须添加<code>static</code>。并且其需要返回一个<code>state obj</code>或者是<code>null</code><br>此方法适用于罕见的用例，<strong>即state的值在任何时候都取决于props</strong>。</p><p>派生状态会导致代码冗余，难以维护。</p><p><code>getSnapshotBeforeUpdate(prevProps, prevState)</code>其执行顺序位于<code>render</code>和<code>componentDidUpdate</code>之间。<br>其必须返回一个<code>snapshot value</code>或者是<code>null</code>。<br><code>snapshot value</code>可以是任何值，无论是number、string或者什么东西。</p><p>其在最近一次渲染输出（提交到DOM节点）之前调用。它使得组件能在发生更改之前从DOM获取一些信息（例如：滚动位置）。<br>此生命周期的任何返回值将作为参数传递给<code>componentDidUpdate()</code>。</p><p>这个钩子函数也不常见，但它可能出现在UI处理中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个例子就是不断的创建一个新闻，但是通过钩子函数去固定页面，让其保持在一个高度。</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">NewsList</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">            state = &#123;<span class="attr">newsArr</span>:[]&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取原状态</span></span><br><span class="line">                    <span class="keyword">const</span> &#123;newsArr&#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">                    <span class="comment">// 模拟一条新闻</span></span><br><span class="line">                    <span class="keyword">const</span> news = <span class="string">&#x27;新闻&#x27;</span> + (newsArr.<span class="property">length</span>+<span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 更新状态</span></span><br><span class="line">                    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">newsArr</span>: [news,...newsArr]&#125;);</span><br><span class="line">                &#125;, <span class="number">1000</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="comment">// 这里返回的是变化前的值</span></span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">refs</span>.<span class="property">list</span>.<span class="property">scrollHeight</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState,height</span>) &#123;</span><br><span class="line">                <span class="comment">// 这里的右边前面的数是变化后的值，其和变化前的值的固定差值为一个新闻的高度。</span></span><br><span class="line">                <span class="comment">// 所以可以通过不断的加去保证其固定高度。</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">refs</span>.<span class="property">list</span>.<span class="property">scrollTop</span> += <span class="variable language_">this</span>.<span class="property">refs</span>.<span class="property">list</span>.<span class="property">scrollHeight</span> - height;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (</span><br><span class="line">                    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;list&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        &#123;</span></span><br><span class="line"><span class="language-xml">                            this.state.newsArr.map((n,index) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">                                return <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;news&#x27;</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;n&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>;</span></span><br><span class="line"><span class="language-xml">                            &#125;)</span></span><br><span class="line"><span class="language-xml">                        &#125;</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-2-总结"><a href="#3-7-2-总结" class="headerlink" title="3.7.2 总结"></a>3.7.2 总结</h3><ol><li>初始化阶段： 由ReactDOM.render()触发 ——————初次渲染<ol><li>constructor()</li><li>getDerivedStateFromProps</li><li>render()</li><li>componentDidMount()</li></ol></li><li>更新阶段：由组件内部this.setState()或父组件重新render触发<ol><li>getDerivedStateFromProps</li><li>shouldComponentUpdate()</li><li>render()</li><li>getSnapshotBeforeUpdate</li><li>componentDidUpdate()</li></ol></li><li>卸载组件：由ReactDOM.unmountComponentAtNode()触发<ol><li>componentWillUnmount()</li></ol></li><li><strong>重要的钩子：</strong><ol><li>render：初始化渲染或更新渲染调用</li><li>componentDidMount()：开启监听，发送ajax请求</li><li>componentWillUnmount()：做一些收尾工作，如：清理定时器</li></ol></li><li><strong>即将废弃的钩子：</strong><ol><li>componentWillMount</li><li>componentWillReceiveProps</li><li>componentWillUpdate</li><li>这三个钩子未来可能会被弃用，现在使用也得加上<strong>UNSAFE_前缀</strong>才能使用</li></ol></li></ol><h2 id="3-8-DOM的diffing算法"><a href="#3-8-DOM的diffing算法" class="headerlink" title="3.8 DOM的diffing算法"></a>3.8 DOM的diffing算法</h2><h3 id="3-8-1-Diffing算法"><a href="#3-8-1-Diffing算法" class="headerlink" title="3.8.1 Diffing算法"></a>3.8.1 Diffing算法</h3><p>最小力度是标签。也就是在每次更新虚拟DOM时，不会更新没有改变的标签，只会更新发生变化标签。<br>标签里面套标签的话，如果里面的标签没有变化，是不会动的。</p><h3 id="3-8-2-key的作用"><a href="#3-8-2-key的作用" class="headerlink" title="3.8.2 key的作用"></a>3.8.2 key的作用</h3><p>问：1.React中的key有什么作用？（key的内部原理是什么？）<br>    2.为什么遍历列表时，key最好不要用index？</p><p>答：</p><ol><li>虚拟DOM中key的作用：<ol><li>简单的说：key是虚拟DOM对象的标识，在更新显示时key起着极其重要的作用</li><li>详细的说：当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】，随后React进行【新虚拟DOM】和【旧虚拟DOM】的diff比较，规则如下：<ol><li>就虚拟DOM中找到了与新虚拟DOM相同的key：<ol><li>若虚拟DOM中内容没变，直接使用之前的真实DOM</li><li>若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM</li></ol></li><li>旧虚拟DOM中未找到与新虚拟DOM相同的key：<ol><li>根据数据创建新的真实DOM，随后渲染到页面</li></ol></li></ol></li></ol></li><li>使用index作为key，可能会引发的问题：<ol><li>若对数据进行：逆序添加、逆序删除等破坏性操作：会产生没有必要的真实DOM更新 &#x3D;&#x3D;&gt;界面效果没问题，但是效率低</li><li>如果结构中还包含输入类的DOM：会产生错误DOM更新 &#x3D;&#x3D;&gt;界面有问题</li><li>如果不存在对数据的逆序添加，逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。</li></ol></li><li>开发中如何选择key：<ol><li>最好使用每条数据的唯一标识作为key，比如：ID,手机号、身份证号、学号等唯一值</li><li>如果确定只是简单的展示数据，用index也是可以的。</li></ol></li></ol><p>如果使用index作为key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">初始数据：</span><br><span class="line">&#123;id:0,name:&#x27;ww&#x27;,age:18&#125;,</span><br><span class="line">&#123;id:1,name:&#x27;xx&#x27;,age:19&#125;,</span><br><span class="line"></span><br><span class="line">初始的虚拟DOM:</span><br><span class="line">&lt;li key=0&gt;ww---18&lt;/li&gt;</span><br><span class="line">&lt;li key=1&gt;xx---19&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">更新了一个新数据：</span><br><span class="line">&#123;id:2,name:&#x27;zz&#x27;,age:20&#125;,</span><br><span class="line">&#123;id:0,name:&#x27;ww&#x27;,age:18&#125;,</span><br><span class="line">&#123;id:1,name:&#x27;xx&#x27;,age:19&#125;,</span><br><span class="line"></span><br><span class="line">更新后的虚拟DOM：</span><br><span class="line">&lt;li key=0&gt;zz---20&lt;/li&gt;</span><br><span class="line">&lt;li key=1&gt;ww---18&lt;/li&gt;</span><br><span class="line">&lt;li key=2&gt;xx---19&lt;/li&gt;</span><br></pre></td></tr></table></figure><p>本来是只需要更新一条数据，但是因为index的问题，导致必须三个数据都转换。使得效率降低咧。<br>如果数据量很大，那么就会导致问题很严重。<strong>严重降低效率</strong><br><strong>所以说，应该使用id（数据的唯一标识）来当做索引值</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;发送请求获取数据&lt;/li&gt;
&lt;li&gt;处理数据（过滤、整理格式等）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作 DOM 呈现页面&lt;/strong&gt;（这一步是 react 的主要目的）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以说 react 是一个将数据渲染为 HTML 视图的开源 js 库&lt;/p&gt;
&lt;p&gt;原生 js 特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原生 js 操作 dom 繁琐，效率低&lt;/li&gt;
&lt;li&gt;使用 js 直接操作 dom，浏览器会进行大量的重绘重排&lt;/li&gt;
&lt;li&gt;原生 js 没有&lt;strong&gt;组件化&lt;/strong&gt;编码方案，代码复用率低&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;react 特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;采用&lt;strong&gt;组件化&lt;/strong&gt;模式，&lt;strong&gt;声明式&lt;/strong&gt;编码，提高开发效率及组件复用率&lt;/li&gt;
&lt;li&gt;在 React Native 中可以使用 React 语法进行移动端开发&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;虚拟 dom&lt;/strong&gt;和优秀的&lt;strong&gt;diffing 算法&lt;/strong&gt;，尽量减少与真实 dom 的交互&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;中文官网：&lt;code&gt;https://react.docschina.org&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Learning to Score Figure Skating Sport Videos</title>
    <link href="http://example.com/2022/12/26/Learning%20to%20Score%20Figure%20Skating%20Sport%20Videos/"/>
    <id>http://example.com/2022/12/26/Learning%20to%20Score%20Figure%20Skating%20Sport%20Videos/</id>
    <published>2022-12-26T07:38:48.000Z</published>
    <updated>2023-03-20T08:32:35.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Learning-to-Score-Figure-Skating-Sport-Videos"><a href="#Learning-to-Score-Figure-Skating-Sport-Videos" class="headerlink" title="Learning to Score Figure Skating Sport Videos"></a>Learning to Score Figure Skating Sport Videos</h1><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>Fis-V滑冰数据集，这个数据集包括500个花滑视频，平均长度为2分50秒。每个视频由9个不同的裁判员的两个分数进行注释，即总元素分数(TES)和总项目成分分数(PCS)。</p><p>每个视频只拍摄一名滑冰运动员的<strong>整个表演</strong>;对滑冰者不相关的部分(如热身，表演后向观众鞠躬)被修剪掉。因此，每个视频的长度约为2分50秒。我们总共收集了来自20多个国家的149名专业花滑运动员的500个视频。</p><p>我们还收集了9个不同国际裁判在比赛中给出的分数。</p><p><strong>我们的花滑视频只有一个球员，整个视频只是跟踪和定位球员在她的整个表现</strong></p><p>我们用选手和比赛仔细地注释了每个视频，并标注了两个分数，分别是Total Element Score (TES)和Total Program Component Score (PCS)。这些分数是由花样滑冰比赛的评分方案给出的。具体来说，这些分数衡量的是选手在整个比赛中每个阶段的表现。<strong>TES得分用于判断所有技术动作的难度和执行力</strong>;<strong>PCS的目的是评估滑冰运动员对音乐的表现和诠释</strong>。TES和PCS都是由9位不同的裁判给出的，他们都是花滑比赛的专家。</p><p>请注意，同一名滑冰运动员在不同的比赛中可能会因其表现而获得截然不同的分数。最后，我们收集了500个关于女子单打短节目的视频，每个视频都有最真实的评分。我们将数据集随机分为400个训练视频和100个测试视频。</p><span id="more"></span><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>Self-Attentive LSTM、Multi-scale Convolutional Skip LSTM，这两个组件能够在每个视频中学习本地（local）和全局（global）的序列信息。</p><p>我们的模型可以分为两个互补的子网络，即自注意LSTM (S-LSTM)和多尺度卷积跳过LSTM (M-LSTM)。S-LSTM采用一种简单的自注意策略来选择直接用于回归任务的重要剪辑特征。</p><p>S-LSTM主要学习表示局部信息。M-LSTM在多尺度上对局部和全局序列信息进行建模。</p><p>这两个子网络都可以直接用作预测模型，或者集成到一个单独的框架中用于最终的回归任务。我们的模型是在两个花样滑冰数据集上进行评估的，即MIT-skate和我们自己的fi - v视频数据集。实验结果验证了模型的有效性。</p><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><ol><li>提出的自注意LSTM可以通过自注意策略有效地学习对局部序列信息建模。</li><li>我们提出了一种多尺度卷积跳跃LSTM模型，用于多尺度的局部和全局信息学习，同时通过跳过一些视频特征来节省计算成本。</li><li>我们贡献了一个高质量的花样滑冰视频数据集 fis - v数据集。这个数据集是现有MIT-skate数据集的3倍多。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Learning-to-Score-Figure-Skating-Sport-Videos&quot;&gt;&lt;a href=&quot;#Learning-to-Score-Figure-Skating-Sport-Videos&quot; class=&quot;headerlink&quot; title=&quot;Learning to Score Figure Skating Sport Videos&quot;&gt;&lt;/a&gt;Learning to Score Figure Skating Sport Videos&lt;/h1&gt;&lt;h2 id=&quot;数据集&quot;&gt;&lt;a href=&quot;#数据集&quot; class=&quot;headerlink&quot; title=&quot;数据集&quot;&gt;&lt;/a&gt;数据集&lt;/h2&gt;&lt;p&gt;Fis-V滑冰数据集，这个数据集包括500个花滑视频，平均长度为2分50秒。每个视频由9个不同的裁判员的两个分数进行注释，即总元素分数(TES)和总项目成分分数(PCS)。&lt;/p&gt;
&lt;p&gt;每个视频只拍摄一名滑冰运动员的&lt;strong&gt;整个表演&lt;/strong&gt;;对滑冰者不相关的部分(如热身，表演后向观众鞠躬)被修剪掉。因此，每个视频的长度约为2分50秒。我们总共收集了来自20多个国家的149名专业花滑运动员的500个视频。&lt;/p&gt;
&lt;p&gt;我们还收集了9个不同国际裁判在比赛中给出的分数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们的花滑视频只有一个球员，整个视频只是跟踪和定位球员在她的整个表现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们用选手和比赛仔细地注释了每个视频，并标注了两个分数，分别是Total Element Score (TES)和Total Program Component Score (PCS)。这些分数是由花样滑冰比赛的评分方案给出的。具体来说，这些分数衡量的是选手在整个比赛中每个阶段的表现。&lt;strong&gt;TES得分用于判断所有技术动作的难度和执行力&lt;/strong&gt;;&lt;strong&gt;PCS的目的是评估滑冰运动员对音乐的表现和诠释&lt;/strong&gt;。TES和PCS都是由9位不同的裁判给出的，他们都是花滑比赛的专家。&lt;/p&gt;
&lt;p&gt;请注意，同一名滑冰运动员在不同的比赛中可能会因其表现而获得截然不同的分数。最后，我们收集了500个关于女子单打短节目的视频，每个视频都有最真实的评分。我们将数据集随机分为400个训练视频和100个测试视频。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机视觉" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
  </entry>
  
  <entry>
    <title>FineDiving: A Fine-grained Dataset for Procedure-aware Action Quality Assessment</title>
    <link href="http://example.com/2022/09/26/finediving-a-fine-grained-dataset-for-procedure-aware-action-quality-assessment/"/>
    <id>http://example.com/2022/09/26/finediving-a-fine-grained-dataset-for-procedure-aware-action-quality-assessment/</id>
    <published>2022-09-26T07:38:48.000Z</published>
    <updated>2023-03-20T08:32:34.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FineDiving-A-Fine-grained-Dataset-for-Procedure-aware-Action-Quality-Assessment"><a href="#FineDiving-A-Fine-grained-Dataset-for-Procedure-aware-Action-Quality-Assessment" class="headerlink" title="FineDiving: A Fine-grained Dataset for Procedure-aware Action Quality Assessment"></a>FineDiving: A Fine-grained Dataset for Procedure-aware Action Quality Assessment</h1><p>用于过程感知动作质量评估的细粒度数据集</p><p>其通过将动作分段，比如这个跳水动作，将其分为四部分，首先是跳水前的准备动作，然后是旋转动作，转体动作，最后是入水动作。这就将一个完整的跳水过程划分成不同的片段来进行处理和评估。</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>现在的动作质量评估大多依赖于整个视频的深度特征来进行预测评分，这样可靠性较差</p><p>通过动作的高级语义和内部时间结构进行精准预测</p><p>所以提出了一个跳水数据集和一个用于动作质量评估的过程感知方法—&gt;基于一个时间分割注意力模块</p><p>这个也就是将一个完整的复杂动作进行分割，分割成具有不同语义和时间对应关系的连续步骤</p><p><strong>代码地址：</strong> <a href="https://github.com/xujinglin/FineDiving">https://github.com/xujinglin/FineDiving</a></p><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Action Quality Assessment (AQA) –&gt; 动作质量评估</p><p>现有的方法大多都是基于视频整体的深度特征，这对于在相似背景下发生微小差异的行动来说是很困难的。</p><p>跳水这个项目，所有的视频套路都一样，分为三个阶段，起飞，飞行，进入，细微的差别主要体现在翻跟头和转体的数量、飞行姿势和执行质量上。</p><p>但是这个咋能用在花滑里呢，跳水摄像机位置是固定的，从侧面好看，但是花滑摄像机位置都不固定，感觉比较困难。</p><p>他们通过了动作过程的细粒度注释，建立了这个细粒度数据集。来进行评分。</p><h3 id="数据集构成"><a href="#数据集构成" class="headerlink" title="数据集构成"></a>数据集构成</h3><p>[<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/FineDiving.jpg">]</p><ol><li><p>两级语义结构</p><ol><li>所有视频被标注了两个层次的语义标签，即动作类型和子动作类型，子动作类型再通过组合产生了一个动作类型</li></ol></li><li><p>两级时间结构</p><ol><li>每个视频中动作的时间边界被注释，通过经过定义的动作词汇被分解为连续的步骤</li></ol></li><li><p>官方动作评分</p></li></ol><h3 id="时间分割注意力模块-TSA"><a href="#时间分割注意力模块-TSA" class="headerlink" title="时间分割注意力模块(TSA)"></a>时间分割注意力模块(TSA)</h3><p>TSA首先将动作解析为具有语义和时间对应关系的连续步骤，用于过程感知交叉注意学习。查询操作的连续步骤作为查询，示例操作的步骤作为键和值。</p><p>然后TSA将成对查询步骤和范例步骤输入转换器，通过交叉注意学习获得过程感知嵌入。最后，TSA对过程感知嵌入进行细粒度对比回归，量化查询与范例之间的分步质量差异，并预测动作评分。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>[<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/dataset.png">]</p><p>数据集包括两级语义结构，第一级是动作的名字，第二级是子动作，是一个具体的小组件。子操作类型的每个组合都可以产生一个操作类型，不同的操作类型可以共享相同的子操作类型。绿色的分支表示不同种类的起飞。紫色、黄色和红色的分支分别代表飞行中三个位置的翻跟头(即直翻、屈翻和卷翻)，每个分支包含不同的翻跟头。橙色的分支表示在翻跟头的过程中穿插着不同的扭转。浅蓝色表示下水。(彩色效果最佳。)</p><p>[<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/Dataset-gross.jpg">] 感觉他这个数据集就是把一个完整的动作分开，分成小动作，然后再用关键帧去找这几个小动作，再把这些小动作分开打分</p><p>与以往的方法不同，我们的方法理解了行动程序，并排除了查询和范例之间的程序感知注意，从而实现更透明的行动评估。</p><h2 id="数据集详情"><a href="#数据集详情" class="headerlink" title="数据集详情"></a>数据集详情</h2><p>数据集标签定位了完整动作实例的时间边界，在注释过程中，丢弃了所有不完整的操作实例，过滤缓慢的回放。步骤级标签是动作过程中连续步骤的起始帧。</p><p>注释分成了两个阶段。</p><ol><li>粗粒度阶段：为每个动作实例标注动作类型及时间边界，附上正式的分数。</li><li>细粒度阶段：为动作过程中的每个步骤标记子动作类型，记录每个步骤的起始帧</li></ol><p>将一个完整的视频，先分开，分成一个一个的整体动作。再将每一个整体动作，分成一个一个的小步骤，因为这些步骤是连续的，所以只需要知道起始帧就行了。</p><p>总共包含3000个视频样本，涵盖52种动作类型，29个子动作类型，23种难度等级类型 [<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/hard.png">] [<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/table.png">]</p><h2 id="动作评估模块"><a href="#动作评估模块" class="headerlink" title="动作评估模块"></a>动作评估模块</h2><p>给出一个两两查询和示例实例，我们使用<strong>I3D提取时空视觉特征</strong>，并提出了一个<strong>时间分割注意力模块</strong>，通过连续完成的过程分割、过程感知交叉注意学习和细粒度对比回归来评估动作质量。</p><p>时间分割注意模块由步骤转换标签和动作评分标签监督，引导模型关注与查询步骤一致的样本区域，并量化其差异以预测可靠的动作评分。</p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/model.png"></p><p>感觉这个就是将一个输入和用例所对应，提取出视觉特征，然后通过这个TSA模块，来预测动作质量分数。</p><h3 id="TSA"><a href="#TSA" class="headerlink" title="TSA"></a>TSA</h3><p>TSA有三个组成部分，即过程分割、过程感知交叉注意学习和细粒度对比回归。</p><ol><li><p><strong>动作过程分割</strong>将成对的查询动作实例和参考动作实例解析为语义和时间对齐的连续步骤。</p><ol><li><p>分割模块S包括“down-up”和“linear”两部分。</p><ol><li><p>其中“down-up”模块由四个“down-m-up-n”子块组成，m和n分别表示空间轴和时间轴上指定的输出维度。</p></li><li><p>每个子块包括两个连续的卷积层和一个池化层。</p></li><li><p>通过时间轴上的卷积层增加了特征的长度</p></li><li><p>通过空间轴上的最大池化层降低了维数。</p></li><li><p>所以说将视觉特征变得更长且低维，更加方便进行分割。</p></li></ol></li><li><p>“linear”负责生成L个概率分布。</p><ol><li>最后其实就是将分割问题转换成分类问题。</li><li>通过预测每一帧是否是第k步过渡的概率</li><li>再通过计算<strong>二元交叉熵损失</strong>来优化S，找到概率最大的过渡帧。</li></ol></li></ol></li></ol><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/mubiaohanshu.png"></p><p>使左侧值最小来使分布更接近。越接近则表示越对齐。</p><ol start="2"><li><p><strong>过程感知交叉注意</strong>通过学习发现成对 query step 和 exemplar step 之间的时空对应关系，并在这两个步骤中生成新特征。成对的步骤相互补充，以引导模型关注 exemplar step 和 query step 中的一致区域，其中，exemplar step 保留了特征图的空间信息。</p><ol><li>过程分割之后，会有L个过渡预测，从而得到L+1个连续的步骤。</li><li>每个动作过程具有语义对应和时间对应。</li><li>这部分通过transformer来完成，MCA和MLP组成，MLP包含两层非线性GELU。</li></ol></li><li><p><strong>细粒度对比回归</strong>通过学习成对步骤的相对分数来量化查询动作实例和示例动作实例之间的一些列步骤偏差，以指导模型来评估动作质量。</p><ol><li>通过计算基础真值和预测值之间的均方误差来优化细粒度对比回归组件。</li></ol></li></ol><p>[<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/yx.png">]</p><h4 id="exemplar选取策略"><a href="#exemplar选取策略" class="headerlink" title="exemplar选取策略"></a>exemplar选取策略</h4><p>关于 TSA 中exemplar的选择策略。根据 action type 从训练集中选择exemplar。在训练阶段，对于每个训练样本（query），从具有相同 action type 的其他训练样本中随机选择一个作为 exemplar。在推理阶段，采用多样本投票策略：从具有相同 action type 的训练样本中随机选择 M 个样本作为 M 个 exemplars。</p><h2 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h2><p>[<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/pinggu.png">]</p><ol><li>13D模型通过Kinetics数据集预训练，作为F，初始学习率为10^-4^,T的初始学习率为10^-3^。</li><li>Adam优化器，权重衰减为0</li><li>每个视频提取96帧，分为9个片段，然后输入13D。每个片段包含16个连续帧。stride为10帧。</li><li>75%训练，25%测试。</li><li>b1块中的（m,n）分别等于(1024,12),(512,24),(256,48),(128,96)</li><li>b2块是一个三层MLP</li><li>M为10，L为2</li><li>每一步的帧数固定为5帧，输入MCA。3layers &amp; 8heads</li><li>每一步包含的帧数过多可能会引入一些噪声信息。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;FineDiving-A-Fine-grained-Dataset-for-Procedure-aware-Action-Quality-Assessment&quot;&gt;&lt;a href=&quot;#FineDiving-A-Fine-grained-Dataset-for-Procedure-aware-Action-Quality-Assessment&quot; class=&quot;headerlink&quot; title=&quot;FineDiving: A Fine-grained Dataset for Procedure-aware Action Quality Assessment&quot;&gt;&lt;/a&gt;FineDiving: A Fine-grained Dataset for Procedure-aware Action Quality Assessment&lt;/h1&gt;&lt;p&gt;用于过程感知动作质量评估的细粒度数据集&lt;/p&gt;
&lt;p&gt;其通过将动作分段，比如这个跳水动作，将其分为四部分，首先是跳水前的准备动作，然后是旋转动作，转体动作，最后是入水动作。这就将一个完整的跳水过程划分成不同的片段来进行处理和评估。&lt;/p&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;现在的动作质量评估大多依赖于整个视频的深度特征来进行预测评分，这样可靠性较差&lt;/p&gt;
&lt;p&gt;通过动作的高级语义和内部时间结构进行精准预测&lt;/p&gt;
&lt;p&gt;所以提出了一个跳水数据集和一个用于动作质量评估的过程感知方法—&amp;gt;基于一个时间分割注意力模块&lt;/p&gt;
&lt;p&gt;这个也就是将一个完整的复杂动作进行分割，分割成具有不同语义和时间对应关系的连续步骤&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码地址：&lt;/strong&gt; &lt;a href=&quot;https://github.com/xujinglin/FineDiving&quot;&gt;https://github.com/xujinglin/FineDiving&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机视觉" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
  </entry>
  
  <entry>
    <title>typescript基础</title>
    <link href="http://example.com/2022/08/17/typescript%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/08/17/typescript%E5%9F%BA%E7%A1%80/</id>
    <published>2022-08-17T01:12:36.000Z</published>
    <updated>2023-03-20T08:32:38.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><ol><li>以JavaScript为基础构建的语言</li><li>其是一个JavaScript的超集</li><li>TypeScript拓展了JavaScript，并添加了类型</li><li>TS不能被JS解析器直接执行，需要将ts编译为js进行执行</li><li>JavaScript是弱类型语言, 很多错误只有在运行时才会被发现。而TypeScript提供了一套静态检测机制, 可以帮助我们在编译时就发现错误</li></ol><span id="more"></span><h2 id="1-1-安装和使用"><a href="#1-1-安装和使用" class="headerlink" title="1.1 安装和使用"></a>1.1 安装和使用</h2><p>首先需要node.js 之后使用npm来下载ts</p><ol><li>首先将npm配置为淘宝镜像地址<code>npm config set registry https://registry.npm.taobao.org</code></li><li>下载typescript<code>npm i -g typescript</code></li><li>下载ts-node<code>npm i -g ts-node</code></li><li>通过<code>tsc --init</code>创建一个tsconfig.json文件</li><li>创建一个示例<code>xxx.ts</code>文件</li><li>然后就能通过<code>ts-node xxx.ts</code>来运行示例了</li><li>或者可以通过<code>tsc xxx.ts</code>来将ts编译成js</li></ol><h2 id="1-2-入门网站"><a href="#1-2-入门网站" class="headerlink" title="1.2 入门网站"></a>1.2 入门网站</h2><p>官方网站：<a href="https://www.typescriptlang.org/zh/">https://www.typescriptlang.org/zh/</a> 一个很不错的入门教程：<a href="https://juejin.cn/post/7018805943710253086?share_token=c4029c41-9cc7-4e39-9e2d-c57b6617d2d8">https://juejin.cn/post/7018805943710253086?share_token&#x3D;c4029c41-9cc7-4e39-9e2d-c57b6617d2d8</a></p><h1 id="二、基础"><a href="#二、基础" class="headerlink" title="二、基础"></a>二、基础</h1><p><strong>typescript是强类型语言</strong></p><h2 id="2-1-类型"><a href="#2-1-类型" class="headerlink" title="2.1 类型"></a>2.1 类型</h2><ol><li><p>ts中需要对声明的变量进行类型的赋予</p></li><li><p>声明变量可以直接进行赋值</p></li><li><p>如果变量的声明和赋值是同时进行的，ts可以自动对变量进行类型检测</p></li><li><p>js中的函数是不考虑参数的类型和个数的</p></li><li><p>在ts中可以通过限制类型来控制传入参数的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以先对变量进行类型的赋予，之后这个变量的类型便固定了，如果赋予其不同类型的值则会报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>:<span class="built_in">string</span>;</span><br><span class="line">a = <span class="number">123</span>;</span><br><span class="line">b = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="comment">// 如果不进行类型赋予，会以其第一个赋予的值作为其类型</span></span><br><span class="line"><span class="comment">// 这里就将c赋予了Boolean值类型</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="literal">false</span>;</span><br><span class="line">c = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 使用js中的函数形式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">aa,bb</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> aa + bb;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="attr">aa</span>:<span class="number">123</span>,<span class="attr">bb</span>:<span class="string">&#x27;hello&#x27;</span>); <span class="comment">//这里返回的就是123hello。变成了字符串拼串</span></span><br><span class="line"><span class="comment">// ts</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">aaa:<span class="built_in">number</span>,bbb:<span class="built_in">number</span></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> aaa + bbb; <span class="comment">//这里就限制了两个传入参数都必须是数字类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入除数字类型和多传入参数都会报错</span></span><br><span class="line"><span class="title function_">sum</span>(<span class="attr">aaa</span>:<span class="number">123</span>, <span class="attr">bbb</span>:<span class="string">&#x27;hello&#x27;</span>,<span class="number">345</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-1-1-注意点"><a href="#2-1-1-注意点" class="headerlink" title="2.1.1 注意点"></a>2.1.1 注意点</h3><p><strong>js中的八种类型值</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> = <span class="string">&quot;jimmy&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span> = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">bool</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="built_in">object</span> = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">big</span>: <span class="built_in">bigint</span> = <span class="number">100n</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">sym</span>: <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>(<span class="string">&quot;me&quot;</span>); </span><br></pre></td></tr></table></figure><p>默认情况下<code>null</code>和<code>undefined</code>是<strong>所有类型</strong>的子类型。 就是说你可以把<code>null</code>和<code>undefined</code>赋值给其他类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// null和undefined赋值给string</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">str</span>:<span class="built_in">string</span> = <span class="string">&quot;666&quot;</span>;</span><br><span class="line">str = <span class="literal">null</span></span><br><span class="line">str= <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined赋值给number</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>:<span class="built_in">number</span> = <span class="number">666</span>;</span><br><span class="line">num = <span class="literal">null</span></span><br><span class="line">num= <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>如果你在<code>tsconfig.json</code>指定了<code>&quot;strictNullChecks&quot;:true</code>，<code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和它们各自的类型。</p><p>虽然<code>number</code>和<code>bigint</code>都表示数字，但是这两个类型不兼容。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">big</span>: <span class="built_in">bigint</span> =  <span class="number">100n</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line">big = num;</span><br><span class="line">num = big;</span><br></pre></td></tr></table></figure><p>会抛出一个类型不兼容的 ts(2322) 错误。</p><h3 id="2-1-2-ts中的新类型"><a href="#2-1-2-ts中的新类型" class="headerlink" title="2.1.2 ts中的新类型"></a>2.1.2 ts中的新类型</h3><ol><li><p>可以直接使用字面量进行类型声明</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a : <span class="number">10</span>;</span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">11</span>; <span class="comment">//报错，不能将类型11分配给类型10</span></span><br><span class="line"><span class="comment">// 这样就限定了某一个变量的值</span></span><br></pre></td></tr></table></figure></li><li><p>但是可以使用来连接多个类型(联合类型)</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b : <span class="string">&#x27;male&#x27;</span>  <span class="string">&#x27;female&#x27;</span>;</span><br><span class="line">b = <span class="string">&#x27;male&#x27;</span>;</span><br><span class="line">b = <span class="string">&#x27;female&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> c : <span class="built_in">boolean</span>  <span class="built_in">string</span>;</span><br><span class="line">c = <span class="literal">true</span>;</span><br><span class="line">c = <span class="string">&#x27;hello&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这样就可以为一个变量进行多个赋值的选择。或者多种类型的选择</p></li><li><p>any 表示任意的类型，一个变量设置类型为any后相当于对该变量关闭ts的类型检测</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">d</span>:<span class="built_in">any</span>;</span><br><span class="line">d = <span class="number">10</span>;</span><br><span class="line">d = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">d = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 声明变量如果不指定类型，则会自动判断变量的类型为any（隐式的any）</span></span><br><span class="line"><span class="keyword">let</span> d;</span><br></pre></td></tr></table></figure><p><strong>在实际应用中尽量别用any</strong></p></li><li><p>unknown 表示未知类型的值</p><ol><li>unknown实际上就是一个类型安全的any</li><li>因为any类型的变量可以复制给任意变量，从而导致可能存在的各种问题</li><li>但是unknown类型的变量，不能直接赋值给其他变量</li></ol></li><li><p>类型断言：可以用来告诉解析器变量的实际类型</p><ol><li><p>变量 as 类型</p></li><li><p>&lt;类型&gt;变量</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> e : <span class="built_in">unknown</span>;</span><br><span class="line"><span class="keyword">let</span> s : <span class="built_in">string</span>;</span><br><span class="line">e = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">s = e; <span class="comment">//这样会报错，因为unknown不能直接赋值给其他变量</span></span><br><span class="line"><span class="comment">// 下面是类型断言，两种方式都可以</span></span><br><span class="line">s = e <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line">s = &lt;<span class="built_in">string</span>&gt;e;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>void用来表示空，以函数为例，就表示没有返回值的函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>): <span class="built_in">void</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>never表示永远不会返回结果</p><ol><li><p>在 TypeScript 中，可以利用 never 类型的特性来实现全面性检查</p></li><li><p>使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = <span class="built_in">string</span>  <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">controlFlowAnalysisWithNever</span>(<span class="params">foo: Foo</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> foo === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line"><span class="comment">// 这里 foo 被收窄为 string 类型</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> foo === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line"><span class="comment">// 这里 foo 被收窄为 number 类型</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// foo 在这里是 never</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">check</span>: <span class="built_in">never</span> = foo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>array类型。表示一个数组。数组有两种表示形式：</p><ol><li><p>string[]</p></li><li><p>Array&lt;&gt;</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面这两种表示形式是一样的</span></span><br><span class="line"><span class="keyword">let</span> g = <span class="built_in">number</span>[];</span><br><span class="line"><span class="keyword">let</span> g : <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line">g=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:(<span class="built_in">number</span>  <span class="built_in">string</span>)[];</span><br><span class="line"><span class="comment">// 表示定义了一个名称叫做arr的数组, </span></span><br><span class="line"><span class="comment">// 这个数组中将来既可以存储数值类型的数据, 也可以存储字符串类型的数据</span></span><br><span class="line">arr3 = [<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="comment">// interface是接口,后面会讲到</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Arrobj</span>&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line"><span class="attr">age</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr3</span>:<span class="title class_">Arrobj</span>[]=[&#123;<span class="attr">name</span>:<span class="string">&#x27;jimmy&#x27;</span>,<span class="attr">age</span>:<span class="number">22</span>&#125;]</span><br></pre></td></tr></table></figure></li></ol></li><li><p>元祖：元祖就是固定长度的数组</p><ol><li><p>元组最重要的特性是可以限制数组元素的个数和类型，它特别适合用来实现多值返回。</p></li><li><p>元组类型只能表示一个已知元素数量和类型的数组，长度已指定，越界访问会提示错误。如果一个数组中可能有多种类型，数量和类型都不确定，那就直接any[]</p></li><li><p>元祖支持解构赋值</p></li><li><p>元祖也支持？表示可选元素</p></li><li><p>可以通过…X来表示一个长度不固定的数组，也就是拼接数组</p></li><li><p>可以通过readonly前缀来设置只读元祖<code>const point: readonly [number, number] = [10, 20];</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这就是一个元祖形式，其类型必须匹配，并且长度为2</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">h</span>:[<span class="built_in">string</span>,<span class="built_in">number</span>];</span><br><span class="line">h = [<span class="string">&#x27;hello&#x27;</span>,<span class="number">123</span>]</span><br></pre></td></tr></table></figure><p>对于解构赋值的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">employee</span>: [<span class="built_in">number</span>, <span class="built_in">string</span>] = [<span class="number">1</span>, <span class="string">&quot;Semlinker&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> [id, username] = employee;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`id: <span class="subst">$&#123;id&#125;</span>`</span>); <span class="comment">//id:1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`username: <span class="subst">$&#123;username&#125;</span>`</span>); <span class="comment">//username:Semlinker</span></span><br><span class="line"><span class="comment">// 解构数组元素的个数不能超过元祖中元素的个数，否则会出错</span></span><br><span class="line"><span class="keyword">let</span> [id, username, age] = employee; <span class="comment">//error</span></span><br></pre></td></tr></table></figure><p>对于拼接的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">RestTupleType</span> = [<span class="built_in">number</span>, ...<span class="built_in">string</span>[]];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">restTuple</span>: <span class="title class_">RestTupleType</span> = [<span class="number">666</span>, <span class="string">&quot;Semlinker&quot;</span>, <span class="string">&quot;Kakuqo&quot;</span>, <span class="string">&quot;Lolo&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(restTuple[<span class="number">0</span>]);   <span class="comment">//666</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(restTuple[<span class="number">1</span>]);   <span class="comment">//Semlinker</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>enum 枚举,通过</p></li></ol><pre><code><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Gender</span>&#123;</span><br><span class="line"><span class="title class_">Male</span> = <span class="number">0</span>,</span><br><span class="line"><span class="title class_">Female</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">i</span>: &#123;<span class="attr">name</span>:<span class="built_in">string</span>, <span class="attr">gender</span>:<span class="title class_">Gender</span>&#125;;</span><br><span class="line">i = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;wh&#x27;</span>,</span><br><span class="line"><span class="attr">gender</span>:<span class="title class_">Gender</span>.<span class="property">Male</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ol start="11"><li>object表示一个js对象</li></ol><pre><code><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">object</span>;</span><br><span class="line">a = &#123;&#125;;</span><br></pre></td></tr></table></figure>&#123;&#125;用来指定对象中可以包含哪些属性 语法：&#123;属性名：属性值&#125; **在属性名后面加上?，表示属性是可选的**</code></pre><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">b</span>:&#123;<span class="attr">name</span>:<span class="built_in">string</span>, age?:<span class="built_in">number</span>&#125;;</span><br><span class="line"><span class="comment">// 因为age后面加了？，所以age这个属性可加可不加</span></span><br><span class="line">b = &#123;<span class="attr">name</span>:<span class="string">&#x27;wh&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [propName:string]:any 表示任意类型的属性</span></span><br><span class="line"><span class="comment">// 表示只要是名字为字符串类型的变量，都可以存在</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>:&#123;<span class="attr">name</span>:<span class="built_in">string</span>, [<span class="attr">propName</span>:<span class="built_in">string</span>]:<span class="built_in">any</span>&#125;;</span><br><span class="line">c = &#123;<span class="attr">name</span>:<span class="string">&#x27;xxx&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">gender</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><ol start="12"><li>设置函数结构的类型声明： 语法：（形参：类型,形参：类型）&#x3D;&gt; 返回值</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">d</span>: <span class="function">(<span class="params">a:<span class="built_in">number</span> , b:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line">d = <span class="keyword">function</span> (<span class="params">a,b</span>):<span class="built_in">number</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-ts的编译"><a href="#2-2-ts的编译" class="headerlink" title="2.2 ts的编译"></a>2.2 ts的编译</h2><ol><li>基础编译：<code>tsc xxx.ts</code></li><li>监视变化的编译：<code>tsc xxx.ts -w</code> 但是这两种方式都不太方便-.-</li></ol><p>所以一般使用的方法都是：<code>tsc --init</code>生成一个tsconfig.json文件 然后<code>tsc</code>进行编译。<code>tsc -w</code>进行所有文件的监视</p><h2 id="2-3-用webpack打包ts代码"><a href="#2-3-用webpack打包ts代码" class="headerlink" title="2.3 用webpack打包ts代码"></a>2.3 用webpack打包ts代码</h2><ol><li><p>对项目进行初始化 <code>npm init -y</code></p></li><li><p>下载依赖包<code>npm i -D webpack webpack-cli ts-loader</code></p><ul><li>-D代表的是在生产环境中安装的包，这些包只在开发环境中使用，用来进行代码打包等操作，不需要上传到服务环境中</li></ul></li><li><p>使用<code>tsc --init</code>生成tsconfig.json文件</p></li><li><p>创建webpack.config.json文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入包</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// webpack中的所有配置都应该写在module.exports中</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="comment">// 指定入口文件</span></span><br><span class="line"><span class="attr">entry</span>: <span class="string">&#x27;./src/index.ts&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定打包文件所在目录</span></span><br><span class="line"><span class="attr">output</span>:&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定打包文件的目录</span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打包后文件的文件</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置开发环境(development)或者是生产环境(production)，webpack4.0新增</span></span><br><span class="line"><span class="attr">mode</span>:<span class="string">&#x27;development&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定webpack打包时要使用的模块</span></span><br><span class="line"><span class="attr">module</span>:&#123;</span><br><span class="line">    <span class="comment">// 指定要加载的规则</span></span><br><span class="line">    <span class="attr">rules</span>:</span><br><span class="line">          [</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">// test指定的是规则生效的文件</span></span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">            <span class="comment">// 要使用的loader</span></span><br><span class="line">            <span class="attr">use</span>: <span class="string">&#x27;ts-loader&#x27;</span>,</span><br><span class="line">            <span class="comment">// 要排除的文件</span></span><br><span class="line">           <span class="attr">exclude</span>:<span class="regexp">/node-modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在package.json文件中加入build</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ts_webpack&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack --mode development&quot;</span>  <span class="comment">//add this</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;keywords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;ts-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^9.3.1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;webpack&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.74.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;webpack-cli&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.10.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>运行<code>npm run build</code>进行编译 上面的这些步骤只是能够将ts文件编译成js文件，但是不能够满足项目上线的需求。 所以还需要一些别的操作：</p></li><li><p><code>npm i -D html-webpack-plugin</code>-–用于生成一个HTML模板并进行引用</p></li><li><p><code>npm i -D webpack-dev-server</code> —用于能够实时调试代码，实时更新</p></li><li><p><code>npm i -D clean-webpack-plugin</code> —用来清除旧代码，保证一直是最新的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入包</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入html插件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HTMLWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CleanWebpackPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="comment">// webpack中的所有配置都应该写在module.exports中</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="comment">// 指定入口文件</span></span><br><span class="line"><span class="attr">entry</span>: <span class="string">&#x27;./src/index.ts&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定打包文件所在目录</span></span><br><span class="line"><span class="attr">output</span>:&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定打包文件的目录</span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打包后文件的文件</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置开发环境或者是生产环境，webpack4.0新增</span></span><br><span class="line"><span class="attr">mode</span>:<span class="string">&#x27;development&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定webpack打包时要使用的模块</span></span><br><span class="line"><span class="attr">module</span>:&#123;</span><br><span class="line">    <span class="comment">// 指定要加载的规则</span></span><br><span class="line">    <span class="attr">rules</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// test指定的是规则生效的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">        <span class="comment">// 要使用的loader</span></span><br><span class="line">        <span class="attr">use</span>: <span class="string">&#x27;ts-loader&#x27;</span>,</span><br><span class="line">        <span class="comment">// 要排除的文件</span></span><br><span class="line">        <span class="attr">exclude</span>:<span class="regexp">/node-modules/</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置webpack插件</span></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">  <span class="comment">// 清除旧代码</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>(),</span><br><span class="line">    <span class="comment">// 生成html文件</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HTMLWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 使用模板html文件</span></span><br><span class="line">        <span class="attr">template</span>:<span class="string">&quot;./src/index.html&quot;</span></span><br><span class="line">    &#125;),</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来设置引用模块</span></span><br><span class="line"><span class="attr">resolve</span>:&#123;</span><br><span class="line">    <span class="attr">extensions</span>:[<span class="string">&#x27;.ts&#x27;</span>,<span class="string">&#x27;.js&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在package.json中加入一些新内容：</p></li></ol><pre><code><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 表示是生产环境的webpack</span></span><br><span class="line"><span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack --mode development&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 能够通过npm start启动服务，并进行实时修改同步</span></span><br><span class="line"><span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack serve --open chrome.exe&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></code></pre><ol start="11"><li><p>为了更好的兼容性，还需要一些别的插件<code>npm i -D @babel/core @babel/preset-env babel-loader core-js</code></p></li><li><p>在webpack.config.js中的module中再添加一些东西</p></li></ol><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定webpack打包时要使用的模块</span></span><br><span class="line"><span class="attr">module</span>:&#123;</span><br><span class="line">    <span class="comment">// 指定要加载的规则</span></span><br><span class="line">    <span class="attr">rules</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// test指定的是规则生效的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">        <span class="comment">// 要使用的loader</span></span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">            <span class="comment">// 配置babel</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 指定加载器</span></span><br><span class="line">                <span class="attr">loader</span>:<span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">                <span class="comment">// 设置babel</span></span><br><span class="line">                <span class="attr">options</span>:&#123;</span><br><span class="line">                    <span class="comment">// 设置预定义的环境</span></span><br><span class="line">                    <span class="attr">presets</span>:[</span><br><span class="line">                        [</span><br><span class="line">                            <span class="comment">// 指定环境的插件</span></span><br><span class="line">                            <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">// 要兼容的目标浏览器</span></span><br><span class="line">                                <span class="attr">targets</span>:&#123;</span><br><span class="line">                                    <span class="string">&quot;chrome&quot;</span>:<span class="string">&#x27;58&#x27;</span>,</span><br><span class="line">                                    <span class="string">&quot;ie&quot;</span>:<span class="string">&#x27;11&#x27;</span></span><br><span class="line">                                &#125;,</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 指定corejs的版本</span></span><br><span class="line">                                <span class="string">&quot;corejs&quot;</span>:<span class="string">&quot;3&quot;</span>,</span><br><span class="line">                                <span class="comment">// 使用corejs的方式&quot;usage&quot;表示按需加载</span></span><br><span class="line">                                <span class="string">&quot;useBuiltIns&quot;</span>:<span class="string">&quot;usage&quot;</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&#x27;ts-loader&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// 要排除的文件</span></span><br><span class="line">        <span class="attr">exclude</span>:<span class="regexp">/node-modules/</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></code></pre><ol start="13"><li>如果为了兼容老ie，虽然现在基本没有咧。需要添加不转换箭头函数</li></ol><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定打包文件所在目录</span></span><br><span class="line"><span class="attr">output</span>:&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定打包文件的目录</span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打包后文件的文件</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉webpack不要转换箭头函数</span></span><br><span class="line">    <span class="attr">environment</span>:&#123;</span><br><span class="line">        <span class="attr">arrowFunction</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></code></pre><h2 id="2-4-类、构造函数和this"><a href="#2-4-类、构造函数和this" class="headerlink" title="2.4 类、构造函数和this"></a>2.4 类、构造函数和this</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// constructor被称为构造函数</span></span><br><span class="line">  <span class="comment">// 构造函数会在对象创建时调用</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span>, age:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">    <span class="comment">// 在实例方法中，this就表示当前的实例</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">bark</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-继承和抽象类"><a href="#2-5-继承和抽象类" class="headerlink" title="2.5 继承和抽象类"></a>2.5 继承和抽象类</h2><ul><li><p>Animal是父类，Dog是子类</p></li><li><p>使用继承后，子类将会拥有父类所有的方法和属性</p></li><li><p>通过继承可以将多个类中共有的代码写在一个父类中</p></li><li><p>在子类中添加了和父类相同的方法，则子类方法会覆盖掉父类方法</p></li><li><p>抽象类的作用就是专门用来被继承</p></li><li><p>抽象类中可以添加抽象方法</p></li><li><p>抽象类不能用来创建对象</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以abstract开头的类就是抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line"><span class="attr">age</span>:<span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span>, age:<span class="built_in">number</span></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayHello</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;动物在叫~&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法只能定义在抽象类中，子类必须对抽象方法进行重写</span></span><br><span class="line"><span class="comment">// 抽象方法没有方法体</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="title function_">say</span>():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// 如果子类写了构造函数，必须写super调用父类</span></span><br><span class="line"><span class="comment">// 和react什么都一样</span></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span>, age:<span class="built_in">number</span></span>)&#123;</span><br><span class="line"><span class="variable language_">super</span>(name);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayHello</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">// 在类的方法中，super就表示当前类的父类</span></span><br><span class="line"><span class="variable language_">super</span>.<span class="title function_">sayHello</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">run</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>在跑...`</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line"><span class="title function_">sayHello</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;喵喵喵&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺财&quot;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog);</span><br><span class="line">dog.<span class="title function_">run</span>();</span><br></pre></td></tr></table></figure></li></ul><h1 id="三、接口"><a href="#三、接口" class="headerlink" title="三、接口"></a>三、接口</h1><ul><li>接口用来定义一个类结构,用来定义一个类中应该包含哪些属性和方法</li><li>同时接口也可以当成类型声明去使用</li><li>接口可以在定义类的时候去限制类的结构<ul><li><strong>接口中的所有的属性不能有实际的值</strong></li><li>接口只定义对象的结构，而不考虑实际值</li><li>在接口中所有的方法都是抽象方法</li><li>接口一般首字母大写</li><li>定义的变量比接口多&#x2F;少一些属性是不允许的</li><li><strong>赋值的时候，变量的形状必须和接口的形状保持一致</strong></li></ul></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInter</span>&#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">  age?:<span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// 通过索引签名的形式可以使接口中有其他的任意属性</span></span><br><span class="line">  [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">  <span class="title function_">sayHello</span>():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义类时，可以使类去实现一个接口，也就是使类满足接口的要求</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">MyInter</span>&#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span>, age:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口可以定义多次，会被自动合并为单个接口。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123; <span class="attr">y</span>: <span class="built_in">number</span>; &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">point</span>: <span class="title class_">Point</span> = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><h2 id="3-1-可选只读属性"><a href="#3-1-可选只读属性" class="headerlink" title="3.1 可选只读属性"></a>3.1 可选只读属性</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只读属性用于限制只能在对象刚刚创建的时候修改其值。此外 TypeScript 还提供了<code>ReadonlyArray&lt;T&gt;</code>类型，它与 <code>Array&lt;T&gt;</code>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">ro</span>: <span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line">ro.<span class="title function_">push</span>(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line">ro.<span class="property">length</span> = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><h2 id="3-2-几种绕开额外属性检查的方法"><a href="#3-2-几种绕开额外属性检查的方法" class="headerlink" title="3.2 几种绕开额外属性检查的方法"></a>3.2 几种绕开额外属性检查的方法</h2><h3 id="3-2-1-鸭式辩型法"><a href="#3-2-1-鸭式辩型法" class="headerlink" title="3.2.1 鸭式辩型法"></a>3.2.1 鸭式辩型法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">LabeledValue</span> &#123;</span><br><span class="line">  <span class="attr">label</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printLabel</span>(<span class="params">labeledObj: LabeledValue</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(labeledObj.<span class="property">label</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myObj = &#123; <span class="attr">size</span>: <span class="number">10</span>, <span class="attr">label</span>: <span class="string">&quot;Size 10 Object&quot;</span> &#125;;</span><br><span class="line"><span class="title function_">printLabel</span>(myObj); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">LabeledValue</span> &#123;</span><br><span class="line">  <span class="attr">label</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printLabel</span>(<span class="params">labeledObj: LabeledValue</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(labeledObj.<span class="property">label</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printLabel</span>(&#123; <span class="attr">size</span>: <span class="number">10</span>, <span class="attr">label</span>: <span class="string">&quot;Size 10 Object&quot;</span> &#125;); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>上面代码，在参数里写对象就相当于是直接给<code>labeledObj</code>赋值，这个对象有严格的类型定义，所以不能多参或少参。而当你在外面将该对象用另一个变量<code>myObj</code>接收，<code>myObj</code>不会经过额外属性检查，但会根据类型推论为<code>let myObj: &#123; size: number; label: string &#125; = &#123; size: 10, label: &quot;Size 10 Object&quot; &#125;;</code>，然后将这个<code>myObj</code>再赋值给<code>labeledObj</code>，此时根据类型的兼容性，两种类型对象，参照鸭式辨型法，因为都具有<code>label</code>属性，所以被认定为两个相同，故而可以用此法来绕开多余的类型检查。</p><h3 id="3-2-2-类型断言"><a href="#3-2-2-类型断言" class="headerlink" title="3.2.2 类型断言"></a>3.2.2 类型断言</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>; </span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>; </span><br><span class="line">  money?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p</span>: <span class="title class_">Props</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;兔神&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">money</span>: -<span class="number">100000</span>,</span><br><span class="line">  <span class="attr">girl</span>: <span class="literal">false</span></span><br><span class="line">&#125; <span class="keyword">as</span> <span class="title class_">Props</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><h3 id="3-2-3-索引签名"><a href="#3-2-3-索引签名" class="headerlink" title="3.2.3 索引签名"></a>3.2.3 索引签名</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>; </span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>; </span><br><span class="line">  money?: <span class="built_in">number</span>;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p</span>: <span class="title class_">Props</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;兔神&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">money</span>: -<span class="number">100000</span>,</span><br><span class="line">  <span class="attr">girl</span>: <span class="literal">false</span></span><br><span class="line">&#125;; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><h2 id="3-3-接口和类型别名"><a href="#3-3-接口和类型别名" class="headerlink" title="3.3 接口和类型别名"></a>3.3 接口和类型别名</h2><p>接口和类型别名在大多数情况下效果是等价的，但是实际还是有区别的。 首先从定义的角度：</p><ul><li><p>接口的作用就是为类型命名和为代码或第三方代码定义数据类型</p></li><li><p>type（类型别名）会给一个类型起个新名字。起别名不会新建一个类型，只是创建了一个新名字来引用某个类型。 从语法角度讲： Interface:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SetPoint</span> &#123;</span><br><span class="line">(<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Type:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line"><span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SetPoint</span> = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure></li></ul><p>与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primitive</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// object</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialPointX</span> = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialPointY</span> = &#123; <span class="attr">y</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// union</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialPoint</span> = <span class="title class_">PartialPointX</span>  <span class="title class_">PartialPointY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tuple</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Data</span> = [<span class="built_in">number</span>, <span class="built_in">string</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// dom</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">type</span> B = <span class="keyword">typeof</span> div;</span><br></pre></td></tr></table></figure><p><strong>接口可以定义多次,类型别名不可以</strong></p><ul><li>接口和类型别名的扩展方式不同，但并不互斥。接口可以扩展类型别名，同理，类型别名也可以扩展接口。</li><li>接口的扩展就是继承，通过<code>extends</code>来实现。类型别名的扩展就是交叉类型，通过<code>&amp;</code>来实现。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PointX</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> <span class="keyword">extends</span> <span class="title class_">PointX</span> &#123;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PointX</span> = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = <span class="title class_">PointX</span> &amp; &#123;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、属性的封装"><a href="#四、属性的封装" class="headerlink" title="四、属性的封装"></a>四、属性的封装</h1><p>通过在属性前添加属性的修饰符</p><ul><li><p>public: 修饰的属性可以在任意位置访问（修改）默认值</p></li><li><p>private:私有属性，私有属性只能在类内部进行访问（修改）</p></li><li><p>通过在类中添加方法使得私有属性可以被外部访问</p></li><li><p>protected:受保护的属性，只能在当前类和当前类的子类中访问</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="attr">_name</span>: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="attr">_age</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">get</span> <span class="title function_">age</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_age</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="title function_">age</span>(<span class="params">value: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_age</span> = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> per = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;tom&#x27;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per);   <span class="comment">//tom 18</span></span><br><span class="line">per.<span class="property">name</span> = <span class="string">&#x27;jack&#x27;</span>;</span><br><span class="line">per.<span class="property">age</span> = -<span class="number">18</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per);  <span class="comment">// jack 18</span></span><br></pre></td></tr></table></figure><p>可以直接将属性定义在构造函数中：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> name:<span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">          <span class="keyword">private</span> age:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">          <span class="keyword">protected</span> gender:<span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">          <span class="keyword">public</span> flag:<span class="built_in">boolean</span></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="五、泛型"><a href="#五、泛型" class="headerlink" title="五、泛型"></a>五、泛型</h1><ul><li><p>在定义函数或是类时，如果遇到类型不明确就可以使用泛型</p></li><li><p>泛型可以同时指定多个</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> fn&lt;T&gt;(<span class="attr">a</span>: T): T&#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>&#x2F;&#x2F; 可以直接调用具有泛型的函数 let result &#x3D; fn(a:10); &#x2F;&#x2F;不指定泛型，TS可以自动对类型进行推断 let result2 &#x3D; fn<string>(a: ‘hello’); &#x2F;&#x2F;指定泛型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">在泛型中T代表Type，在定义泛型时通常用作第一个类型变量名称。但实际上T可以用任何有效名称代替。除了T之外，以下是常见泛型变量代表的意思：</span><br><span class="line">- K（Key）：表示对象中的键类型；</span><br><span class="line">- V（Value）：表示对象中的值类型；</span><br><span class="line">- E（Element）：表示元素类型。</span><br><span class="line"></span><br><span class="line">使用extends关键字让T继承接口的类型从而实现类型约束。简单来说就是你定义一个类型，然后让 T 实现这个接口即可</span><br><span class="line">```ts</span><br><span class="line">interface Sizeable &#123;</span><br><span class="line">  size: number;</span><br><span class="line">&#125;</span><br><span class="line">function trace&lt;T extends Sizeable&gt;(arg: T): T &#123;</span><br><span class="line">  console.log(arg.size);</span><br><span class="line">  return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-1-typeof"><a href="#5-1-typeof" class="headerlink" title="5.1 typeof"></a>5.1 typeof</h2><p><strong>typeof 的主要用途是在类型上下文中获取变量或者属性的类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">sem</span>: <span class="title class_">Person</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;semlinker&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Sem</span> = <span class="keyword">typeof</span> sem; <span class="comment">// type Sem = Person</span></span><br></pre></td></tr></table></figure><p>typeof 操作符除了可以获取对象的结构类型之外，它也可以用来获取函数对象的类型，比如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toArray</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Func</span> = <span class="keyword">typeof</span> toArray; <span class="comment">// -&gt; (x: number) =&gt; number[]</span></span><br></pre></td></tr></table></figure><h2 id="5-2-keyof"><a href="#5-2-keyof" class="headerlink" title="5.2 keyof"></a>5.2 keyof</h2><p>keyof可以用于获取某种类型的所有键，其返回类型是联合类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">K1</span> = keyof <span class="title class_">Person</span>; <span class="comment">// &quot;name&quot;  &quot;age&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">K2</span> = keyof <span class="title class_">Person</span>[]; <span class="comment">// &quot;length&quot;  &quot;toString&quot;  &quot;pop&quot;  &quot;push&quot;  &quot;concat&quot;  &quot;join&quot; </span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">K3</span> = keyof &#123; [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="title class_">Person</span> &#125;;  <span class="comment">// string  number</span></span><br></pre></td></tr></table></figure><h1 id="六、tsconfig-json文件"><a href="#六、tsconfig-json文件" class="headerlink" title="六、tsconfig.json文件"></a>六、tsconfig.json文件</h1><ul><li>files - 设置要编译的文件的名称；</li><li>include - 设置需要进行编译的文件，支持路径模式匹配；</li><li>exclude - 设置无需进行编译的文件，支持路径模式匹配；</li><li>compilerOptions - 设置与编译流程相关的选项。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 基本选项 */</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es5&quot;</span><span class="punctuation">,</span>                       <span class="comment">// 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES6&#x27;/&#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;commonjs&quot;</span><span class="punctuation">,</span>                  <span class="comment">// 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span>                             <span class="comment">// 指定要包含在编译中的库文件</span></span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                       <span class="comment">// 允许编译 javascript 文件</span></span><br><span class="line">    <span class="attr">&quot;checkJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                       <span class="comment">// 报告 javascript 文件中的错误</span></span><br><span class="line">    <span class="attr">&quot;jsx&quot;</span><span class="punctuation">:</span> <span class="string">&quot;preserve&quot;</span><span class="punctuation">,</span>                     <span class="comment">// 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;</span></span><br><span class="line">    <span class="attr">&quot;declaration&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                   <span class="comment">// 生成相应的 &#x27;.d.ts&#x27; 文件</span></span><br><span class="line">    <span class="attr">&quot;sourceMap&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                     <span class="comment">// 生成相应的 &#x27;.map&#x27; 文件</span></span><br><span class="line">    <span class="attr">&quot;outFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span>                       <span class="comment">// 将输出文件合并为一个文件</span></span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span>                        <span class="comment">// 指定输出目录</span></span><br><span class="line">    <span class="attr">&quot;rootDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span>                       <span class="comment">// 用来控制输出目录结构 --outDir.</span></span><br><span class="line">    <span class="attr">&quot;removeComments&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                <span class="comment">// 删除编译后的所有的注释</span></span><br><span class="line">    <span class="attr">&quot;noEmit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                        <span class="comment">// 不生成输出文件</span></span><br><span class="line">    <span class="attr">&quot;importHelpers&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                 <span class="comment">// 从 tslib 导入辅助工具函数</span></span><br><span class="line">    <span class="attr">&quot;isolatedModules&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>               <span class="comment">// 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 严格的类型检查选项 */</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                        <span class="comment">// 启用所有严格类型检查选项</span></span><br><span class="line">    <span class="attr">&quot;noImplicitAny&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                 <span class="comment">// 在表达式和声明上有隐含的 any类型时报错</span></span><br><span class="line">    <span class="attr">&quot;strictNullChecks&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>              <span class="comment">// 启用严格的 null 检查</span></span><br><span class="line">    <span class="attr">&quot;noImplicitThis&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                <span class="comment">// 当 this 表达式值为 any 类型的时候，生成一个错误</span></span><br><span class="line">    <span class="attr">&quot;alwaysStrict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                  <span class="comment">// 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 额外的检查 */</span></span><br><span class="line">    <span class="attr">&quot;noUnusedLocals&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                <span class="comment">// 有未使用的变量时，抛出错误</span></span><br><span class="line">    <span class="attr">&quot;noUnusedParameters&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>            <span class="comment">// 有未使用的参数时，抛出错误</span></span><br><span class="line">    <span class="attr">&quot;noImplicitReturns&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>             <span class="comment">// 并不是所有函数里的代码都有返回值时，抛出错误</span></span><br><span class="line">    <span class="attr">&quot;noFallthroughCasesInSwitch&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>    <span class="comment">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 模块解析选项 */</span></span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node&quot;</span><span class="punctuation">,</span>            <span class="comment">// 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span>                       <span class="comment">// 用于解析非相对模块名称的基目录</span></span><br><span class="line">    <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span>                           <span class="comment">// 模块名到基于 baseUrl 的路径映射的列表</span></span><br><span class="line">    <span class="attr">&quot;rootDirs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span>                        <span class="comment">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span></span><br><span class="line">    <span class="attr">&quot;typeRoots&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span>                       <span class="comment">// 包含类型声明的文件列表</span></span><br><span class="line">    <span class="attr">&quot;types&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span>                           <span class="comment">// 需要包含的类型声明文件名列表</span></span><br><span class="line">    <span class="attr">&quot;allowSyntheticDefaultImports&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>  <span class="comment">// 允许从没有设置默认导出的模块中默认导入。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="attr">&quot;sourceRoot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span>                    <span class="comment">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span></span><br><span class="line">    <span class="attr">&quot;mapRoot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span>                       <span class="comment">// 指定调试器应该找到映射文件而不是生成文件的位置</span></span><br><span class="line">    <span class="attr">&quot;inlineSourceMap&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>               <span class="comment">// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span></span><br><span class="line">    <span class="attr">&quot;inlineSources&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                 <span class="comment">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 其他选项 */</span></span><br><span class="line">    <span class="attr">&quot;experimentalDecorators&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>        <span class="comment">// 启用装饰器</span></span><br><span class="line">    <span class="attr">&quot;emitDecoratorMetadata&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span>          <span class="comment">// 为装饰器提供元数据的支持</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;以JavaScript为基础构建的语言&lt;/li&gt;
&lt;li&gt;其是一个JavaScript的超集&lt;/li&gt;
&lt;li&gt;TypeScript拓展了JavaScript，并添加了类型&lt;/li&gt;
&lt;li&gt;TS不能被JS解析器直接执行，需要将ts编译为js进行执行&lt;/li&gt;
&lt;li&gt;JavaScript是弱类型语言, 很多错误只有在运行时才会被发现。而TypeScript提供了一套静态检测机制, 可以帮助我们在编译时就发现错误&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>git时忽略node_modules的方法</title>
    <link href="http://example.com/2022/08/16/git%E6%97%B6%E5%BF%BD%E7%95%A5node-modules%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2022/08/16/git%E6%97%B6%E5%BF%BD%E7%95%A5node-modules%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2022-08-16T01:57:35.000Z</published>
    <updated>2023-03-20T08:32:34.453Z</updated>
    
    <content type="html"><![CDATA[<p>一开始使用git时，我发现node_modules是自动忽略的，但是后来突然开始上传node_modules了。所以查阅了一下资料，发现是缺了<code>.gitgnore</code>文件。 所以在git时想忽略<code>node_modules</code>文件夹，需要在项目目录下，新建<code>.gitgnore</code>文件。 <img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-1660615037295.png" alt="file"> 然后在文件内输入<code>node_modules/</code>就可以了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一开始使用git时，我发现node_modules是自动忽略的，但是后来突然开始上传node_modules了。所以查阅了一下资料，发现是缺了&lt;code&gt;.gitgnore&lt;/code&gt;文件。 所以在git时想忽略&lt;code&gt;node_modules&lt;/code&gt;文件夹，需</summary>
      
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>getter和setter方法</title>
    <link href="http://example.com/2022/07/21/getter%E5%92%8Csetter%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2022/07/21/getter%E5%92%8Csetter%E6%96%B9%E6%B3%95/</id>
    <published>2022-07-21T09:44:36.000Z</published>
    <updated>2023-03-20T08:32:34.407Z</updated>
    
    <content type="html"><![CDATA[<p>有两种类型的对象属性。 第一种是<strong>数据属性</strong>。我们已经知道如何使用它们了。到目前为止，我们使用过的所有属性都是<strong>数据属性</strong>。 第二种类型的属性是新东西。它是<strong>访问器属性</strong>（accessor property）。它们本质上是用于获取和设置值的函数，但从外部代码来看就像常规属性。</p><p>访问器属性由 “getter” 和 “setter” 方法表示。在对象字面量中，它们用<code>get</code>和<code>set</code>表示：</p><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">propName</span>() &#123;</span><br><span class="line">    <span class="comment">// 当读取 obj.propName 时，getter 起作用</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">propName</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 当执行 obj.propName = value 操作时，setter 起作用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当读取<code>obj.propName</code>时，<code>getter</code>起作用，当<code>obj.propName</code>被赋值时，<code>setter</code>起作用。 例如，我们有一个具有 name 和 surname 属性的对象 user：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">surname</span>: <span class="string">&quot;Smith&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在我们想添加一个<code>fullName</code>属性，该属性值应该为<code>&quot;John Smith&quot;</code>。当然，我们不想复制粘贴已有的信息，因此我们可以使用访问器来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">surname</span>: <span class="string">&quot;Smith&quot;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.surname&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">fullName</span>); <span class="comment">// John Smith</span></span><br></pre></td></tr></table></figure><p>从外表看，访问器属性看起来就像一个普通属性。这就是访问器属性的设计思想。我们不以函数的方式<strong>调用</strong><code>user.fullName</code>，我们正常<strong>读取</strong>它：<code>getter</code>在幕后运行。</p><p>截至目前，<code>fullName</code>只有一个<code>getter</code>。如果我们尝试赋值操作<code>user.fullName=</code>，将会出现错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`...`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">user.<span class="property">fullName</span> = <span class="string">&quot;Test&quot;</span>; <span class="comment">// Error（属性只有一个 getter）</span></span><br></pre></td></tr></table></figure><p>让我们通过为<code>user.fullName</code>添加一个<code>setter</code>来修复它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">surname</span>: <span class="string">&quot;Smith&quot;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.surname&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">fullName</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    [<span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">this</span>.<span class="property">surname</span>] = value.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// set fullName 将以给定值执行</span></span><br><span class="line">user.<span class="property">fullName</span> = <span class="string">&quot;Alice Cooper&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">name</span>); <span class="comment">// Alice</span></span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">surname</span>); <span class="comment">// Cooper</span></span><br></pre></td></tr></table></figure><p><strong>所以说，如果只给一个属性设置get而不设置set，则这个属性是只读的，不可被修改。</strong></p><p>可以通过使用<code>defineProperty</code>创建一个<code>fullName</code>访问器，我们可以使用<code>get</code>和<code>set</code>来传递描述符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">surname</span>: <span class="string">&quot;Smith&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(user, <span class="string">&#x27;fullName&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.surname&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    [<span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">this</span>.<span class="property">surname</span>] = value.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">fullName</span>); <span class="comment">// John Smith</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> user) <span class="title function_">alert</span>(key); <span class="comment">// name, surname</span></span><br></pre></td></tr></table></figure><p>请注意，一个属性要么是访问器（具有 get&#x2F;set 方法），要么是数据属性（具有 value），但不能两者都是。 如果我们试图在同一个描述符中同时提供 get 和 value，则会出现错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error: Invalid property descriptor.</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(&#123;&#125;, <span class="string">&#x27;prop&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">value</span>: <span class="number">2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有两种类型的对象属性。 第一种是&lt;strong&gt;数据属性&lt;/strong&gt;。我们已经知道如何使用它们了。到目前为止，我们使用过的所有属性都是&lt;strong&gt;数据属性&lt;/strong&gt;。 第二种类型的属性是新东西。它是&lt;strong&gt;访问器属性&lt;/strong&gt;（accessor property）。它们本质上是用于获取和设置值的函数，但从外部代码来看就像常规属性。&lt;/p&gt;
&lt;p&gt;访问器属性由 “getter” 和 “setter” 方法表示。在对象字面量中，它们用&lt;code&gt;get&lt;/code&gt;和&lt;code&gt;set&lt;/code&gt;表示：&lt;/p&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>新版vscode中无法使用tab+！生成html模板的解决方法</title>
    <link href="http://example.com/2022/07/21/%E6%96%B0%E7%89%88vscode%E4%B8%AD%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8tab%EF%BC%81%E7%94%9F%E6%88%90html%E6%A8%A1%E6%9D%BF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2022/07/21/%E6%96%B0%E7%89%88vscode%E4%B8%AD%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8tab%EF%BC%81%E7%94%9F%E6%88%90html%E6%A8%A1%E6%9D%BF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2022-07-21T09:37:51.000Z</published>
    <updated>2023-03-20T08:32:39.288Z</updated>
    
    <content type="html"><![CDATA[<p>自从前几天更新了 vscode 后发现无法再使用 tab+！生成标准 html 模板了。 后来查阅资料发现，他是把默认生成符改了。 新版 vscode 可以通过输入<code>html:5</code>来生成模板。如下图所示： <img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-1658395859477.png" alt="file"></p><p>当然还可以使用一些别的方法来生成原先的模板，并且可以自定义一些自己的模板。</p><ol><li><p>首先点击左下角设置，之后点击配置用户代码片段。 <img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-1658395968863.png" alt="file"></p></li><li><p>进入后搜索<code>html.json</code>，并点击进入 <img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-1658396012948.png" alt="file"></p></li><li><p>在改文件内添加模板： <img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-1658396080005.png" alt="file"> 具体如下： html5 标准模板：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;html:5&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;!&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;&lt;!DOCTYPE html&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;html&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;head&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;meta charset=\&quot;UTF-8\&quot;&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;meta name=\&quot;viewport\&quot; content=\&quot;width=device-width, initial-scale=1.0\&quot;&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;meta http-equiv=\&quot;X-UA-Compatible\&quot; content=\&quot;ie=edge\&quot;&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;title&gt;&lt;/title&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;/head&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;body&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;/body&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;/html&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HTML5&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我自己使用的 react 模板：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;react&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;!!&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;&lt;!DOCTYPE html&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;html&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;head&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;meta charset=\&quot;UTF-8\&quot;&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;meta name=\&quot;viewport\&quot; content=\&quot;width=device-width, initial-scale=1.0\&quot;&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;meta http-equiv=\&quot;X-UA-Compatible\&quot; content=\&quot;ie=edge\&quot;&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;title&gt;&lt;/title&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;/head&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;body&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;div&gt;&lt;/div&gt;\n\t&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;script src=\&quot;https://unpkg.com/babel-standalone@6/babel.min.js\&quot;&gt;&lt;/script&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;script src=\&quot;https://unpkg.com/react@16/umd/react.development.js\&quot; crossorigin&gt;&lt;/script&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;script src=\&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js\&quot; crossorigin&gt;&lt;/script&gt;\n\t&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;script type=\&quot;text/babel\&quot;&gt;\n\t\t&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;/script&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;/body&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;/html&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>其中 prefix 表示快捷键 <code>\t</code>表示前面空出一个 tab <code>\n</code>表示换行，也就是下面会空一行</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自从前几天更新了 vscode 后发现无法再使用 tab+！生成标准 html 模板了。 后来查阅资料发现，他是把默认生成符改了。 新版 vscode 可以通过输入&lt;code&gt;html:5&lt;/code&gt;来生成模板。如下图所示： &lt;img src=&quot;https://blogw</summary>
      
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>js中的class</title>
    <link href="http://example.com/2022/07/21/js%E4%B8%AD%E7%9A%84class/"/>
    <id>http://example.com/2022/07/21/js%E4%B8%AD%E7%9A%84class/</id>
    <published>2022-07-21T09:16:30.000Z</published>
    <updated>2023-03-20T08:32:34.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、class语法"><a href="#一、class语法" class="headerlink" title="一、class语法"></a>一、class语法</h1><h2 id="1-1-class基本语法"><a href="#1-1-class基本语法" class="headerlink" title="1.1 class基本语法"></a>1.1 class基本语法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="comment">// class 方法</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">  <span class="title function_">method1</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">  <span class="title function_">method2</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">  <span class="title function_">method3</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用<code>new MyClass()</code>来创建具有上述列出的所有方法的新对象。</p><p>new 会自动调用<code>constructor()</code>方法，因此我们可以在<code>constructor()</code>中初始化对象。</p><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 构造器方法</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">user.<span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure><p>当<code>new User(&quot;John&quot;)</code>被调用：</p><ol><li>一个新对象被创建。</li><li><code>constructor</code>使用给定的参数运行，并将其赋值给<code>this.name</code>。</li></ol><p>……然后我们就可以调用对象方法了，例如<code>user.sayHi</code>。</p><p>注意： <strong>类的方法之间没有逗号</strong> 对于新手开发人员来说，常见的陷阱是在类的方法之间放置逗号，这会导致语法错误。 不要把这里的符号与对象字面量相混淆。在类中，不需要逗号。</p><h2 id="1-2-什么是class"><a href="#1-2-什么是class" class="headerlink" title="1.2 什么是class"></a>1.2 什么是class</h2><p><strong>在JavaScript中，类是一种函数。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123; <span class="variable language_">this</span>.<span class="property">name</span> = name; &#125;</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// class 是一个函数</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="title class_">User</span>); <span class="comment">// function</span></span><br><span class="line"><span class="comment">// ...或者，更确切地说，是 constructor 方法</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">User</span> === <span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 方法在 User.prototype 中，例如：</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span>); <span class="comment">// sayHi 方法的代码</span></span><br><span class="line"><span class="comment">// 在原型中实际上有两个方法</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>)); <span class="comment">// constructor, sayHi</span></span><br></pre></td></tr></table></figure><p>所以说创建一个类时，其中的方法会被储存在原型中，所以在调用对象时可以访问类中的方法。 而构造器的作用就是来指定这个类的作用，也就是类这个函数的代码。</p><h2 id="1-3-类不是单纯的语法糖"><a href="#1-3-类不是单纯的语法糖" class="headerlink" title="1.3 类不是单纯的语法糖"></a>1.3 类不是单纯的语法糖</h2><ol><li><p>首先，通过 class 创建的函数具有特殊的内部属性标记<code>[[IsClassConstructor]]: true</code>。因此，它与手动创建并不完全相同。 编程语言会在许多地方检查该属性。例如，与普通函数不同，必须使用 new 来调用它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="title class_">User</span>); <span class="comment">// function</span></span><br><span class="line"><span class="title class_">User</span>(); <span class="comment">// Error: Class constructor User cannot be invoked without &#x27;new&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>类方法不可枚举。 类定义将 “prototype” 中的所有方法的<code>enumerable</code>标志设置为<code>false</code>。这很好，因为如果我们对一个对象调用<code>for..in</code>方法，我们通常不希望<code>class</code>方法出现。</p></li><li><p>类总是使用<code>use strict</code>。 在类构造中的所有代码都将自动进入严格模式。</p></li></ol><p><strong>就像函数一样，类可以在另外一个表达式中被定义，被传递，被返回，被赋值等。</strong></p><h2 id="1-4-类字段"><a href="#1-4-类字段" class="headerlink" title="1.4 类字段"></a>1.4 类字段</h2><p><strong>“类字段”是一种允许添加任何属性的语法。</strong> 类字段重要的不同之处在于，它们会在每个独立对象中被设好，而不是设在<code>User.prototype</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">name</span>); <span class="comment">// John</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>我们也可以在赋值时使用更复杂的表达式和函数调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  name = <span class="title function_">prompt</span>(<span class="string">&quot;Name, please?&quot;</span>, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">name</span>); <span class="comment">// John</span></span><br></pre></td></tr></table></figure><p>类字段<code>click = () =&gt; &#123;...&#125;</code>是基于每一个对象被创建的，在这里对于每一个<code>Button</code>对象都有一个独立的方法，在内部都有一个指向此对象的<code>this</code>。我们可以把 <code>button.click</code>传递到任何地方，而且<code>this</code>的值总是正确的。 在浏览器环境中，它对于进行事件监听尤为有用。</p><h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  prop = value; <span class="comment">// 属性</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">...</span>) &#123; <span class="comment">// 构造器</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">method</span>(<span class="params">...</span>) &#123;&#125; <span class="comment">// method</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">something</span>(<span class="params">...</span>) &#123;&#125; <span class="comment">// getter 方法</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">something</span>(<span class="params">...</span>) &#123;&#125; <span class="comment">// setter 方法</span></span><br><span class="line"></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;&#125; <span class="comment">// 有计算名称（computed name）的方法（此处为 symbol）</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>技术上来说，<code>MyClass</code>是一个函数（我们提供作为<code>constructor</code>的那个），而<code>methods</code>、<code>getters</code>和<code>settors</code>都被写入了<code>MyClass.prototype</code>。</p><h1 id="二、类的继承"><a href="#二、类的继承" class="headerlink" title="二、类的继承"></a>二、类的继承</h1><p><code>class Child extends Parent</code>是类的继承的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">speed</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">run</span>(<span class="params">speed</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">speed</span> = speed;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> runs with speed <span class="subst">$&#123;<span class="variable language_">this</span>.speed&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">stop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">speed</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> stands still.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类rabbit继承了父类animal的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rabbit</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">hide</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> hides!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> <span class="title class_">Rabbit</span>(<span class="string">&quot;White Rabbit&quot;</span>);</span><br><span class="line"></span><br><span class="line">rabbit.<span class="title function_">run</span>(<span class="number">5</span>); <span class="comment">// White Rabbit runs with speed 5.</span></span><br><span class="line">rabbit.<span class="title function_">hide</span>(); <span class="comment">// White Rabbit hides!</span></span><br></pre></td></tr></table></figure><h2 id="2-1-重写方法"><a href="#2-1-重写方法" class="headerlink" title="2.1 重写方法"></a>2.1 重写方法</h2><p>通常，我们不希望完全替换父类的方法，而是希望在父类方法的基础上进行调整或扩展其功能。我们在我们的方法中做一些事儿，但是在它之前或之后或在过程中会调用父类方法。 Class 为此提供了<code>&quot;super&quot;</code>关键字。</p><ul><li>执行<code>super.method(...)</code>来调用一个父类方法。</li><li>执行<code>super(...)</code>来调用一个父类<code>constructor</code>（只能在我们的<code>constructor</code>中）。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">speed</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">run</span>(<span class="params">speed</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">speed</span> = speed;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> runs with speed <span class="subst">$&#123;<span class="variable language_">this</span>.speed&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">stop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">speed</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> stands still.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rabbit</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">hide</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> hides!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">stop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">stop</span>(); <span class="comment">// 调用父类的 stop</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">hide</span>(); <span class="comment">// 然后 hide</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> <span class="title class_">Rabbit</span>(<span class="string">&quot;White Rabbit&quot;</span>);</span><br><span class="line">rabbit.<span class="title function_">run</span>(<span class="number">5</span>); <span class="comment">// White Rabbit runs with speed 5.</span></span><br><span class="line">rabbit.<span class="title function_">stop</span>(); <span class="comment">// White Rabbit stands still. White Rabbit hides!</span></span><br></pre></td></tr></table></figure><p>现在,<code>Rabbit</code>在执行过程中调用父类的<code>super.stop()</code>方法，所以<code>Rabbit</code>也具有了<code>stop</code>方法。</p><p><strong>箭头函数没有<code>super</code>，如果被访问，它会从外部函数获取。</strong></p><h2 id="2-2-重写constructor"><a href="#2-2-重写constructor" class="headerlink" title="2.2 重写constructor"></a>2.2 重写constructor</h2><p>如果一个类扩展了另一个类并且没有<code>constructor</code>，那么将生成下面这样的“空”<code>constructor</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rabbit</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="comment">// 为没有自己的 constructor 的扩展类生成的</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承类的<code>constructor</code>必须调用<code>super(...)</code>，并且一定要在使用<code>this</code>之前调用。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">speed</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rabbit</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, earLength</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">earLength</span> = earLength;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在可以了</span></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> <span class="title class_">Rabbit</span>(<span class="string">&quot;White Rabbit&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="title function_">alert</span>(rabbit.<span class="property">name</span>); <span class="comment">// White Rabbit</span></span><br><span class="line"><span class="title function_">alert</span>(rabbit.<span class="property">earLength</span>); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h1 id="三、静态属性和静态方法"><a href="#三、静态属性和静态方法" class="headerlink" title="三、静态属性和静态方法"></a>三、静态属性和静态方法</h1><p>我们可以把一个方法作为一个整体赋值给类。这样的方法被称为<strong>静态的（static）</strong>。 在一个类的声明中，它们以<code>static</code>关键字开头，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">staticMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span> === <span class="title class_">User</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">User</span>.<span class="title function_">staticMethod</span>(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>通常，<strong>静态方法用于实现属于整个类，但不属于该类任何特定对象的函数</strong>。 例如，我们有对象<code>Article</code>，并且需要一个方法来比较它们。 通常的解决方案就是添加<code>Article.compare</code>静态方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">title, date</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">title</span> = title;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">date</span> = date;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">compare</span>(<span class="params">articleA, articleB</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> articleA.<span class="property">date</span> - articleB.<span class="property">date</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">let</span> articles = [</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Article</span>(<span class="string">&quot;HTML&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">1</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Article</span>(<span class="string">&quot;CSS&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2019</span>, <span class="number">0</span>, <span class="number">1</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Article</span>(<span class="string">&quot;JavaScript&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">1</span>))</span><br><span class="line">];</span><br><span class="line">articles.<span class="title function_">sort</span>(<span class="title class_">Article</span>.<span class="property">compare</span>);</span><br><span class="line"><span class="title function_">alert</span>( articles[<span class="number">0</span>].<span class="property">title</span> ); <span class="comment">// CSS</span></span><br></pre></td></tr></table></figure><p><strong>静态方法不适用于单个对象</strong>。静态方法可以在类上调用，而不是在单个对象上。</p><p>静态的属性也是可能的，它们看起来就像常规的类属性，但前面加有 static：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> publisher = <span class="string">&quot;Levi Ding&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( <span class="title class_">Article</span>.<span class="property">publisher</span> ); <span class="comment">// Levi Ding</span></span><br></pre></td></tr></table></figure><p>这等同于直接给 Article 赋值： <code>Article.publisher = &quot;Levi Ding&quot;;</code></p><p><strong>静态属性和方法是可被继承的。</strong></p><p><strong>静态属性被用于当我们想要存储类级别的数据时，而不是绑定到实例。</strong></p><h1 id="四、私有的和受保护的属性和方法"><a href="#四、私有的和受保护的属性和方法" class="headerlink" title="四、私有的和受保护的属性和方法"></a>四、私有的和受保护的属性和方法</h1><h2 id="4-1-内部接口喝外部接口"><a href="#4-1-内部接口喝外部接口" class="headerlink" title="4.1 内部接口喝外部接口"></a>4.1 内部接口喝外部接口</h2><p>在面向对象的编程中，属性和方法分为两组：</p><ul><li><strong>内部接口</strong> —— 可以通过该类的其他方法访问，但不能从外部访问的方法和属性。</li><li><strong>外部接口</strong> —— 也可以从类的外部访问的方法和属性。</li></ul><p>在 JavaScript 中，有两种类型的对象字段（属性和方法）：</p><ul><li>公共的：可从任何地方访问。它们构成了外部接口。到目前为止，我们只使用了公共的属性和方法。</li><li>私有的：只能从类的内部访问。这些用于内部接口。 在许多其他编程语言中，还存在“受保护”的字段：只能从类的内部和基于其扩展的类的内部访问（例如私有的，但可以从继承的类进行访问）。它们对于内部接口也很有用。从某种意义上讲，它们比私有的属性和方法更为广泛，因为我们通常希望继承类来访问它们。 受保护的字段不是在语言级别的 Javascript 中实现的，但实际上它们非常方便，因为它们是在 Javascript 中模拟的类定义语法。</li></ul><h2 id="4-2-受保护的属性"><a href="#4-2-受保护的属性" class="headerlink" title="4.2 受保护的属性"></a>4.2 受保护的属性</h2><p><strong>受保护的属性通常以下划线 _ 作为前缀。</strong> 这不是在语言级别强制实施的，但是程序员之间有一个众所周知的约定，即不应该从外部访问此类型的属性和方法。 此处以创建一个咖啡机为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeMachine</span> &#123;</span><br><span class="line">  _waterAmount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">waterAmount</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      value = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_waterAmount</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">waterAmount</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_waterAmount</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">power</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_power</span> = power;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建咖啡机</span></span><br><span class="line"><span class="keyword">let</span> coffeeMachine = <span class="keyword">new</span> <span class="title class_">CoffeeMachine</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 加水</span></span><br><span class="line">coffeeMachine.<span class="property">waterAmount</span> = -<span class="number">10</span>; <span class="comment">// _waterAmount 将变为 0，而不是 -10</span></span><br></pre></td></tr></table></figure><p>现在访问已受到控制，因此将水量的值设置为小于零的数变得不可能。</p><h2 id="4-3-只读的属性"><a href="#4-3-只读的属性" class="headerlink" title="4.3 只读的属性"></a>4.3 只读的属性</h2><p>对于<code>power</code>属性，让我们将它设为只读。有时候一个属性必须只能被在创建时进行设置，之后不再被修改。 咖啡机就是这种情况：功率永远不会改变。 要做到这一点，我们只需要设置 getter，而不设置 setter：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeMachine</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">power</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_power</span> = power;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">power</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_power</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建咖啡机</span></span><br><span class="line"><span class="keyword">let</span> coffeeMachine = <span class="keyword">new</span> <span class="title class_">CoffeeMachine</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">`Power is: <span class="subst">$&#123;coffeeMachine.power&#125;</span>W`</span>); <span class="comment">// 功率是：100W</span></span><br><span class="line">coffeeMachine.<span class="property">power</span> = <span class="number">25</span>; <span class="comment">// Error（没有 setter）</span></span><br></pre></td></tr></table></figure><p>这里我们使用了 getter&#x2F;setter 语法。 但大多数时候首选 get…&#x2F;set… 函数，像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeMachine</span> &#123;</span><br><span class="line">  _waterAmount = <span class="number">0</span>;</span><br><span class="line">  <span class="title function_">setWaterAmount</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) value = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_waterAmount</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getWaterAmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_waterAmount</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">CoffeeMachine</span>().<span class="title function_">setWaterAmount</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>这看起来有点长，但函数更灵活。它们可以接受多个参数（即使我们现在还不需要）。 另一方面，get&#x2F;set 语法更短，所以最终没有严格的规定，而是由你自己来决定。</p><p><strong>受保护的字段是可以被继承的</strong></p><h2 id="4-4-私有的属性"><a href="#4-4-私有的属性" class="headerlink" title="4.4 私有的属性"></a>4.4 私有的属性</h2><p>私有属性和方法应该以 # 开头。它们只在类的内部可被访问。 在语言级别，# 是该字段为私有的特殊标志。我们无法从外部或从继承的类中访问它。 私有字段与公共字段不会发生冲突。我们可以同时拥有私有的<code>#waterAmount</code>和公共的<code>waterAmount</code>字段。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeMachine</span> &#123;</span><br><span class="line"></span><br><span class="line">  #waterAmount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">waterAmount</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#waterAmount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">waterAmount</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) value = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.#waterAmount = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> machine = <span class="keyword">new</span> <span class="title class_">CoffeeMachine</span>();</span><br><span class="line"></span><br><span class="line">machine.<span class="property">waterAmount</span> = <span class="number">100</span>;</span><br><span class="line"><span class="title function_">alert</span>(machine.#waterAmount); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>目前，各个浏览器对私有字段的支持不是很好，但可以用 polyfill 解决。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、class语法&quot;&gt;&lt;a href=&quot;#一、class语法&quot; class=&quot;headerlink&quot; title=&quot;一、class语法&quot;&gt;&lt;/a&gt;一、class语法&lt;/h1&gt;&lt;h2 id=&quot;1-1-class基本语法&quot;&gt;&lt;a href=&quot;#1-1-class基本语法&quot; class=&quot;headerlink&quot; title=&quot;1.1 class基本语法&quot;&gt;&lt;/a&gt;1.1 class基本语法&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;MyClass&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// class 方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;title function_&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &amp;#123; ... &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;title function_&quot;&gt;method1&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &amp;#123; ... &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;title function_&quot;&gt;method2&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &amp;#123; ... &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;title function_&quot;&gt;method3&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &amp;#123; ... &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;然后使用&lt;code&gt;new MyClass()&lt;/code&gt;来创建具有上述列出的所有方法的新对象。&lt;/p&gt;
&lt;p&gt;new 会自动调用&lt;code&gt;constructor()&lt;/code&gt;方法，因此我们可以在&lt;code&gt;constructor()&lt;/code&gt;中初始化对象。&lt;/p&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>axios详解</title>
    <link href="http://example.com/2022/07/13/axios%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/07/13/axios%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-07-13T10:04:15.000Z</published>
    <updated>2023-03-20T08:32:32.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、配置和下载"><a href="#一、配置和下载" class="headerlink" title="一、配置和下载"></a>一、配置和下载</h1><h2 id="1-1-json-server"><a href="#1-1-json-server" class="headerlink" title="1.1 json-server"></a>1.1 json-server</h2><p>首先是 json-server 的下载和安装</p><ol><li>在命令行中输入<code>npm install -g json-server</code></li><li>在需要使用的文件夹下创建文件 db.json</li><li>在 db.json 中置入内容</li></ol><span id="more"></span><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;posts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;json-server&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;typicode&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;comments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;profile&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;typicode&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>开启 json-server 服务：<code>json-server --watch db.json</code></li></ol><p>json-server 主要是提供一个虚假的服务器，从而实现数据通信。在本文中主要起演示作用</p><h2 id="1-2-axios"><a href="#1-2-axios" class="headerlink" title="1.2 axios"></a>1.2 axios</h2><p>从下面方式中选择一项进行安装或使用</p><ol><li>通过 npm 安装：<code>npm install axios</code></li><li>通过 bower 安装：<code>bower install axios</code></li><li>通过 yarn 安装：<code>yarn add axios</code></li><li>通过 pnpm 安装：<code>pnpm add axios</code></li><li>直接使用 script 调用 api：<code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</code></li><li>可以通过国内网站<code>https://www.bootcdn.cn/</code>来调用国内 api 从而加快访问速度：<code>&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/1.0.0-alpha.1/axios.js&quot;&gt;&lt;/script&gt;</code></li></ol><p>在项目中使用 axios 一般使用上面几种方式来进行，但是在日常练习中，可以直接调用 api</p><h1 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h1><h2 id="2-1-基本使用"><a href="#2-1-基本使用" class="headerlink" title="2.1 基本使用"></a>2.1 基本使用</h2><p>基本请求共包含四个，分别是 GET&#x2F;POST&#x2F;PUT&#x2F;DELETE 在 json-server 服务中 GET 表示查看内容，POST 表示新增内容，PUT 表示修改内容，DELETE 表示删除内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送请求，获得内容</span></span><br><span class="line">btn[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="comment">// 发送方法</span></span><br><span class="line">        <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">        <span class="comment">// 发送链接</span></span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000/posts/2&quot;</span>,</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 添加新内容</span></span><br><span class="line">btn[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="comment">// 发送方法</span></span><br><span class="line">        <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        <span class="comment">// 发送链接</span></span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000/posts&quot;</span>,</span><br><span class="line">        <span class="comment">// 设置请求体</span></span><br><span class="line">        <span class="attr">data</span>: &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">            <span class="attr">author</span>: <span class="string">&quot;wh&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以 PUT 和 POST 为例，主要需要设置发送的<strong>请求方法</strong>，和<strong>请求的连接</strong>，如果需要的话，还需要设置<strong>请求体</strong></p><h2 id="2-2-axios-的其他使用"><a href="#2-2-axios-的其他使用" class="headerlink" title="2.2 axios 的其他使用"></a>2.2 axios 的其他使用</h2><p>axios 和 ajax 比较类似，可以直接使用现成的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">request</span>(config)</span><br><span class="line">axios.<span class="title function_">get</span>(url[, config])</span><br><span class="line">axios.<span class="title function_">delete</span>(url[, config])</span><br><span class="line">axios.<span class="title function_">head</span>(url[, config])</span><br><span class="line">axios.<span class="title function_">options</span>(url[, config])</span><br><span class="line">axios.<span class="title function_">post</span>(url[, data[, config]])</span><br><span class="line">axios.<span class="title function_">put</span>(url[, data[, config]])</span><br><span class="line">axios.<span class="title function_">patch</span>(url[, data[, config]])</span><br></pre></td></tr></table></figure><p>具体的使用举例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">btn[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    axios</span><br><span class="line">        .<span class="title function_">request</span>(&#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">            <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000/comments&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//发送post请求</span></span><br><span class="line">btn[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    axios</span><br><span class="line">        .<span class="title function_">post</span>(<span class="string">&quot;http://localhost:3000/comments&quot;</span>, &#123;</span><br><span class="line">            <span class="attr">body</span>: <span class="string">&quot;hahahaha&quot;</span>,</span><br><span class="line">            <span class="attr">postId</span>: <span class="number">2</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-3-axios-的响应"><a href="#2-3-axios-的响应" class="headerlink" title="2.3 axios 的响应"></a>2.3 axios 的响应</h2><p>config：配置对象，包括 url，请求方式等内容 data：响应体的内容 headers：响应头的信息 request：原生的 ajax 请求对象 status：响应状态码 statusText：响应状态</p><h2 id="2-4-axios-配置对象详细说明"><a href="#2-4-axios-配置对象详细说明" class="headerlink" title="2.4 axios 配置对象详细说明"></a>2.4 axios 配置对象详细说明</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 请求地址，可以将前面的省略从而和baseURL结合</span></span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求方法</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// axios会将baseURL和url相结合，所以说如果要调用统一域名下的不同url，这样就会很方便</span></span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://some-domain.com/api/&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对请求数据进行一个处理，处理完成后再发送给服务器</span></span><br><span class="line">  <span class="comment">// 只能对四种基本方法进行操作</span></span><br><span class="line">  <span class="attr">transformRequest</span>: [<span class="keyword">function</span> (<span class="params">data, headers</span>) &#123;</span><br><span class="line">    <span class="comment">// Do whatever you want to transform the data</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对返回的结果进行处理</span></span><br><span class="line">  <span class="attr">transformResponse</span>: [<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// Do whatever you want to transform the data</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 传递数据头</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;<span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span>&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个的主要目的是当发送url时，有时候需要在url后面加一些字符串数据，但是直接加不方便，就可以通过这个方法，它会自动将其中的键和值插入到url最后面</span></span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对请求的参数进行一个序列化，根据接口不同而不同</span></span><br><span class="line">  <span class="attr">paramsSerializer</span>: &#123;</span><br><span class="line">    <span class="attr">indexes</span>: <span class="literal">null</span> <span class="comment">// array indexes format (null - no brackets, false - empty brackets, true - brackets with indexes)</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求体设置，共分为两种，分别是字符串格式和对象形式</span></span><br><span class="line">  <span class="comment">// 对象形式axios会将其转换为json格式，字符串格式会直接进行传递</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">data</span>: <span class="string">&#x27;Country=Brasil&amp;City=Belo Horizonte&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 超时时间，单位为ms</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>, <span class="comment">// default is `0` (no timeout)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//跨域请求时对cookie是否携带，false为不携带</span></span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">false</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//发送ajax请求或者是http请求</span></span><br><span class="line">  <span class="attr">adapter</span>: <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置用户名和密码</span></span><br><span class="line">  <span class="attr">auth</span>: &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;janedoe&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;s00pers3cret&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对响应体格式做一个要求</span></span><br><span class="line">  <span class="attr">responseType</span>: <span class="string">&#x27;json&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 响应体编码</span></span><br><span class="line">  <span class="attr">responseEncoding</span>: <span class="string">&#x27;utf8&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跨域请求cookie设置</span></span><br><span class="line">  <span class="attr">xsrfCookieName</span>: <span class="string">&#x27;XSRF-TOKEN&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跨域请求头信息设置，这两个主要是做保护作用，发送唯一标识，对名字做表好似</span></span><br><span class="line">  <span class="attr">xsrfHeaderName</span>: <span class="string">&#x27;X-XSRF-TOKEN&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上传回调</span></span><br><span class="line">  <span class="attr">onUploadProgress</span>: <span class="keyword">function</span> (<span class="params">progressEvent</span>) &#123;</span><br><span class="line">    <span class="comment">// Do whatever you want with the native progress event</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下载回调</span></span><br><span class="line">  <span class="attr">onDownloadProgress</span>: <span class="keyword">function</span> (<span class="params">progressEvent</span>) &#123;</span><br><span class="line">    <span class="comment">// Do whatever you want with the native progress event</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置响应体最大长度，单位为字节</span></span><br><span class="line">  <span class="attr">maxContentLength</span>: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置请求最大长度</span></span><br><span class="line">  <span class="attr">maxBodyLength</span>: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对响应结果做一个设置，也就是认定什么情况下它才属于成功的，属于默认规则</span></span><br><span class="line">  <span class="attr">validateStatus</span>: <span class="keyword">function</span> (<span class="params">status</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// default</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最大跳转次数，一般只能用在node.js</span></span><br><span class="line">  <span class="attr">maxRedirects</span>: <span class="number">21</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跳转前的操作</span></span><br><span class="line">  <span class="attr">beforeRedirect</span>: <span class="function">(<span class="params">options, &#123; headers &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">hostname</span> === <span class="string">&quot;example.com&quot;</span>) &#123;</span><br><span class="line">      options.<span class="property">auth</span> = <span class="string">&quot;user:password&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置socket文件位置，</span></span><br><span class="line">  <span class="attr">socketPath</span>: <span class="literal">null</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// http状态</span></span><br><span class="line">  <span class="attr">httpAgent</span>: <span class="keyword">new</span> http.<span class="title class_">Agent</span>(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">  <span class="attr">httpsAgent</span>: <span class="keyword">new</span> https.<span class="title class_">Agent</span>(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 代理，通过代理可以进行爬虫或者投票这些，就是通过代理池去操作</span></span><br><span class="line">  <span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="attr">protocol</span>: <span class="string">&#x27;https&#x27;</span>,</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">9000</span>,</span><br><span class="line">    <span class="attr">auth</span>: &#123;</span><br><span class="line">      <span class="attr">username</span>: <span class="string">&#x27;mikeymike&#x27;</span>,</span><br><span class="line">      <span class="attr">password</span>: <span class="string">&#x27;rapunz3l&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对ajax请求进行一个取消的操作</span></span><br><span class="line">  <span class="attr">cancelToken</span>: <span class="keyword">new</span> <span class="title class_">CancelToken</span>(<span class="keyword">function</span> (<span class="params">cancel</span>) &#123;</span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// an alternative way to cancel Axios requests using AbortController</span></span><br><span class="line">  <span class="attr">signal</span>: <span class="keyword">new</span> <span class="title class_">AbortController</span>().<span class="property">signal</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `decompress` indicates whether or not the response body should be decompressed</span></span><br><span class="line">  <span class="comment">// automatically. If set to `true` will also remove the &#x27;content-encoding&#x27; header</span></span><br><span class="line">  <span class="comment">// from the responses objects of all decompressed responses</span></span><br><span class="line">  <span class="comment">// - Node only (XHR cannot turn off decompression)</span></span><br><span class="line">  <span class="attr">decompress</span>: <span class="literal">true</span> <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `insecureHTTPParser` boolean.</span></span><br><span class="line">  <span class="comment">// Indicates where to use an insecure HTTP parser that accepts invalid HTTP headers.</span></span><br><span class="line">  <span class="comment">// This may allow interoperability with non-conformant HTTP implementations.</span></span><br><span class="line">  <span class="comment">// Using the insecure parser should be avoided.</span></span><br><span class="line">  <span class="comment">// see options https://nodejs.org/dist/latest-v12.x/docs/api/http.html#http_http_request_url_options_callback</span></span><br><span class="line">  <span class="comment">// see also https://nodejs.org/en/blog/vulnerability/february-2020-security-releases/#strict-http-header-parsing-none</span></span><br><span class="line">  <span class="attr">insecureHTTPParser</span>: <span class="literal">undefined</span> <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// transitional options for backward compatibility that may be removed in the newer versions</span></span><br><span class="line">  <span class="attr">transitional</span>: &#123;</span><br><span class="line">    <span class="comment">// silent JSON parsing mode</span></span><br><span class="line">    <span class="comment">// `true`  - ignore JSON parsing errors and set response.data to null if parsing failed (old behaviour)</span></span><br><span class="line">    <span class="comment">// `false` - throw SyntaxError if JSON parsing failed (Note: responseType must be set to &#x27;json&#x27;)</span></span><br><span class="line">    <span class="attr">silentJSONParsing</span>: <span class="literal">true</span>, <span class="comment">// default value for the current Axios version</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// try to parse the response string as JSON even if `responseType` is not &#x27;json&#x27;</span></span><br><span class="line">    <span class="attr">forcedJSONParsing</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// throw ETIMEDOUT error instead of generic ECONNABORTED on request timeouts</span></span><br><span class="line">    <span class="attr">clarifyTimeoutError</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="comment">// The FormData class to be used to automatically serialize the payload into a FormData object</span></span><br><span class="line">    <span class="title class_">FormData</span>: <span class="variable language_">window</span>?.<span class="property">FormData</span>  <span class="variable language_">global</span>?.<span class="property">FormData</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">formSerializer</span>: &#123;</span><br><span class="line">      <span class="attr">visitor</span>: <span class="function">(<span class="params">value, key, path, helpers</span>)=&gt;</span> &#123;&#125;; <span class="comment">// custom visitor funaction to serrialize form values</span></span><br><span class="line">      <span class="attr">dots</span>: boolean; <span class="comment">// use dots instead of brackets format</span></span><br><span class="line">      <span class="attr">metaTokens</span>: boolean; <span class="comment">// keep special endings like &#123;&#125; in parameter key</span></span><br><span class="line">      <span class="attr">indexes</span>: boolean; <span class="comment">// array indexes format null - no brackets, false - empty brackets, true - brackets with indexes</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-axios-的默认配置"><a href="#2-5-axios-的默认配置" class="headerlink" title="2.5 axios 的默认配置"></a>2.5 axios 的默认配置</h2><p>通过<code>axios.defaults.xxx</code>即可进行配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">defaults</span>.<span class="property">method</span> = <span class="string">&quot;GET&quot;</span>;</span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&quot;http://localhost:3000&quot;</span>;</span><br><span class="line"></span><br><span class="line">btn[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    axios</span><br><span class="line">        .<span class="title function_">request</span>(&#123;</span><br><span class="line">            <span class="attr">url</span>: <span class="string">&quot;/comments&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-6-axios-创建实例对象"><a href="#2-6-axios-创建实例对象" class="headerlink" title="2.6 axios 创建实例对象"></a>2.6 axios 创建实例对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> joke = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&quot;http://route.showapi.com&quot;</span>,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">2000</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">joke.<span class="title function_">get</span>(<span class="string">&quot;/341-2&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="三、拦截器"><a href="#三、拦截器" class="headerlink" title="三、拦截器"></a>三、拦截器</h1><p>包括请求拦截器和响应拦截器 拦截器的主要作用就是在发送或接收的过程中对数据进行处理 比如说请求拦截器就是将数据发送到服务器的过程中进行处理，如果符合要求就进行传送，不符合要求则放弃传送 响应拦截器可以对数据进行处理等操作 等于就是<strong>一道道关卡</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置请求拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求拦截器 成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求拦截器 失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置响应拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;响应拦截器 成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;响应拦截器 失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>通过请求拦截器和响应拦截器可以对请求和返回的数据进行修改</p><h1 id="四、取消-axios-请求"><a href="#四、取消-axios-请求" class="headerlink" title="四、取消 axios 请求"></a>四、取消 axios 请求</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 声明全局变量</span></span><br><span class="line"><span class="keyword">let</span> cancel = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">btn[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cancel !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="title function_">cancel</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000/posts&quot;</span>,</span><br><span class="line">        <span class="comment">// 1.添加配置对象的属性</span></span><br><span class="line">        <span class="attr">cancelToken</span>: <span class="keyword">new</span> axios.<span class="title class_">CancelToken</span>(<span class="keyword">function</span> (<span class="params">c</span>) &#123;</span><br><span class="line">            <span class="comment">// 3.将c的值赋值给cancel</span></span><br><span class="line">            cancel = c;</span><br><span class="line">        &#125;),</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">        cancel = <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">btn[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">cancel</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>取消请求主要是通过<code>cancelToken</code>来进行，通过对一个变量来赋值，在需要调用取消的时候，直接使用<code>cancel()</code>方法来取消请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cancelToken</span>: <span class="keyword">new</span> axios.<span class="title class_">CancelToken</span>(<span class="keyword">function</span> (<span class="params">c</span>) &#123;</span><br><span class="line">            <span class="comment">// 3.将c的值赋值给cancel</span></span><br><span class="line">            cancel = c;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、配置和下载&quot;&gt;&lt;a href=&quot;#一、配置和下载&quot; class=&quot;headerlink&quot; title=&quot;一、配置和下载&quot;&gt;&lt;/a&gt;一、配置和下载&lt;/h1&gt;&lt;h2 id=&quot;1-1-json-server&quot;&gt;&lt;a href=&quot;#1-1-json-server&quot; class=&quot;headerlink&quot; title=&quot;1.1 json-server&quot;&gt;&lt;/a&gt;1.1 json-server&lt;/h2&gt;&lt;p&gt;首先是 json-server 的下载和安装&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在命令行中输入&lt;code&gt;npm install -g json-server&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在需要使用的文件夹下创建文件 db.json&lt;/li&gt;
&lt;li&gt;在 db.json 中置入内容&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>promise详解</title>
    <link href="http://example.com/2022/07/12/promise%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/07/12/promise%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-07-12T04:47:50.000Z</published>
    <updated>2023-03-20T08:32:36.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>promise 是 js 中进行异步编程的<strong>新解决方案</strong> 旧方案是使用单纯的回调函数</p><p>promise 可以使回调函数的方式更加灵活 promise：启动异步任务 &#x3D;&gt; 返回 promise 对象 &#x3D;&gt; 给 promise 对象绑定回调函数（甚至可以在异步任务结束后指定&#x2F;多个）</p><p><strong>promise 支持链式调用，可以解决回调地狱问题</strong></p><span id="more"></span><ol><li>什么是回调地狱？ 回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行的条件</li><li>回调地狱的缺点？ 不便于阅读，不便于异常处理</li><li>解决方案： promise 链式调用</li></ol><h1 id="二、promise-使用"><a href="#二、promise-使用" class="headerlink" title="二、promise 使用"></a>二、promise 使用</h1><h2 id="2-1-promise-基本使用"><a href="#2-1-promise-基本使用" class="headerlink" title="2.1 promise 基本使用"></a>2.1 promise 基本使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise 形式实现</span></span><br><span class="line"><span class="comment">// resolve 和reject都是函数类型的数据</span></span><br><span class="line"><span class="comment">// resolve代表解决时实现的函数</span></span><br><span class="line"><span class="comment">// reject代表拒绝时实现的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// promise 可以传递参数</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> n = <span class="title function_">rand</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">30</span>) &#123;</span><br><span class="line"><span class="title function_">resolve</span>(n); <span class="comment">//将promise对象的状态设置为成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="title function_">reject</span>(n); <span class="comment">//将promise对象的状态设置为失败</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// then函数，前面是resolve的解决方案，后面是reject的解决方案</span></span><br><span class="line">p.<span class="title function_">then</span>(</span><br><span class="line"><span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;congratulation&quot;</span> + value);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;try again&quot;</span> + reason);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>promise 基本部分由两部分组成，第一部分为定义部分： <code>const p = new Promise((resolve, reject) =&gt;&#123;&#125;);</code> 其中包括 resolve 和 reject 两部分，这两部分表示的都是函数。 resolve 表示的是设置为成功时执行的函数； reject 表示的是设置为失败时执行的函数。</p><p>其中 resolve 和 reject 都能够传递参数。</p><p>第二部分为执行部分，也就是定义 resolve 函数和 reject 函数分别代表着什么含义。 第一部分传递的参数传递到第二部分可以分别进行定义，正如上面的 n 传递到 resolve 中代表的是 value；传递到 reject 中代表的是 reason。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="title function_">then</span>(</span><br><span class="line"><span class="function">(<span class="params">value</span>) =&gt;</span> &#123;&#125;, <span class="comment">//第一个回调函数代表的是resolve函数</span></span><br><span class="line"><span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;&#125; <span class="comment">//第二个回调函数代表的是reject函数</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="2-2-promise-的状态改变"><a href="#2-2-promise-的状态改变" class="headerlink" title="2.2 promise 的状态改变"></a>2.2 promise 的状态改变</h2><p>promise 中的属性（promiseState）：</p><ul><li>pending 未决定的</li><li>resolved&#x2F;fullfilled 成功</li><li>rejected 失败 这个状态一个 promise 对象只能改变一次，并且只能够是<code>pending --&gt; resolved</code>，或者是<code>pending --&gt; rejected</code>。 无论变为成功还是失败，都会有一个结果数据 成功的结果数据一般称为 value，失败的结果数据一般称为 reason</li></ul><p>promise 中的另一个属性（promiseResult）保存着异步任务成功或失败的结果</p><p>也就是 resolve 或者是 reject 的值</p><h2 id="2-3-promise-的工作流程"><a href="#2-3-promise-的工作流程" class="headerlink" title="2.3 promise 的工作流程"></a>2.3 promise 的工作流程</h2><p>[<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/01.jpg">]</p><h2 id="2-4-promise-的-API"><a href="#2-4-promise-的-API" class="headerlink" title="2.4 promise 的 API"></a>2.4 promise 的 API</h2><p>promise 的构造函数：promise(executor){}</p><ul><li>executor 函数：执行器<code>(resolve, reject)=&gt;&#123;&#125;</code></li><li>resolve 函数：内部定义成功时调用的函数 value &#x3D;&gt;{}</li><li>reject 函数：内部定义失败时调用的函数 reason &#x3D;&gt;{}</li><li>executor 会在 promise 内部立即<strong>同步调用</strong>，<strong>异步操作</strong>在<strong>执行器</strong>中执行</li></ul><p><code>promise.then(onResolve,onReject)=&gt;&#123;&#125;</code>表示可以指定成功和失败的回调函数 <code>promise.catch(onReject)=&gt;&#123;&#125;</code>其只能表示失败的回调函数</p><p><code>promise.resolve()</code>中如果传入的参数为 非 Promise 类型的对象，则返回的结果为成功 promise 对象 如果传入的参数为 Promise 对象，则参数的结果决定了 resolve 的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(xxx);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1); <span class="comment">//输出的值为xxx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">reject</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2); <span class="comment">//输出的值为error，类型为rejected</span></span><br><span class="line"><span class="comment">// 但是如果promise对象里是resolve(&#x27;ok&#x27;),那么输出的值就是ok，类型为resolved</span></span><br></pre></td></tr></table></figure><p><code>promise.reject()</code>用于传出 reason 信息，也就是不管里面是什么，<strong>输出类型都是 rejected</strong>。</p><p><code>promise.all([])</code>中包含 n 个 promise 的数组，其会返回一个新的 promise，只有所有的 promise 都成功才成功，只要有一个失败了就直接失败</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;oh yeah&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;err&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]); <span class="comment">//result状态为resolved，值为p1,p2,p3的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3, p4]); <span class="comment">//result状态为rejected，值为p4的值，因为他是err</span></span><br></pre></td></tr></table></figure><p><code>promise.race()</code>其也是包含 n 个 promise 的数组，其会返回一个新的 promise。这一堆 promise 数组里谁先改变状态，谁就先输出。 <strong>所以说这是一个赛跑问题，跑的最快的先出来</strong></p><h2 id="2-5-promise-的关键问题"><a href="#2-5-promise-的关键问题" class="headerlink" title="2.5 promise 的关键问题"></a>2.5 promise 的关键问题</h2><h3 id="2-5-1-改变-promise-对象状态的方式"><a href="#2-5-1-改变-promise-对象状态的方式" class="headerlink" title="2.5.1 改变 promise 对象状态的方式"></a>2.5.1 改变 promise 对象状态的方式</h3><ol><li>resolve 函数，<code>resolve(&#39;ok&#39;);</code> pending &#x3D;&gt; resolved</li><li>reject 函数：<code>reject(&#39;error&#39;);</code> pending &#x3D;&gt; rejected</li><li>抛出错误：<code>throw &#39;error&#39;;</code> pending &#x3D;&gt; rejected</li></ol><h3 id="2-5-2-promise-指定多个回调"><a href="#2-5-2-promise-指定多个回调" class="headerlink" title="2.5.2 promise 指定多个回调"></a>2.5.2 promise 指定多个回调</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">alert</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个回调都会进行</span></span><br></pre></td></tr></table></figure><p>为一个 promise 指定多个回调时，当 promise 改变为对应状态是都会调用</p><h3 id="2-5-3-改变-promise-状态和指定回调函数谁先谁后"><a href="#2-5-3-改变-promise-状态和指定回调函数谁先谁后" class="headerlink" title="2.5.3 改变 promise 状态和指定回调函数谁先谁后"></a>2.5.3 改变 promise 状态和指定回调函数谁先谁后</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(</span><br><span class="line"><span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当执行器函数中是一个同步任务时，先改变 resolve 的状态，再执行 then 中的函数 或者执行器函数中有一个延迟时间，但是 then 中延迟时间更长，则也会先改变 resolve 的状态，再执行函数</p><p>当执行器函数中是一个异步任务时，也就是需要等待一段时间的时候，先执行 then 中的函数，再改变状态</p><h3 id="2-5-4-promise-then-中返回的新的-promise-的结果状态由什么决定"><a href="#2-5-4-promise-then-中返回的新的-promise-的结果状态由什么决定" class="headerlink" title="2.5.4 promise.then()中返回的新的 promise 的结果状态由什么决定"></a>2.5.4 promise.then()中返回的新的 promise 的结果状态由什么决定</h3><p><strong>由 then()指定的回调函数执行的结果决定</strong></p><p>如果抛出异常，新 promise 变为 rejected，reason 为抛出的异常 如果返回的是非 promise 的任意值，新 promise 变为 resolved，value 为返回的值 如果返回的是另一个新 promise，此 promise 的结果就会变成新 promise 的结果</p><h3 id="2-5-5-promise-串联多个操作任务"><a href="#2-5-5-promise-串联多个操作任务" class="headerlink" title="2.5.5 promise 串联多个操作任务"></a>2.5.5 promise 串联多个操作任务</h3><p>通过 then 方法可以链式调用多个任务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">//输出success，因为这个里面的没有返回值结果，所以说这个undefined的返回值传到下一个里面输出的就是undefined</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">//输出undefined</span></span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-5-6-promise-异常穿透"><a href="#2-5-6-promise-异常穿透" class="headerlink" title="2.5.6 promise 异常穿透"></a>2.5.6 promise 异常穿透</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;error!&quot;</span>; <span class="comment">//比如说我们这里抛出了一个异常，但是会在最后进行处理</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">233</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">344</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">warn</span>(reason); <span class="comment">//也就是这里来进行异常处理，这就叫做异常穿透</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当使用 promise 的 then 链式调用时，可以在最后指定失败的回调。 前面任何操作出了异常，都会传到最后失败的回调中处理</p><h3 id="2-5-7-中断-promise-链"><a href="#2-5-7-中断-promise-链" class="headerlink" title="2.5.7 中断 promise 链"></a>2.5.7 中断 promise 链</h3><p>在回调函数中返回一个 pending 状态的 promise 对象，就能够中断链式调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);  <span class="comment">//这里是空的。返回pending，所以最后只显示111，后面就被忽略了。</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">233</span>);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h1 id="三、自定义-promise（手写）"><a href="#三、自定义-promise（手写）" class="headerlink" title="三、自定义 promise（手写）"></a>三、自定义 promise（手写）</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line"><span class="comment">// 定时器部分是为了实现回调函数的异步执行。</span></span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line"><span class="comment">// 添加属性</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">PromiseState</span> = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">PromiseResult</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">callbacks</span> = [];</span><br><span class="line"><span class="comment">// 保存实例对象的this值</span></span><br><span class="line"><span class="keyword">const</span> self = <span class="variable language_">this</span>; <span class="comment">//self _this that</span></span><br><span class="line"><span class="comment">// 因为下面function里的this指向的是window对象。</span></span><br><span class="line"><span class="comment">// 所以说需要将这里的this的值保存一下，在下面进行调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">data</span>) &#123;</span><br><span class="line"><span class="comment">// 判断状态</span></span><br><span class="line"><span class="keyword">if</span> (self.<span class="property">PromiseState</span> !== <span class="string">&quot;pending&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 1.修改对象的状态(PromiseState)</span></span><br><span class="line">self.<span class="property">PromiseState</span> = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line"><span class="comment">// 2.设置对象结果值(PromiseResult)</span></span><br><span class="line">self.<span class="property">PromiseResult</span> = data;</span><br><span class="line"><span class="comment">// 调用成功的回调函数</span></span><br><span class="line"><span class="comment">// 这里针对的是单次回调</span></span><br><span class="line"><span class="comment">// if(self.callback.onResolved)&#123;</span></span><br><span class="line"><span class="comment">//     self.callback.onResolved(data);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当多个回调时，需要用for循环遍历</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">item.<span class="title function_">onResolved</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// reject函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">data</span>) &#123;</span><br><span class="line"><span class="comment">// 判断状态</span></span><br><span class="line"><span class="keyword">if</span> (self.<span class="property">PromiseState</span> !== <span class="string">&quot;pending&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 1.修改对象的状态(PromiseState)</span></span><br><span class="line">self.<span class="property">PromiseState</span> = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line"><span class="comment">// 2.设置对象结果值(PromiseResult)</span></span><br><span class="line">self.<span class="property">PromiseResult</span> = data;</span><br><span class="line"><span class="comment">// 调用成功的回调函数</span></span><br><span class="line"><span class="comment">// if(self.callback.onRejected)&#123;</span></span><br><span class="line"><span class="comment">//     self.callback.onRejected(data);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">item.<span class="title function_">onRejected</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 同步调用执行器函数</span></span><br><span class="line"><span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"><span class="title function_">reject</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// then方法封装</span></span><br><span class="line"><span class="title function_">then</span>(<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line"><span class="comment">// 判断回调函数参数</span></span><br><span class="line"><span class="comment">// 这部分主要是解决链式传递出现的问题</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">onRejected = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> reason;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> onResolved !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">onResolved = <span class="function">(<span class="params">value</span>) =&gt;</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为了能够解决回调为promise对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 封装函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callback</span>(<span class="params">type</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 获取回调函数的执行结果</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">type</span>(self.<span class="property">PromiseResult</span>);</span><br><span class="line"><span class="comment">//判断</span></span><br><span class="line"><span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">result.<span class="title function_">then</span>(</span><br><span class="line"><span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(v);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">reject</span>(r);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"><span class="title function_">reject</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">callback</span>(onResolved);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">callback</span>(onRejected);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断pending状态</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line"><span class="comment">// 保存回调函数</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line"><span class="comment">// onResolved: onResolved,</span></span><br><span class="line"><span class="comment">// onRejected: onRejected</span></span><br><span class="line"><span class="attr">onResolved</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">callback</span>(onResolved);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">onRejected</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">callback</span>(onRejected);</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加resolve方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line"><span class="comment">// 返回promise对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">value.<span class="title function_">then</span>(</span><br><span class="line"><span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(v);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">reject</span>(r);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 状态设置为成功</span></span><br><span class="line"><span class="title function_">resolve</span>(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加reject方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">reject</span>(reason);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加all方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">all</span>(<span class="params">promises</span>) &#123;</span><br><span class="line"><span class="comment">// 返回结果为promise对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 声明一个计数变量</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 存放成功结果的数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">promises[i].<span class="title function_">then</span>(</span><br><span class="line"><span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 得知对象的状态是成功</span></span><br><span class="line"><span class="comment">// 当每个promise对象都成功再调用resolve</span></span><br><span class="line">count++;</span><br><span class="line"><span class="comment">// 将当前promise对象成功的结果存放到数组中</span></span><br><span class="line">arr[i] = v;</span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="keyword">if</span> (count === promises.<span class="property">length</span>) &#123;</span><br><span class="line"><span class="title function_">resolve</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">reject</span>(r);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加race方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">race</span>(<span class="params">promises</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">promises[i].<span class="title function_">then</span>(</span><br><span class="line"><span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(v);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">reject</span>(r);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、async-amp-await"><a href="#四、async-amp-await" class="headerlink" title="四、async&amp;await"></a>四、async&amp;await</h1><h2 id="4-1-async"><a href="#4-1-async" class="headerlink" title="4.1 async"></a>4.1 async</h2><ol><li>函数返回值为 promise 对象</li><li>promise 对象的结果由 async 函数执行的返回值决定</li></ol><p>和 then 方法的规则一致</p><ol><li>如果返回的是一个非 promise 类型的数据。返回 fulfilled+值</li><li>如果返回的是一个 promise 类型的数据，根据 promise 类型决定</li><li>如果抛出异常，返回 rejected+reason</li></ol><h2 id="4-2-await"><a href="#4-2-await" class="headerlink" title="4.2 await"></a>4.2 await</h2><ol><li>await 右侧的表达式一般为 promise 对象，但也可以是其他的值</li><li>如果表达式是 promise 对象，await 返回的是 promise 成功的值</li><li>如果表达式是其他的值，直接将此值作为 await 的返回值</li></ol><p><strong>注意事项</strong></p><ol><li>await 必须写在 async 函数中，但 async 函数中可以没有 await</li><li>如果 await 的 promise 失败了，就会抛出异常，需要通过 try…catch 捕获处理</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// resolve(&#x27;ok&#x27;);</span></span><br><span class="line"><span class="title function_">reject</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右侧为promise的情况</span></span><br><span class="line"><span class="comment">// let res = await p;</span></span><br><span class="line"><span class="comment">// 右侧为数据的情况</span></span><br><span class="line"><span class="comment">// let res2 = await 20;</span></span><br><span class="line"><span class="comment">// 如果promise是失败的情况</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">let</span> res3 = <span class="keyword">await</span> p;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>();</span><br></pre></td></tr></table></figure><h2 id="4-3-async-和-await-结合"><a href="#4-3-async-和-await-结合" class="headerlink" title="4.3 async 和 await 结合"></a>4.3 async 和 await 结合</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;发送ajax请求&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button id=&quot;btn&quot;&gt;点击获取段子&lt;/button&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // axios</span><br><span class="line">        function sendAjax(url)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let btn = document.querySelector(&#x27;btn&#x27;);</span><br><span class="line"></span><br><span class="line">        btn.addEventListener(&#x27;click&#x27;,async function()&#123;</span><br><span class="line">            let joke = await sendAjax(&#x27;https://api.apiopen.top/getJoke&#x27;);</span><br><span class="line">            console.log(joke);</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;p&gt;promise 是 js 中进行异步编程的&lt;strong&gt;新解决方案&lt;/strong&gt; 旧方案是使用单纯的回调函数&lt;/p&gt;
&lt;p&gt;promise 可以使回调函数的方式更加灵活 promise：启动异步任务 &amp;#x3D;&amp;gt; 返回 promise 对象 &amp;#x3D;&amp;gt; 给 promise 对象绑定回调函数（甚至可以在异步任务结束后指定&amp;#x2F;多个）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;promise 支持链式调用，可以解决回调地狱问题&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>AJAX详解</title>
    <link href="http://example.com/2022/07/07/Ajax%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/07/07/Ajax%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-07-07T01:49:01.000Z</published>
    <updated>2023-03-20T08:32:32.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-1-AJAX简介"><a href="#1-1-AJAX简介" class="headerlink" title="1.1 AJAX简介"></a>1.1 AJAX简介</h2><p>Ajax(Asynchronous JavaScript And XML)，就是异步的JS和XML</p><p>通过Ajax可以在浏览器中向服务器发送异步请求</p><p><strong>其最大的优势就是可以不刷新网页从而获取数据</strong></p><p>Ajax不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式</p><span id="more"></span><h2 id="1-2-XML简介"><a href="#1-2-XML简介" class="headerlink" title="1.2 XML简介"></a>1.2 XML简介</h2><p>XML是一种可扩展的标记语言</p><p>XML被设计用来传输和存储数据</p><p>XML和HTML类似，不同的是，html中都是预定义标签，而xml中没有预定义标签，都是自定义标签。</p><p><strong>但是现在已经被JSON取代了</strong></p><h2 id="1-3-AJAX特点"><a href="#1-3-AJAX特点" class="headerlink" title="1.3 AJAX特点"></a>1.3 AJAX特点</h2><h3 id="1-3-1-AJAX的优点"><a href="#1-3-1-AJAX的优点" class="headerlink" title="1.3.1 AJAX的优点"></a>1.3.1 AJAX的优点</h3><ol><li>可以无需刷新页面而与服务端进行通信</li><li>允许你根据用户事件来更新部分页面问题</li></ol><h3 id="1-3-2-AJAX的缺点"><a href="#1-3-2-AJAX的缺点" class="headerlink" title="1.3.2 AJAX的缺点"></a>1.3.2 AJAX的缺点</h3><ol><li>没有浏览历史，不能回退</li><li>存在跨域问题（同源）</li><li>SEO不友好，也就是搜索引擎优化，因为AJAX不能够被爬虫，网页源代码中找不到它，它是从服务器端的请求来的</li></ol><h2 id="1-4-http协议"><a href="#1-4-http协议" class="headerlink" title="1.4 http协议"></a>1.4 http协议</h2><p>http（hypertext transport protocol），超文本传输协议，协议详细规定了浏览器和万维网服务器之间的互相通信规则</p><h3 id="1-4-1-请求报文"><a href="#1-4-1-请求报文" class="headerlink" title="1.4.1 请求报文"></a>1.4.1 请求报文</h3><p>重点是格式与参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">行      POST /s?ie=ytf-8    HTTP/1.1</span><br><span class="line">头      Host: guigu.com</span><br><span class="line">        Cookie: name=guigu</span><br><span class="line">        Content-Type: application/x-www-form-urlencoded</span><br><span class="line">        User-Agent: chrome 83</span><br><span class="line">空行</span><br><span class="line">体      username=admin&amp;password=admin</span><br></pre></td></tr></table></figure><h3 id="1-4-2-响应报文"><a href="#1-4-2-响应报文" class="headerlink" title="1.4.2 响应报文"></a>1.4.2 响应报文</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">行      HTTP/1.1 200 OK</span><br><span class="line">头      Content-Type:text/html;charset=utff-8</span><br><span class="line">        Content-length:2048</span><br><span class="line">        Content-encoding:gzip</span><br><span class="line">空行</span><br><span class="line">体      html结构</span><br></pre></td></tr></table></figure><h3 id="1-4-3-查看请求报文和响应报文"><a href="#1-4-3-查看请求报文和响应报文" class="headerlink" title="1.4.3 查看请求报文和响应报文"></a>1.4.3 查看请求报文和响应报文</h3><p>f12 –&gt; network –&gt; Headers Request Headers：请求头 Response Headers:响应头 Query String Parameters:查询字符串参数，对参数进行可视化，具体的可视化区域是utf-8区域的参数，也就是<strong>请求行的内容</strong></p><p>f12 –&gt; network –&gt; Response:看具体的响应体</p><p>对于post请求，会通过Form Data来将用户名和密码传送给服务器</p><h3 id="1-4-4-get-x2F-post"><a href="#1-4-4-get-x2F-post" class="headerlink" title="1.4.4 get&#x2F;post"></a>1.4.4 get&#x2F;post</h3><p>GET一般用于获取&#x2F;查询资源信息，而POST一般用于更新资源信息.</p><h4 id="1-4-4-1-GET"><a href="#1-4-4-1-GET" class="headerlink" title="1.4.4.1 GET"></a>1.4.4.1 GET</h4><p>当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是GET方式。 GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。</p><p>使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号(“?”)代表URL的结尾与请求参数的开始，传递参数长度受限制。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例如，/index.jsp?id=100&amp;op=bind,这样通过GET方式传递的参数直接表示在地址中</span><br><span class="line"></span><br><span class="line">以用google搜索domety为例，Request报文如下：</span><br><span class="line"></span><br><span class="line">GET /search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq= HTTP/1.1</span><br><span class="line">Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint,</span><br><span class="line">application/msword, application/x-silverlight, application/x-shockwave-flash, */*</span><br><span class="line">Referer: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.google.cn/&quot;</span>&gt;</span>http://www.google.cn/<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">Accept-Language: zh-cn</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)</span><br><span class="line">Host: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.google.cn&quot;</span>&gt;</span>www.google.cn<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-FxlRugatx63JLv7CWMD6UB_O_r</span><br></pre></td></tr></table></figure><p>可以看到，GET方式的请求一般不包含”请求内容”部分，请求数据以地址的形式表现在请求行。地址链接如下： <code>&lt;a href=&quot;http://www.google.cn/search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq=&quot;&gt;http://www.google.cn/search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq=&lt;/a&gt;</code></p><p>地址中”?”之后的部分就是<strong>通过GET发送的请求数据</strong>，在地址栏中可以看到，各个数据之间用”&amp;”符号隔开。 <strong>很显然，这种方式不适合传送私密数据。</strong> 另外，由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别1024个字符，所以如果需要传送大量数据的时候，也不适合使用GET方式。</p><h4 id="1-4-4-2-POST"><a href="#1-4-4-2-POST" class="headerlink" title="1.4.4.2 POST"></a>1.4.4.2 POST</h4><p>对于上面提到的不适合使用GET方式的情况，可以考虑使用POST方式，因为使用POST方法可以允许客户端给服务器提供信息较多。POST方法将请求参数封装在HTTP请求数据中，以名称&#x2F;值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。还以上面的搜索domety为例，如果使用POST方式的话，格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /search HTTP/1.1 </span><br><span class="line">Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, </span><br><span class="line">application/msword, application/x-silverlight, application/x-shockwave-flash, */* </span><br><span class="line">Referer: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.google.cn/&quot;</span>&gt;</span>http://www.google.cn/<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line">Accept-Language: zh-cn </span><br><span class="line">Accept-Encoding: gzip, deflate </span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld) </span><br><span class="line">Host: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.google.cn&quot;</span>&gt;</span>www.google.cn<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line">Connection: Keep-Alive </span><br><span class="line">Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-FxlRugatx63JLv7CWMD6UB_O_r</span><br><span class="line"></span><br><span class="line">hl=zh-CN&amp;source=hp&amp;q=domety</span><br></pre></td></tr></table></figure><p>可以看到，POST方式请求行中不包含数据字符串，这些数据保存在”请求内容”部分，各数据之间也是使用”&amp;”符号隔开。 POST方式大多用于页面的表单中。因为POST也能完成GET的功能，因此多数人在设计表单的时候一律都使用POST方式，其实这是一个误区。 GET方式也有自己的特点和优势，我们应该根据不同的情况来选择是使用GET还是使用POST。</p><h4 id="1-4-4-3-HEAD"><a href="#1-4-4-3-HEAD" class="headerlink" title="1.4.4.3 HEAD"></a>1.4.4.3 HEAD</h4><p>HEAD就像GET，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。</p><h4 id="1-4-4-4-get和post的区别"><a href="#1-4-4-4-get和post的区别" class="headerlink" title="1.4.4.4 get和post的区别"></a>1.4.4.4 get和post的区别</h4><p>我们看看GET和POST的区别</p><ol><li><p>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name&#x3D;test1&amp;id&#x3D;123456. POST方法是把提交的数据放在HTTP包的Body中.</p></li><li><p>GET提交的数据大小有限制(因为浏览器对URL的长度有限制)，而POST方法提交的数据没有限制.</p></li><li><p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p></li><li><p>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p></li></ol><p><strong>HTTP请求数据</strong> [<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/request.jpg">] <strong>HTTP响应数据</strong> [<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/response.png">]</p><h1 id="二-AJAX的使用"><a href="#二-AJAX的使用" class="headerlink" title="二 AJAX的使用"></a>二 AJAX的使用</h1><h2 id="2-1-get请求"><a href="#2-1-get请求" class="headerlink" title="2.1 get请求"></a>2.1 get请求</h2><ol><li><p>创建对象<br>这里用xhr的原因就是使用ajax一般都要通过xhr来，所以说xhr代表的就是ajax<br><code>const xhr = new XMLHttpRequest();</code></p></li><li><p>初始化，设置请求方法和url<br><code>xhr.open(&quot;GET&quot;, &quot;http://127.0.0.1:8000/server&quot;);</code><br>请求方法包括GET&#x2F;POST&#x2F;DELETE等<br>对于url的设置是以?分割，用&amp;表示不同参数。 <code>xhr.open(&quot;GET&quot;, &quot;http://127.0.0.1:8000/server?a=100&amp;b=200&amp;c=300&quot;);</code></p></li><li><p>发送 <code>xhr.send();</code> 4.事件绑定 处理服务端返回的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// on表示当。。。时候</span></span><br><span class="line"><span class="comment">// readystate是xhr对象中的属性。表示状态0,1,2,3,4</span></span><br><span class="line"><span class="comment">// 0表示被初始化，1代表open方法加装完毕</span></span><br><span class="line"><span class="comment">// 2代表send方法加装完毕，3表示服务端返回的部分结果，4表示服务端返回的所有结果</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 判断(服务端返回了所有的结果)</span></span><br><span class="line">    <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="comment">// 判断响应状态码 200、404、403、401、500等</span></span><br><span class="line">        <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt;= <span class="number">300</span>)&#123;</span><br><span class="line">            <span class="comment">// 处理结果 行 头 空行 体</span></span><br><span class="line">            <span class="comment">// 响应</span></span><br><span class="line">            <span class="comment">// console.log(xhr.status);//状态码</span></span><br><span class="line">            <span class="comment">// console.log(xhr.statusText);//状态字符串</span></span><br><span class="line">            <span class="comment">// console.log(xhr.getAllResponseHeaders());//所有响应头</span></span><br><span class="line">            <span class="comment">// console.log(xhr.response);//响应体</span></span><br><span class="line">            result.<span class="property">innerHTML</span> = xhr.<span class="property">response</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-2-post请求"><a href="#2-2-post请求" class="headerlink" title="2.2 post请求"></a>2.2 post请求</h2><p>post请求中主要就是请求体的位置不一样 在get方法中，数据是通过url传输的，这样就比较不安全 但是在post方法中，通过<code>send()</code>方法传输，数据的传输更安全可靠</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>AJAX POST 请求<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#result</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: solid <span class="number">1px</span> <span class="number">#90b</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取元素</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> result = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;result&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 绑定事件</span></span></span><br><span class="line"><span class="language-javascript">        result.<span class="title function_">addEventListener</span>(<span class="string">&quot;mouseover&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 1.创建对象</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 2.初始化</span></span></span><br><span class="line"><span class="language-javascript">            xhr.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&#x27;http://127.0.0.1:8000/server&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 3.发送</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// xhr.send(&#x27;a=100&amp;b=200&amp;c=300&#x27;);</span></span></span><br><span class="line"><span class="language-javascript">            xhr.<span class="title function_">send</span>(<span class="string">&#x27;a:100&amp;b:200&amp;c:300&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 4.事件绑定</span></span></span><br><span class="line"><span class="language-javascript">            xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;=<span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span>&lt;= <span class="number">300</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                        result.<span class="property">innerHTML</span> = xhr.<span class="property">response</span>;</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-3-express框架使用"><a href="#2-3-express框架使用" class="headerlink" title="2.3 express框架使用"></a>2.3 express框架使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.创建路由规则</span></span><br><span class="line"><span class="comment">// request是对请求报文的封装</span></span><br><span class="line"><span class="comment">// response是对响应报文的封装</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 设置响应头,设置允许跨域</span></span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="comment">// 设置响应体</span></span><br><span class="line">    response.<span class="title function_">send</span>(<span class="string">&quot;hello ajax&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 设置响应头,设置允许跨域</span></span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="comment">// 设置响应体</span></span><br><span class="line">    response.<span class="title function_">send</span>(<span class="string">&quot;hello ajax post&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.监听端口启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务已经启动，8000端口监听中......&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2-4-json请求"><a href="#2-4-json请求" class="headerlink" title="2.4 json请求"></a>2.4 json请求</h2><p>json请求和其他的区别不是很大，其主要改变就是在server端要想要对数据进行响应，需要对数据进行转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/json-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 设置响应头,设置允许跨域</span></span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="comment">// 响应一个数据</span></span><br><span class="line">    <span class="keyword">const</span> data = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;wh&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 对对象进行字符串转换</span></span><br><span class="line">    <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">    <span class="comment">// 设置响应体</span></span><br><span class="line">    response.<span class="title function_">send</span>(str);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>之后在前端，可以通过两种方式来进行数据的显示：</p><ol><li><p>手动对数据进行转化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">response</span>);</span><br><span class="line">result.<span class="property">innerHTML</span> = data.<span class="property">name</span>;</span><br></pre></td></tr></table></figure><p>2.自动对数据进行转化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">// 设置响应体的类型</span></span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&#x27;json&#x27;</span>;</span><br><span class="line"><span class="comment">// 之后在事件绑定中，就可以直接进行显示</span></span><br><span class="line">result.<span class="property">innerHTML</span> = xhr.<span class="property">response</span>.<span class="property">name</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-5-神奇的IE"><a href="#2-5-神奇的IE" class="headerlink" title="2.5 神奇的IE"></a>2.5 神奇的IE</h2><p>IE浏览器在使用ajax过程中会出现缓存问题，当然ie现在已经die了。 但是还是得提一下 其实结果办法也比较简单，就是在前端的初始化阶段设置一个参数时间 <code>xhr.open(&quot;GET&quot;, &#39;https://127.0.0.1:8000/ie?t=&#39;Date.now());</code></p><h2 id="2-6-请求超时与网络异常"><a href="#2-6-请求超时与网络异常" class="headerlink" title="2.6 请求超时与网络异常"></a>2.6 请求超时与网络异常</h2><p>在<code>const xhr = new XMLHttpRequest();</code>和<code>xhr.open(&#39;GET&#39;, &#39;http://127.0.0.1:8000/delay&#39;);</code>之间添加内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置超时取消</span></span><br><span class="line">xhr.<span class="property">timeout</span> = <span class="number">2000</span>;</span><br><span class="line">xhr.<span class="property">ontimeout</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;net error,please try again later&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;your net maybe have some problems&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-7-请求取消的问题"><a href="#2-7-请求取消的问题" class="headerlink" title="2.7 请求取消的问题"></a>2.7 请求取消的问题</h2><p>取消请求可以使用<code>abort()</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="literal">null</span>;</span><br><span class="line">btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    x = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    x.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;http://127.0.0.1:8000&#x27;</span>);</span><br><span class="line">    x.<span class="title function_">send</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    x.<span class="title function_">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过这种方法就可以当点击一个按钮发送请求时，点击另一个按钮就可以取消这个请求</span></span><br></pre></td></tr></table></figure><h2 id="2-8-请求重复的问题"><a href="#2-8-请求重复的问题" class="headerlink" title="2.8 请求重复的问题"></a>2.8 请求重复的问题</h2><p>请求重复问题的核心就是创建一个标识变量，如果这个标识变量为true，则证明请求过程还未结束，不能够接受新的请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;button&quot;</span>)[<span class="number">0</span>]; </span><br><span class="line">        <span class="keyword">let</span> x = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 创建标识变量</span></span><br><span class="line">        <span class="keyword">let</span> isSending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isSending) x.<span class="title function_">abort</span>();</span><br><span class="line">            x = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">            isSending = <span class="literal">true</span>;</span><br><span class="line">            x.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;http://127.0.0.1:8000/delay&#x27;</span>);</span><br><span class="line">            x.<span class="title function_">send</span>();</span><br><span class="line">            x.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">                    <span class="comment">// 修改标识变量</span></span><br><span class="line">                    isSending = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="三、同源策略"><a href="#三、同源策略" class="headerlink" title="三、同源策略"></a>三、同源策略</h1><p>同源策略是一种浏览器的安全策略</p><p>同源：协议、域名、端口号必须完全相同</p><p>违背同源策略就是跨域</p><h2 id="3-1-JSONP"><a href="#3-1-JSONP" class="headerlink" title="3.1 JSONP"></a>3.1 JSONP</h2><p>JSONP是一种非官方的跨域解决方案，只支持GET请求 其利用script标签的跨域能力来发送请求</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params">data</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> result = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            result.<span class="property">innerHTML</span> = data.<span class="property">name</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://127.0.0.1:8000/jsonp-server&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从上面的代码中可以看出，script标签可以通过src链接来实现跨域通信，但是其服务器端回传的必须是一段script代码 比如说想要回传一个参数，可以把参数的显示函数等放在前端，然后服务器端通过调用这个函数就可以啦。 因为其实回传过来的是一段script代码，所以说前端会执行这些前端代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/jsonp-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 响应一个页面</span></span><br><span class="line">    <span class="comment">// response.send(&#x27;console.log(&quot;hello jsonp server&quot;)&#x27;);</span></span><br><span class="line">    <span class="keyword">const</span> data = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;wh&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="string">&#x27;18&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">    response.<span class="title function_">send</span>(<span class="string">`handle(<span class="subst">$&#123;str&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然想要回传参数，需要先将参数转换为json</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建script 标签</span></span><br><span class="line"><span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line"><span class="comment">// 2.设置标签的src属性</span></span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;http://127.0.0.1:8000/check-server&#x27;</span>;</span><br><span class="line"><span class="comment">// 3.将script插入到文档中</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure><p>在正常使用过程中，需要创建script标签，并将其置入src，之后再将script标签插入到文档中使用</p><h2 id="3-2-CORS"><a href="#3-2-CORS" class="headerlink" title="3.2 CORS"></a>3.2 CORS</h2><p>cors(cross-origin resource sharing)，跨域资源共享 是官方的跨域解决方案。它的特点是不需要在客户端做任何特殊的操作。 完全在服务器中进行处理。并且支持get和post请求。 跨域资源共享标准新增了一组HTTP首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源</p><p><strong>CORS通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应后就会对响应放行</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置响应头</span></span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>); <span class="comment">//这个就代表可以跨域运行，并且对所有网页都可以进行</span></span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://example.com&#x27;</span>); <span class="comment">//表示对某个网页进行跨域</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般在开发时会加这些东西</span></span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Method&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br></pre></td></tr></table></figure><p>具体的标准和响应头可以看<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">CORS</a></p><h1 id="四、使用ajax"><a href="#四、使用ajax" class="headerlink" title="四、使用ajax"></a>四、使用ajax</h1><p>本文中使用的主要为express框架，基于node.js和npm、nodemon包使用</p><p>开启服务端的操作为：  </p><p><code>nodemon server.js</code> ——————这个操作能够动态更新服务端代码  </p><p><code>node server.js</code> ——————这个操作每次更新服务端代码都需要重启服务  </p><p>nodemon的下载操作为： <code>npm install -g nodemon</code></p><p><strong>因为新版的node.js中内置了npm，所以不用再下载npm包了</strong></p><p>npm是node.js的一个包管理工具</p><p>查询npm是否下载完成的方式为：<code>npm -v</code> 查询node.js是否下载成功的方式为：<code>node -v</code></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;h2 id=&quot;1-1-AJAX简介&quot;&gt;&lt;a href=&quot;#1-1-AJAX简介&quot; class=&quot;headerlink&quot; title=&quot;1.1 AJAX简介&quot;&gt;&lt;/a&gt;1.1 AJAX简介&lt;/h2&gt;&lt;p&gt;Ajax(Asynchronous JavaScript And XML)，就是异步的JS和XML&lt;/p&gt;
&lt;p&gt;通过Ajax可以在浏览器中向服务器发送异步请求&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其最大的优势就是可以不刷新网页从而获取数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ajax不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式&lt;/p&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>网页的生命周期和cookie</title>
    <link href="http://example.com/2022/07/03/%E7%BD%91%E9%A1%B5%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8Ccookie/"/>
    <id>http://example.com/2022/07/03/%E7%BD%91%E9%A1%B5%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8Ccookie/</id>
    <published>2022-07-03T15:15:33.000Z</published>
    <updated>2023-03-20T08:32:39.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、页面的生命周期"><a href="#一、页面的生命周期" class="headerlink" title="一、页面的生命周期"></a>一、页面的生命周期</h1><p>HTML 页面的生命周期包含三个重要事件：</p><ul><li>DOMContentLoaded —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像<code>&lt;img&gt;</code>和样式表之类的外部资源可能尚未加载完成。</li><li>load —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。</li><li>beforeunload&#x2F;unload —— 当用户正在离开页面时。</li></ul><p>每个事件都是有用的：</p><ul><li>DOMContentLoaded 事件 —— DOM 已经就绪，因此处理程序可以查找 DOM 节点，并初始化接口。</li><li>load 事件 —— 外部资源已加载完成，样式已被应用，图片大小也已知了。</li><li>beforeunload 事件 —— 用户正在离开：我们可以检查用户是否保存了更改，并询问他是否真的要离开。</li><li>unload 事件 —— 用户几乎已经离开了，但是我们仍然可以启动一些操作，例如发送统计数据。</li></ul><h2 id="1-1-DOMContentLoaded"><a href="#1-1-DOMContentLoaded" class="headerlink" title="1.1 DOMContentLoaded"></a>1.1 DOMContentLoaded</h2><p><code>DOMContentLoaded</code>事件发生在<code>document</code>对象上。</p><p>我们必须使用<code>addEventListener</code>来捕获它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, ready);</span><br><span class="line"><span class="comment">// 不是 &quot;document.onDOMContentLoaded = ...&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">ready</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&#x27;DOM is ready&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 图片目前尚未加载完成（除非已经被缓存），所以图片的大小为 0x0</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">`Image size: <span class="subst">$&#123;img.offsetWidth&#125;</span>x<span class="subst">$&#123;img.offsetHeight&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, ready);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://en.js.cx/clipart/train.gif?speed=1&amp;cache=0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为DOMContentLoaded会在文档加载完成后触发，所以它可以查看所有元素，包括<code>&lt;img&gt;</code>等元素，但是不会等待图片加载，所以图片大小是0。</p><p>当浏览器处理一个 HTML 文档，并在文档中遇到<code>&lt;script&gt;</code>标签时，就会在继续构建 DOM 之前运行它。这是一种防范措施，因为脚本可能想要修改 DOM，甚至对其执行 <code>document.write</code>操作，所以<code>DOMContentLoaded</code>必须等待脚本执行结束。</p><p>此规则有两个例外：</p><ol><li>具有<code>async</code>特性（attribute）的脚本不会阻塞<code>DOMContentLoaded</code>，稍后我们会讲到。</li><li>使用<code>document.createElement(&#39;script&#39;)</code>动态生成并添加到网页的脚本也不会阻塞<code>DOMContentLoaded</code>。</li></ol><p><strong>外部样式表不会影响DOM，因此<code>DOMContentLoaded</code>不会等待它们。</strong></p><p>但这里有一个陷阱。如果在样式后面有一个脚本，那么该脚本必须等待样式表加载完成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 在样式表加载完成之前，脚本都不会执行</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(<span class="title function_">getComputedStyle</span>(<span class="variable language_">document</span>.<span class="property">body</span>).<span class="property">marginTop</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>原因是，脚本可能想要获取元素的坐标和其他与样式相关的属性，如上例所示。因此，它必须等待样式加载完成。</p><p><strong>当<code>DOMContentLoaded</code>等待脚本时，它现在也在等待脚本前面的样式。所以说虽然外部样式表不会影响DOM，但是如果外部样式表后存在script脚本， <code>DOMContentLoaded</code>也会等待样式表加载完成</strong></p><h2 id="1-2-浏览器的自动填充"><a href="#1-2-浏览器的自动填充" class="headerlink" title="1.2 浏览器的自动填充"></a>1.2 浏览器的自动填充</h2><p>Firefox，Chrome 和 Opera 都会在<code>DOMContentLoaded</code>中自动填充表单。</p><p>例如，如果页面有一个带有登录名和密码的表单，并且浏览器记住了这些值，那么在 <code>DOMContentLoaded</code>上，浏览器会尝试自动填充它们（如果得到了用户允许）。</p><p>因此，如果<code>DOMContentLoaded</code>被需要加载很长时间的脚本延迟触发，那么自动填充也会等待。你可能在某些网站上看到过（如果你使用浏览器自动填充）—— 登录名&#x2F;密码字段不会立即自动填充，而是在页面被完全加载前会延迟填充。这实际上是 <code>DOMContentLoaded</code>事件之前的延迟。</p><h2 id="1-3-window-onload"><a href="#1-3-window-onload" class="headerlink" title="1.3 window.onload"></a>1.3 window.onload</h2><p>当<strong>整个页面，包括样式、图片和其他资源被加载完成时</strong>，会触发window对象上的<code>load</code>事件。可以通过<code>onload</code>属性获取此事件。</p><p>下面的这个示例正确显示了图片大小，因为<code>window.onload</code>会等待所有图片加载完毕：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 也可以用 window.addEventListener(&#x27;load&#x27;, (event) =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&#x27;Page loaded&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 此时图片已经加载完成</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">`Image size: <span class="subst">$&#123;img.offsetWidth&#125;</span>x<span class="subst">$&#123;img.offsetHeight&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://en.js.cx/clipart/train.gif?speed=1&amp;cache=0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-3-window-onunload"><a href="#1-3-window-onunload" class="headerlink" title="1.3 window.onunload"></a>1.3 window.onunload</h2><p>当访问者离开页面时，window对象上的<code>unload</code>事件就会被触发。我们可以在那里做一些不涉及延迟的操作，例如关闭相关的弹出窗口。 有一个值得注意的特殊情况是发送分析数据。 假设我们收集有关页面使用情况的数据：鼠标点击，滚动，被查看的页面区域等。 自然地，当用户要离开的时候，我们希望通过<code>unload</code>事件将数据保存到我们的服务器上。 有一个特殊的<code>navigator.sendBeacon(url, data)</code>方法可以满足这种需求，<a href="https://w3c.github.io/beacon/">详见规范</a>。 它在后台发送数据，转换到另外一个页面不会有延迟：浏览器离开页面，但仍然在执行<code>sendBeacon</code>。 使用方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> analyticsData = &#123; <span class="comment">/* 带有收集的数据的对象 */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;unload&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  navigator.<span class="title function_">sendBeacon</span>(<span class="string">&quot;/analytics&quot;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(analyticsData));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>请求以 POST 方式发送。</li><li>我们不仅能发送字符串，还能发送表单以及其他格式的数据，但通常它是一个字符串化的对象。</li><li>数据大小限制在 64kb。</li></ul><p>当<code>sendBeacon</code>请求完成时，浏览器可能已经离开了文档，所以就无法获取服务器响应（对于分析数据来说通常为空）。 还有一个<code>keep-alive</code>标志，该标志用于在<code>fetch</code>方法中为通用的网络请求执行此类“离开页面后”的请求。 如果我们要取消跳转到另一页面的操作，在这里做不到。但是我们可以使用另一个事件 ——<code>onbeforeunload</code>。</p><h2 id="1-4-window-onbeforeunload"><a href="#1-4-window-onbeforeunload" class="headerlink" title="1.4 window.onbeforeunload"></a>1.4 window.onbeforeunload</h2><p>如果访问者触发了离开页面的导航（navigation）或试图关闭窗口，<code>beforeunload</code>处理程序将要求进行更多确认。 如果我们要取消事件，浏览器会询问用户是否确定。 你可以通过运行下面这段代码，然后重新加载页面来进行尝试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onbeforeunload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为有些站长通过显示误导性和恶意信息滥用了此事件处理程序。所以，目前一些旧的浏览器可能仍将其显示为消息，但除此之外 —— 无法自定义显示给用户的消息。</p><p><code>event.preventDefault()</code>在<code>beforeunload</code>处理程序中不起作用 这听起来可能很奇怪，但大多数浏览器都会忽略<code>event.preventDefault()</code>。 以下代码可能不起作用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;beforeunload&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 不起作用，所以这个事件处理程序没做任何事儿</span></span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>相反，在这样的处理程序中，应该将<code>event.returnValue</code>设置为一个字符串，以获得类似于上面代码的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;beforeunload&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 起作用，与在 window.onbeforeunload 中 return 值的效果是一样的</span></span><br><span class="line">  event.<span class="property">returnValue</span> = <span class="string">&quot;有未保存的值。确认要离开吗？&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="1-5-readyState"><a href="#1-5-readyState" class="headerlink" title="1.5 readyState"></a>1.5 readyState</h2><p>如果我们在文档加载完成之后设置<code>DOMContentLoaded</code>事件处理程序，会发生什么？ 很自然地，它永远不会运行。 在某些情况下，我们不确定文档是否已经准备就绪。我们希望我们的函数在 DOM 加载完成时执行，无论现在还是以后。</p><p><code>document.readyState</code>属性可以为我们提供当前加载状态的信息。</p><p>它有 3 个可能值：</p><ul><li><code>loading</code> —— 文档正在被加载。</li><li><code>interactive</code> —— 文档被全部读取。</li><li><code>complete</code> —— 文档被全部读取，并且所有资源（例如图片等）都已加载完成。</li></ul><p>所以，我们可以检查<code>document.readyState</code>并设置一个处理程序，或在代码准备就绪时立即执行它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">work</span>(<span class="params"></span>) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">readyState</span> == <span class="string">&#x27;loading&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// 仍在加载，等待事件</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, work);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// DOM 已就绪！</span></span><br><span class="line">  <span class="title function_">work</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个<code>readystatechange</code>事件，会在状态发生改变时触发，因此我们可以打印所有这些状态，就像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前状态</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">readyState</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态改变时打印它</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;readystatechange&#x27;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">readyState</span>));</span><br></pre></td></tr></table></figure><p><code>readystatechange</code>事件是跟踪文档加载状态的另一种机制，它很早就存在了。现在则很少被使用。</p><p>在<code>DOMContentLoaded</code>之前，<code>document.readyState</code>会立即变成<code>interactive</code>。它们俩的意义实际上是相同的。 当所有资源（iframe 和 img）都加载完成后，<code>document.readyState</code>变成 complete。这里我们可以发现，它与<code>img.onload</code>（img 是最后一个资源）和 <code>window.onload</code>几乎同时发生。转换到 complete 状态的意义与<code>window.onload</code>相同。区别在于<code>window.onload</code>始终在所有其他 load 处理程序之后运行。</p><h1 id="二、脚本：async，defer"><a href="#二、脚本：async，defer" class="headerlink" title="二、脚本：async，defer"></a>二、脚本：async，defer</h1><p>现代的网站中，脚本往往比 HTML 更“重”：它们的大小通常更大，处理时间也更长。</p><p>当浏览器加载 HTML 时遇到<code>&lt;script&gt;...&lt;/script&gt;</code>标签，浏览器就不能继续构建 DOM。它必须立刻执行此脚本。对于外部脚本<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code>也是一样的：浏览器必须等脚本下载完，并执行结束，之后才能继续处理剩余的页面。</p><p>这会导致两个重要的问题：</p><ol><li>脚本不能访问到位于它们下面的 DOM 元素，因此，脚本无法给它们添加处理程序等。</li><li>如果页面顶部有一个笨重的脚本，它会“阻塞页面”。在该脚本下载并执行结束前，用户都不能看到页面内容。</li></ol><p>这里有一些解决办法。例如，我们可以把脚本放在页面底部。此时，它可以访问到它上面的元素，并且不会阻塞页面显示内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  ...all content is above the script...</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://javascript.info/article/script-async-defer/long.js?speed=1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是这种解决方案远非完美。例如，浏览器只有在下载了完整的 HTML 文档之后才会注意到该脚本（并且可以开始下载它）。对于长的 HTML 文档来说，这样可能会造成明显的延迟。</p><p>这对于使用高速连接的人来说，这不值一提，他们不会感受到这种延迟。但是这个世界上仍然有很多地区的人们所使用的网络速度很慢，并且使用的是远非完美的移动互联网连接。</p><p>幸运的是，这里有两个<code>&lt;script&gt;</code>特性（attribute）可以为我们解决这个问题：defer 和 async。</p><h2 id="2-1-defer"><a href="#2-1-defer" class="headerlink" title="2.1 defer"></a>2.1 defer</h2><p><code>defer</code>特性告诉浏览器不要等待脚本。相反，浏览器将继续处理 HTML，构建 DOM。脚本会“在后台”下载，然后等 DOM 构建完成后，脚本才会执行。</p><p>这是与上面那个相同的示例，但是带有 defer 特性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>...content before script...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;https://javascript.info/article/script-async-defer/long.js?speed=1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 立即可见 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>...content after script...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以说：</p><ul><li>具有<code>defer</code>特性的脚本不会阻塞页面。</li><li>具有<code>defer</code>特性的脚本总是要等到 DOM 解析完毕，但在<code>DOMContentLoaded</code>事件之前执行。</li></ul><p>因为具有<code>defer</code>特性的脚本不会被等待，但是<code>DOMContentLoaded</code>事件必须等到脚本结束才能进行。</p><p><strong>具有<code>defer</code>特性的脚本保持其相对顺序，就像常规脚本一样。</strong></p><p>浏览器扫描页面寻找脚本，然后并行下载它们，以提高性能。</p><p>如果有两个脚本，一个大一个小，大脚本在前，小脚本在后。但是如果小脚本先被下载完成，但是因为执行的相对顺序，它会排在大脚本后面被执行。</p><p>当我们需要先加载 JavaScript 库，然后再加载依赖于它的脚本时，这可能会很有用。</p><p><strong><code>defer</code>特性仅适用于外部脚本。如果<code>&lt;script&gt;</code>脚本没有 src，则会忽略<code>defer</code>特性。</strong></p><h2 id="2-2-async"><a href="#2-2-async" class="headerlink" title="2.2 async"></a>2.2 async</h2><p><code>async</code>特性与<code>defer</code>有些类似。它也能够让脚本不阻塞页面。但是，在行为上二者有着重要的区别。</p><p><code>async</code>特性意味着脚本是完全独立的：</p><ul><li>浏览器不会因<code>async</code>脚本而阻塞（与<code>defer</code>类似）。</li><li>其他脚本不会等待<code>async</code>脚本加载完成，同样，<code>async</code>脚本也不会等待其他脚本。</li><li><code>DOMContentLoaded</code>和异步脚本不会彼此等待：<ul><li><code>DOMContentLoaded</code>可能会发生在异步脚本之前（如果异步脚本在页面完成后才加载完成）</li><li><code>DOMContentLoaded</code>也可能发生在异步脚本之后（如果异步脚本很短，或者是从 HTTP 缓存中加载的）</li></ul></li></ul><p>换句话说，<code>async</code>脚本会在后台加载，并在加载就绪时运行。DOM 和其他脚本不会等待它们，它们也不会等待其它的东西。<code>async</code>脚本就是一个会在加载完成时执行的完全独立的脚本。</p><ul><li>页面内容立刻显示出来：加载写有 async 的脚本不会阻塞页面渲染。</li><li><code>DOMContentLoaded</code>可能在<code>async</code>之前或之后触发，不能保证谁先谁后。</li><li>较小的脚本 small.js 排在第二位，但可能会比 long.js 这个长脚本先加载完成，所以 small.js 会先执行。虽然，可能是 long.js 先加载完成，如果它被缓存了的话，那么它就会先执行。换句话说，<strong>异步脚本以“加载优先”的顺序执行</strong>。</li></ul><p>当我们将独立的第三方脚本集成到页面时，此时采用异步加载方式是非常棒的：计数器，广告等，因为它们不依赖于我们的脚本，我们的脚本也不应该等待它们：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">&quot;https://google-analytics.com/analytics.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong><code>async</code>特性仅适用于外部脚本。如果<code>&lt;script&gt;</code>脚本没有 src，则会忽略<code>async</code>特性。</strong></p><h2 id="2-3-动态脚本"><a href="#2-3-动态脚本" class="headerlink" title="2.3 动态脚本"></a>2.3 动态脚本</h2><p>此外，还有一种向页面添加脚本的重要的方式。</p><p>我们可以使用 JavaScript 动态地创建一个脚本，并将其附加（append）到文档（document）中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;/article/script-async-defer/long.js&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(script); <span class="comment">// (*)</span></span><br></pre></td></tr></table></figure><p>当脚本被附加到文档 (*) 时，脚本就会立即开始加载。</p><p><strong>默认情况下，动态脚本的行为是“异步”的。</strong></p><p>如果我们显式地设置了<code>script.async=false</code>，则可以改变这个规则。然后脚本将按照脚本在文档中的顺序执行，就像<code>defer</code>那样。</p><h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h2><p>所以说<code>defer</code>是以文档顺序进行解析，而<code>async</code>则是按照加载优先顺序进行解析 <code>defer</code>更适合需要整个DOM的脚本，而<code>async</code>则更合适用于独立脚本</p><p>请注意：如果你使用的是<code>defer</code>或<code>async</code>，那么用户将在脚本加载完成之前先看到页面。 在这种情况下，某些图形组件可能尚未初始化完成。 因此，请记得添加一个“正在加载”的提示，并禁用尚不可用的按钮。以让用户可以清楚地看到，他现在可以在页面上做什么，以及还有什么是正在准备中的。</p><h1 id="三、资源加载"><a href="#三、资源加载" class="headerlink" title="三、资源加载"></a>三、资源加载</h1><p>浏览器允许我们跟踪外部资源的加载 —— 脚本，iframe，图片等。</p><p>这里有两个事件：</p><ul><li>onload —— 成功加载</li><li>onerror —— 出现error</li></ul><p>假设我们需要加载第三方脚本，并调用其中的函数。 我们可以像这样动态加载它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;my.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">append</span>(script);</span><br></pre></td></tr></table></figure><p>……但如何运行在该脚本中声明的函数？我们需要等到该脚本加载完成，之后才能调用它。</p><h2 id="3-1-script-onload-x2F-onerror"><a href="#3-1-script-onload-x2F-onerror" class="headerlink" title="3.1 script.onload&#x2F;onerror"></a>3.1 script.onload&#x2F;onerror</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以从任意域（domain），加载任意脚本</span></span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">append</span>(script);</span><br><span class="line"></span><br><span class="line">script.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 该脚本创建了一个变量 &quot;_&quot;</span></span><br><span class="line">  <span class="title function_">alert</span>( _.<span class="property">VERSION</span> ); <span class="comment">// 显示库的版本</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过onload事件，可以在脚本加载完成后，通过函数来运行脚本中的变量和函数等。</p><p>如果出现错误（比如error 404 或者服务器宕机等），则会被onerror追踪到。</p><p>例如，我们请求一个不存在的脚本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;https://example.com/404.js&quot;</span>; <span class="comment">// 没有这个脚本</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">append</span>(script);</span><br><span class="line"></span><br><span class="line">script.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;Error loading &quot;</span> + <span class="variable language_">this</span>.<span class="property">src</span>); <span class="comment">// Error loading https://example.com/404.js</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>onload&#x2F;onerror 事件仅跟踪加载本身。</strong> 在脚本处理和执行期间可能发生的error超出了这些事件跟踪的范围。也就是说：如果脚本成功加载，则即使脚本中有编程error，也会触发onload事件。如果要跟踪脚本error，可以使用<code>window.onerror</code>全局处理程序。</p><h2 id="3-2-其他资源"><a href="#3-2-其他资源" class="headerlink" title="3.2 其他资源"></a>3.2 其他资源</h2><p><code>load</code>和<code>error</code>事件也适用于其他资源，基本上（basically）适用于具有外部 src 的任何资源。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;https://js.cx/clipart/train.gif&quot;</span>; <span class="comment">// (*)</span></span><br><span class="line"></span><br><span class="line">img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">`Image loaded, size <span class="subst">$&#123;img.width&#125;</span>x<span class="subst">$&#123;img.height&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">img.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;Error occurred while loading image&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>大多数资源在被添加到文档中后，便开始加载。但是<code>&lt;img&gt;</code>是个例外。它要等到获得<code>src (*)</code>后才开始加载。</li><li>对于<code>&lt;iframe&gt;</code>来说，iframe加载完成时会触发<code>iframe.onload</code>事件，无论是成功加载还是出现error。</li></ul><h2 id="3-3-跨源策略"><a href="#3-3-跨源策略" class="headerlink" title="3.3 跨源策略"></a>3.3 跨源策略</h2><p>这里有一条规则：来自一个网站的脚本无法访问其他网站的内容。例如，位于<code>https://facebook.com</code>的脚本无法读取位于<code>https://gmail.com</code>的用户邮箱。</p><p>或者，更确切地说，一个源（域&#x2F;端口&#x2F;协议三者）无法获取另一个源（origin）的内容。因此，即使我们有一个子域，或者仅仅是另一个端口，这都是不同的源，彼此无法相互访问。 这个规则还影响其他域的资源。 如果我们使用的是来自其他域的脚本，并且该脚本中存在 error，那么我们无法获取 error 的详细信息。</p><p>因为有很多服务（我们也可以构建自己的服务）使用<code>window.onerror</code>监听全局 error，保存 error 并提供访问和分析 error 的接口。这很好，因为我们可以看到由用户触发的实际中的 error。但是，如果一个脚本来自于另一个源（origin），则没有太多有关 error 的信息。</p><p>要允许跨源访问，<code>&lt;script&gt;</code>标签需要具有 crossorigin 特性（attribute），并且远程服务器必须提供特殊的 header。</p><ol><li>无<code>crossorigin</code>特性 —— 禁止访问。</li><li><code>crossorigin=&quot;anonymous&quot;</code> —— 如果服务器的响应带有包含 * 或我们的源（origin）的 header <code>Access-Control-Allow-Origin</code>，则允许访问。浏览器不会将授权信息和 cookie 发送到远程服务器。</li><li><code>crossorigin=&quot;use-credentials&quot;</code> —— 如果服务器发送回带有我们的源的 header <code>Access-Control-Allow-Origin</code> 和 <code>Access-Control-Allow-Credentials: true</code>，则允许访问。浏览器会将授权信息和 cookie 发送到远程服务器。</li></ol><p>关于cookie的相关知识会在下面进行介绍。</p><h1 id="四、cookie"><a href="#四、cookie" class="headerlink" title="四、cookie"></a>四、cookie</h1><p>Cookie 是直接存储在浏览器中的一小串数据。它们是 HTTP 协议的一部分。 Cookie 通常是由Web服务器使用响应<code>Set-Cookie HTTP-header</code>设置的。然后浏览器使用<code>Cookie HTTP-header</code>将它们自动添加到（几乎）每个对相同域的请求中。</p><p>最常见的用处之一就是身份验证：</p><ol><li>登录后，服务器在响应中使用<code>Set-Cookie HTTP-header</code>来设置具有唯一“会话标识符（session identifier）”的 cookie。</li><li>下次当请求被发送到同一个域时，浏览器会使用<code>Cookie HTTP-header</code>通过网络发送 cookie。</li><li>所以服务器知道是谁发起了请求。</li></ol><p>我们还可以使用<code>document.cookie</code>属性从浏览器访问 cookie。</p><h2 id="4-1-document-cookie"><a href="#4-1-document-cookie" class="headerlink" title="4.1 document.cookie"></a>4.1 document.cookie</h2><p><code>document.cookie</code>的值由<code>name=value</code>对组成，以 ; 分隔。每一个都是独立的 cookie。 为了找到一个特定的 cookie，我们可以以 ; 作为分隔，将<code>document.cookie</code>分开，然后找到对应的名字。我们可以使用正则表达式或者数组函数来实现。</p><p><strong>可以使用document.cookie来更新cookie的值。但是这种写入操作只会更新其中提到的 cookie，而不会涉及其他 cookie</strong></p><p>从技术上讲，cookie 的名称和值可以是任何字符。为了保持有效的格式，它们应该使用内建的<code>encodeURIComponent</code>函数对其进行转义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特殊字符（空格），需要编码</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;my name&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> value = <span class="string">&quot;John Smith&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 cookie 编码为 my%20name=John%20Smith</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>); <span class="comment">// ...; my%20name=John%20Smith</span></span><br></pre></td></tr></table></figure><p>cookie的限制：</p><ul><li><code>encodeURIComponent</code>编码后的 name&#x3D;value 对，大小不能超过 4KB。因此，我们不能在一个 cookie 中保存大的东西。</li><li>每个域的 cookie 总数不得超过 20+ 左右，具体限制取决于浏览器。</li></ul><h2 id="4-2-cookie的选项"><a href="#4-2-cookie的选项" class="headerlink" title="4.2 cookie的选项"></a>4.2 cookie的选项</h2><p><code>document.cookie = &quot;user=John; path=/; expires=Tue, 19 Jan 2038 03:14:07 GMT&quot;</code></p><ul><li><p>path: path&#x3D;&#x2F;mypath。</p><ul><li>url 路径前缀必须是绝对路径。它使得该路径下的页面可以访问该 cookie。默认为当前路径。</li><li>如果一个 cookie 带有<code>path=/admin</code>设置，那么该 cookie 在<code>/admin</code>和<code>/admin/something</code>下都是可见的，但是在<code>/home</code>或<code>/adminpage</code>下不可见。</li><li>通常，我们应该将path设置为根目录：<code>path=/</code>，以使 cookie 对此网站的所有页面可见。</li></ul></li><li><p>domain:domain&#x3D;site.com</p><ul><li><p>domain 控制了可访问 cookie 的域。但是在实际中，有一些限制。我们无法设置任何域。</p></li><li><p>无法从另一个二级域访问 cookie，因此<code>other.com</code>永远不会收到在<code>site.com</code>设置的 cookie。</p></li><li><p>这是一项安全限制，为了允许我们将敏感数据存储在应该仅在一个站点上可用的 cookie 中。</p></li><li><p>默认情况下，cookie 只有在设置的域下才能被访问到。</p></li><li><p>请注意，默认情况下，cookie 也不会共享给子域，例如<code>forum.site.com</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果我们在 site.com 网站上设置了 cookie……</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;user=John&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……在 forum.site.com 域下我们无法访问它</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>); <span class="comment">// 没有 user</span></span><br></pre></td></tr></table></figure></li><li><p><strong>所以说，如果想要在子域上访问父域的cookie，则需要通过<code>domain</code>来将<code>domain=site.com</code>，这样就将父域设置为了根域，从而所有子域都能够访问到这样的cookie</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 site.com</span></span><br><span class="line"><span class="comment">// 使 cookie 可以被在任何子域 *.site.com 访问：</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;user=John; domain=site.com&quot;</span></span><br><span class="line"><span class="comment">// 之后</span></span><br><span class="line"><span class="comment">// 在 forum.site.com</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>); <span class="comment">// 有 cookie user=John</span></span><br></pre></td></tr></table></figure></li><li><p>出于历史原因,<code>domain=.site.com</code>（site.com 前面有一个点符号）也以相同的方式工作，允许从子域访问 cookie。这是一个旧的表示方式，如果我们需要支持非常旧的浏览器，那么应该使用它</p></li></ul></li><li><p>expires,max-age</p><ul><li><p>默认情况下，如果一个 cookie 没有设置这两个参数中的任何一个，那么在关闭浏览器之后，它就会消失。此类 cookie 被称为 “session cookie”。</p></li><li><p>为了让 cookie 在浏览器关闭后仍然存在，我们可以设置 expires 或 max-age 选项中的一个。<code>expires=Tue, 19 Jan 2038 03:14:07 GMT</code></p></li><li><p>cookie 的过期时间定义了浏览器会自动清除该 cookie 的时间。</p></li><li><p>日期必须完全采用 GMT 时区的这种格式。我们可以使用<code>date.toUTCString</code>来获取。</p></li><li><p>如果我们将<code>expires</code>设置为过去的时间，则 cookie 会被删除。</p></li><li><p><code>max-age</code>是<code>expires</code>的替代选项，指明了 cookie 的过期时间距离当前时间的秒数。</p></li><li><p>如果将其设置为 0 或负数，则 cookie 会被删除：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// cookie 会在一小时后失效</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;user=John; max-age=3600&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><p>&#x2F;&#x2F; 删除 cookie（让它立即过期） document.cookie &#x3D; “user&#x3D;John; max-age&#x3D;0”;</p></li><li><p>secure</p><ul><li>Cookie 应只能被通过 HTTPS 传输。</li><li><strong>默认情况下，如果我们在<code>http://site.com</code>上设置了 cookie，那么该 cookie 也会出现在<code>https://site.com</code>上，反之亦然。</strong></li><li>也就是说，cookie 是基于域的，它们不区分协议。</li><li>使用此选项，如果一个 cookie 是通过<code>https://site.com</code>设置的，那么它不会在相同域的 HTTP 环境下出现，例如 <code>http://site.com</code>。所以，如果一个 cookie 包含绝不应该通过未加密的 HTTP 协议发送的敏感内容，那么就应该设置 secure 标识</li></ul></li><li><p>samesite</p><ul><li>这是另外一个关于安全的特性。它旨在防止 XSRF（跨网站请求伪造）攻击。</li><li>当<code>samesite=strict</code>时，如果用户来自同一网站之外，那么设置了 <code>samesite=strict</code>的 cookie 永远不会被发送。</li><li><code>samesite=lax</code>是一种更轻松的方法，该方法还可以防止 XSRF 攻击，并且不会破坏用户体验。</li><li>宽松（lax）模式，和 strict 模式类似，当从外部来到网站，则禁止浏览器发送 cookie，但是增加了一个例外。</li><li>如果以下两个条件均成立，则会发送含 samesite&#x3D;lax 的 cookie：</li><li><ol><li>HTTP 方法是“安全的”（例如 GET 方法，而不是 POST）。</li></ol></li><li>所有安全的 HTTP 方法详见<a href="https://datatracker.ietf.org/doc/html/rfc7231">RFC7231规范</a>。基本上，这些都是用于读取而不是写入数据的方法。它们不得执行任何更改数据的操作。跟随链接始终是 GET，是安全的方法。<ol start="2"><li>该操作执行顶级导航（更改浏览器地址栏中的 URL）。</li></ol></li><li>这通常是成立的，但是如果导航是在一个<code>&lt;iframe&gt;</code>中执行的，那么它就不是顶级的。此外，用于网络请求的 JavaScript 方法不会执行任何导航，因此它们不适合。</li><li>所以，<code>samesite=lax</code>所做的是基本上允许最常见的“前往 URL”操作携带 cookie。例如，从笔记中打开网站链接就满足这些条件。</li><li>但是，任何更复杂的事儿，例如来自另一个网站的网络请求或表单提交都会丢失 cookie。</li><li>如果这种情况适合你，那么添加<code>samesite=lax</code>将不会破坏用户体验并且可以增加保护。</li><li><strong>samesite会被到 2017 年左右的旧版本浏览器忽略（不兼容）。</strong></li><li>所以可以将 samesite 与其他保护措施（例如 XSRF token）一起使用，例如 xsrf token，这样可以多增加一层保护，将来，当旧版本的浏览器淘汰时，我们可能就可以删除 xsrf token 这种方式了。</li></ul></li><li><p>httpOnly</p><ul><li>Web 服务器使用<code>Set-Cookie header</code>来设置 cookie。并且，它可以设置 <code>httpOnly</code>选项。</li><li>这个选项禁止任何 JavaScript 访问 cookie。我们使用<code>document.cookie</code>看不到此类 cookie，也无法对此类 cookie 进行操作。</li><li>这个的主要作用就是保护浏览器被入侵而造成的用户信息的泄露</li></ul></li></ul><h2 id="4-3-cookie函数"><a href="#4-3-cookie函数" class="headerlink" title="4.3 cookie函数"></a>4.3 cookie函数</h2><p>这里有一组有关 cookie 操作的函数，比手动修改 document.cookie 方便得多。</p><p>有很多这种 cookie 库，所以这些函数只用于演示。虽然它们都能正常使用。</p><h3 id="4-3-1-getCookie-name"><a href="#4-3-1-getCookie-name" class="headerlink" title="4.3.1 getCookie(name)"></a>4.3.1 getCookie(name)</h3><p>获取 cookie 最简短的方式是使用 正则表达式。 getCookie(name) 函数返回具有给定 name 的 cookie：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回具有给定 name 的 cookie，</span></span><br><span class="line"><span class="comment">// 如果没找到，则返回 undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getCookie</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> matches = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">match</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>(</span><br><span class="line">    <span class="string">&quot;(?:^; )&quot;</span> + name.<span class="title function_">replace</span>(<span class="regexp">/([\.$?*&#123;&#125;\(\)\[\]\\\/\+^])/g</span>, <span class="string">&#x27;\\$1&#x27;</span>) + <span class="string">&quot;=([^;]*)&quot;</span></span><br><span class="line">  ));</span><br><span class="line">  <span class="keyword">return</span> matches ? <span class="built_in">decodeURIComponent</span>(matches[<span class="number">1</span>]) : <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 new RegExp 是动态生成的，以匹配 ; name&#x3D;。</p><p>请注意 cookie 的值是经过编码的，所以 getCookie 使用了内建方法 <code>decodeURIComponent</code>函数对其进行解码。</p><h3 id="4-3-2-setCookie-name-value-options"><a href="#4-3-2-setCookie-name-value-options" class="headerlink" title="4.3.2 setCookie(name, value,options)"></a>4.3.2 setCookie(name, value,options)</h3><p>将 cookie 的 name 设置为具有默认值 path&#x3D;&#x2F;（可以修改以添加其他默认值）和给定值 value：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setCookie</span>(<span class="params">name, value, options = &#123;&#125;</span>) &#123;</span><br><span class="line"></span><br><span class="line">  options = &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="comment">// 如果需要，可以在这里添加其他默认值</span></span><br><span class="line">    ...options</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">expires</span> <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">    options.<span class="property">expires</span> = options.<span class="property">expires</span>.<span class="title function_">toUTCString</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updatedCookie = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">&quot;=&quot;</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> optionKey <span class="keyword">in</span> options) &#123;</span><br><span class="line">    updatedCookie += <span class="string">&quot;; &quot;</span> + optionKey;</span><br><span class="line">    <span class="keyword">let</span> optionValue = options[optionKey];</span><br><span class="line">    <span class="keyword">if</span> (optionValue !== <span class="literal">true</span>) &#123;</span><br><span class="line">      updatedCookie += <span class="string">&quot;=&quot;</span> + optionValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">cookie</span> = updatedCookie;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用范例：</span></span><br><span class="line"><span class="title function_">setCookie</span>(<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;John&#x27;</span>, &#123;<span class="attr">secure</span>: <span class="literal">true</span>, <span class="string">&#x27;max-age&#x27;</span>: <span class="number">3600</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-3-3-deleteCookie-name"><a href="#4-3-3-deleteCookie-name" class="headerlink" title="4.3.3 deleteCookie(name)"></a>4.3.3 deleteCookie(name)</h3><p>要删除一个 cookie，我们可以给它设置一个负的过期时间来调用它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deleteCookie</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title function_">setCookie</span>(name, <span class="string">&quot;&quot;</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;max-age&#x27;</span>: -<span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>请注意：当我们更新或删除一个 cookie 时，我们应该使用和设置 cookie 时相同的路径和域选项。</strong></p><h2 id="4-4-第三方cookie"><a href="#4-4-第三方cookie" class="headerlink" title="4.4 第三方cookie"></a>4.4 第三方cookie</h2><p>如果 cookie 是由用户所访问的页面的域以外的域放置的，则称其为第三方 cookie。</p><p>由于它的性质，第三方 cookie 通常用于跟踪和广告服务。它们被绑定在原始域上，因此 ads.com 可以在不同网站之间跟踪同一用户，如果这些网站都可以访问 ads.com 的话。</p><p>当然，有些人不喜欢被跟踪，因此浏览器允许禁止此类 cookie。</p><p>此外，一些现代浏览器对此类 cookie 采取特殊策略：</p><ul><li>Safari 浏览器完全不允许第三方 cookie。</li><li>Firefox 浏览器附带了一个第三方域的黑名单，它阻止了来自名单内的域的第三方 cookie。</li></ul><h2 id="4-5-GDPR"><a href="#4-5-GDPR" class="headerlink" title="4.5 GDPR"></a>4.5 GDPR</h2><p>欧洲有一项名为 GDPR 的立法，该法规针对网站尊重用户实施了一系列规则。其中之一就是需要明确的许可才可以跟踪用户的 cookie。</p><p><strong>所以说很多网站要用户来同意使用cookie，但是感觉国内网站根本没有这个东西-。-</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、页面的生命周期&quot;&gt;&lt;a href=&quot;#一、页面的生命周期&quot; class=&quot;headerlink&quot; title=&quot;一、页面的生命周期&quot;&gt;&lt;/a&gt;一、页面的生命周期&lt;/h1&gt;&lt;p&gt;HTML 页面的生命周期包含三个重要事件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOMCont</summary>
      
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>js补充知识</title>
    <link href="http://example.com/2022/06/22/js%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2022/06/22/js%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/</id>
    <published>2022-06-22T05:44:19.000Z</published>
    <updated>2023-03-20T08:32:35.762Z</updated>
    
    <content type="html"><![CDATA[<h3 id="现代模式"><a href="#现代模式" class="headerlink" title="现代模式"></a>现代模式</h3><p>现代模式<code>&quot;use strict&quot;;</code>当它处于脚本文件的顶部时，则整个脚本文件都将以“现代”模式进行工作。 <code>&quot;use strict&quot;</code>可以被放在函数体的开头。这样则可以只在该函数中启用严格模式。 但通常人们会在整个脚本中启用严格模式。</p><span id="more"></span><h3 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h3><p>用<code>let</code>来声明一个变量，原来用<code>var</code>来声明变量是一种比较古老的方式 <code>let message = &quot;hello&quot;;</code> 一个变量应该只能被声明一次，之后只进行引用</p><p>声明一个常数（不变）变量，可以使用 <code>const</code> 而非 <code>let</code>,常量不能被修改，否则会报错 一个普遍的做法是将常量用作别名，以便记住那些在执行之前就已知的难以记住的值。例如使用大写字母和下划线来命名这些常量。</p><h4 id="let-和-var的区别"><a href="#let-和-var的区别" class="headerlink" title="let 和 var的区别"></a>let 和 var的区别</h4><p>var没有块级作用域，它只存在于函数作用域和全局作用域，所以如果有一个代码块的话，等于var会创建一个全局变量。 而let只会存在在代码块内。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> test = <span class="literal">true</span>; <span class="comment">// 使用 &quot;var&quot; 而不是 &quot;let&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(test); <span class="comment">// true，变量在 if 结束后仍存在</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> test = <span class="literal">true</span>; <span class="comment">// 使用 &quot;let&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(test); <span class="comment">// ReferenceError: test is not defined</span></span><br></pre></td></tr></table></figure><p><strong>var能够穿透if，for和其它代码块。</strong></p><p>如果我们用 let 在同一作用域下将同一个变量声明两次，则会出现错误。 使用 var，我们可以重复声明一个变量，不管多少次都行。如果我们对一个已经声明的变量使用var，这条新的声明语句会被忽略。 <strong>var 变量声明在函数开头就会被处理（脚本启动对应全局变量）。</strong></p><h3 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h3><p>numbe类型无法大于大于 (2^53-1)（即 9007199254740991），或小于 -(2^53-1) 的整数。这是其内部表示形式导致的技术限制。 可以通过将 n 附加到整数字段的末尾来创建 BigInt 值。 <code>const bigInt = 1234567890123456789012345678901234567890n;</code></p><h3 id="通过反引号对字符串嵌入"><a href="#通过反引号对字符串嵌入" class="headerlink" title="通过反引号对字符串嵌入"></a>通过反引号对字符串嵌入</h3><p>反引号是<strong>功能扩展</strong>引号。它们允许我们通过将变量和表达式包装在<code>$&#123;...&#125;</code>中，来将它们嵌入到字符串中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">`the result is <span class="subst">$&#123;<span class="number">1</span> + <span class="number">2</span>&#125;</span>`</span> ); <span class="comment">// the result is 3</span></span><br></pre></td></tr></table></figure><h3 id="for-in-和for-of-的区别"><a href="#for-in-和for-of-的区别" class="headerlink" title="for in 和for of 的区别"></a>for in 和for of 的区别</h3><p>for in 和for of 都是遍历对象里的每一项，那么他们有什么区别呢？ 区别1： for of无法循环遍历对象 区别2： <strong>for in循环遍历的是数组的索引，for of循环遍历的是数组的值</strong></p><p><strong>可以应用 for..of 的对象被称为 可迭代的。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;nick&#x27;</span>,<span class="string">&#x27;freddy&#x27;</span>,<span class="string">&#x27;mike&#x27;</span>,<span class="string">&#x27;james&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key);   <span class="comment">//输出的是0,1,2,3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----------分割线-----------&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> arr)&#123;   </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);  <span class="comment">//输出的是nick&#x27;,&#x27;freddy&#x27;,&#x27;mike&#x27;,&#x27;james&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别3： for in 会遍历自定义属性，for of不会</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;nick&#x27;</span>,<span class="string">&#x27;freddy&#x27;</span>,<span class="string">&#x27;mike&#x27;</span>,<span class="string">&#x27;james&#x27;</span>];</span><br><span class="line">arr.<span class="property">name</span> = <span class="string">&quot;数组&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key+<span class="string">&#x27;: &#x27;</span>+arr[key]);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----------分割线-----------&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> arr)&#123;   </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给数组添加一个自定义属性name，并且赋值”数组”。然后进行遍历输出的，会发现新定义的属性也被for in输出来了，而for of并不会对name进行输出。</p><h3 id="对象的一些补充知识"><a href="#对象的一些补充知识" class="headerlink" title="对象的一些补充知识"></a>对象的一些补充知识</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    name = <span class="string">&quot;john&quot;</span>,</span><br><span class="line">    age = <span class="number">30</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>列表中的最后一个属性应以逗号结尾,这叫做尾随（trailing）或悬挂（hanging）逗号。这样便于我们添加、删除和移动属性，因为所有的行都是相似的。 通过方括号同样可以对对象进行操作 比如说<code>user[&quot;like birds&quot;] = true;</code>或者是<code>delete user[&quot;like birds&quot;]</code>就可以通过方括号来对对象进行增删查改，并且可以适用于任何字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> key = <span class="title function_">prompt</span>(<span class="string">&quot;What do you want to know about the user?&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问变量</span></span><br><span class="line"><span class="title function_">alert</span>( user[key] ); <span class="comment">// John（如果输入 &quot;name&quot;）</span></span><br></pre></td></tr></table></figure><p>又或者可以通过变量<code>key</code>来访问属性。而点符号则不能使用 key只能访问user中存在的属性，如果属性不存在则显示undefined，这里的key会指向name</p><p>对象的克隆和合并可以使用<code>Object.assign(dest, [src1, src2, src3...])</code>方法 第一个参数 dest 是指目标对象。 更后面的参数 src1, …, srcN（可按需传递多个参数）是源对象。 该方法将所有源对象的属性拷贝到目标对象 dest 中。换句话说，从第二个开始的所有参数的属性都被拷贝到第一个参数的对象中。 调用结果返回 dest。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> permissions1 = &#123; <span class="attr">canView</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> permissions2 = &#123; <span class="attr">canEdit</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 permissions1 和 permissions2 中的所有属性都拷贝到 user 中</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(user, permissions1, permissions2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 user = &#123; name: &quot;John&quot;, canView: true, canEdit: true &#125;</span></span><br></pre></td></tr></table></figure><p>如果被拷贝的属性的属性名已经存在，那么它会被覆盖：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(user, &#123; <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">name</span>); <span class="comment">// 现在 user = &#123; name: &quot;Pete&quot; &#125;</span></span><br></pre></td></tr></table></figure><p>我们也可以用 Object.assign 代替 for..in 循环来进行简单克隆：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clone = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, user);</span><br></pre></td></tr></table></figure><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>symbol表示唯一的标识符。 Symbol 保证是唯一的。即使我们创建了许多具有相同描述的 Symbol，它们的值也是不同。描述只是一个标签，不影响任何东西。 例如，这里有两个描述相同的 Symbol —— 它们不相等：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id1 = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> id2 = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(id1 == id2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>Symbol 不会被自动转换为字符串</strong> 如果我们真的想显示一个 Symbol，我们需要在它上面调用 <code>.toString()</code>，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(id.<span class="title function_">toString</span>()); <span class="comment">// Symbol(id)，现在它有效了</span></span><br></pre></td></tr></table></figure><p>或者获取 symbol.description 属性，只显示描述（description）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(id.<span class="property">description</span>); <span class="comment">// id</span></span><br></pre></td></tr></table></figure><p><strong>Symbol 允许我们创建对象的“隐藏”属性，代码的任何其他部分都不能意外访问或重写这些属性。</strong></p><h3 id="数字、字符串、数组的补充"><a href="#数字、字符串、数组的补充" class="headerlink" title="数字、字符串、数组的补充"></a>数字、字符串、数组的补充</h3><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>假如我们需要表示 10 亿。显然，我们可以这样写： <code>MARKDOWN_HASH3c0128960a8d24c0e2a3faa7cb76fcf5MARKDOWN_HASH_</code> <em>我们也可以使用下划线</em> 作为分隔符： <code>MARKDOWN_HASH132377f2ba50b82cc7752c46a838738dMARKDOWN_HASH_</code> <em>这里的下划线</em> 扮演了“语法糖”的角色，使得数字具有更强的可读性。JavaScript 引擎会直接忽略数字之间的 _，所以 上面两个例子其实是一样的。 在 JavaScript 中，我们可以通过在数字后面附加字母 “e” 并指定零的个数来缩短数字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> billion = <span class="number">1e9</span>;  <span class="comment">// 10 亿，字面意思：数字 1 后面跟 9 个 0</span></span><br><span class="line"><span class="keyword">let</span> mcs = <span class="number">1e-6</span>; <span class="comment">// 1 的左边有 6 个 0 --&gt;0.000001</span></span><br></pre></td></tr></table></figure><p>方法 num.toString(base) 返回在给定 base 进制数字系统中 num 的字符串表示形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( num.<span class="title function_">toString</span>(<span class="number">16</span>) );  <span class="comment">// ff</span></span><br><span class="line"><span class="title function_">alert</span>( num.<span class="title function_">toString</span>(<span class="number">2</span>) );   <span class="comment">// 11111111</span></span><br></pre></td></tr></table></figure><p>函数 toFixed(n) 将数字舍入到小数点后 n 位，并以<strong>字符串形式</strong>返回结果。 因为toFixed 的结果是一个字符串。如果小数部分比所需要的短，则在结尾添加零：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">12.34</span>;</span><br><span class="line"><span class="title function_">alert</span>( num.<span class="title function_">toFixed</span>(<span class="number">5</span>) ); <span class="comment">// &quot;12.34000&quot;，在结尾添加了 0，以达到小数点后五位</span></span><br></pre></td></tr></table></figure><p>所以说如果使用toFixed来转换，可以使用一元加号或Number()调用，将其转换为数字：<code>+num.toFixed(5)</code></p><p><strong>因为在js中进行小数操作时，很有可能出现精度损失，所以在处理小数时避免相等性检查。</strong></p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p><code>str.charAt[pos]</code>可以获取在pos位置的字符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`Hello`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个字符</span></span><br><span class="line"><span class="title function_">alert</span>( str[<span class="number">0</span>] ); <span class="comment">// H</span></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">charAt</span>(<span class="number">0</span>) ); <span class="comment">// H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一个字符</span></span><br><span class="line"><span class="title function_">alert</span>( str[str.<span class="property">length</span> - <span class="number">1</span>] ); <span class="comment">// o</span></span><br></pre></td></tr></table></figure><p><strong><code>str.charCodeAt[pos]</code>可以获取在pos位置的字符的Unicode编码</strong></p><p>toLowerCase() 和 toUpperCase() 方法可以改变大小写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&#x27;Interface&#x27;</span>.<span class="title function_">toUpperCase</span>() ); <span class="comment">// INTERFACE</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&#x27;Interface&#x27;</span>.<span class="title function_">toLowerCase</span>() ); <span class="comment">// interface</span></span><br></pre></td></tr></table></figure><p><code>str.indexOf()</code> 和<code>str.lastIndexOf()</code>用于查找字符串中某个字符或字符串的位置 如果找到则返回位置，没找到则返回-1。 不同的是，indexOf是从头开始寻找，lastIndexOf是从尾部开始寻找，但是这两种方法返回的值都是正向的。</p><p>更现代的方法 str.includes(substr, pos) 根据 str 中是否包含 substr 来返回 true&#x2F;false。 <strong>如果我们需要检测匹配，但不需要它的位置，那么这是正确的选择</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Widget with id&quot;</span>.<span class="title function_">includes</span>(<span class="string">&quot;Widget&quot;</span>) ); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Hello&quot;</span>.<span class="title function_">includes</span>(<span class="string">&quot;Bye&quot;</span>) ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>str.includes 的第二个可选参数是开始搜索的起始位置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Midget&quot;</span>.<span class="title function_">includes</span>(<span class="string">&quot;id&quot;</span>) ); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Midget&quot;</span>.<span class="title function_">includes</span>(<span class="string">&quot;id&quot;</span>, <span class="number">3</span>) ); <span class="comment">// false, 从位置 3 开始没有 &quot;id&quot;</span></span><br></pre></td></tr></table></figure><p>方法 str.startsWith 和 str.endsWith 的功能与其名称所表示的意思相同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Widget&quot;</span>.<span class="title function_">startsWith</span>(<span class="string">&quot;Wid&quot;</span>) ); <span class="comment">// true，&quot;Widget&quot; 以 &quot;Wid&quot; 开始</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Widget&quot;</span>.<span class="title function_">endsWith</span>(<span class="string">&quot;get&quot;</span>) ); <span class="comment">// true，&quot;Widget&quot; 以 &quot;get&quot; 结束</span></span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>通过数组来实现队列和栈 <strong>队列(queque)：</strong> push 在末端添加一个元素. shift 取出队列首端的一个元素，整个队列往前移，这样原先排第二的元素现在排在了第一。 这两种操作数组都支持。 队列的应用在实践中经常会碰到。例如需要在屏幕上显示消息队列。 <strong>栈：</strong> push 在末端添加一个元素. pop 从末端取出一个元素. 所以新元素的添加和取出都是从“末端”开始的。 栈通常被被形容成一叠卡片：要么在最上面添加卡片，要么从最上面拿走卡片： 对于栈来说，最后放进去的内容是最先接收的，也叫做 LIFO（Last-In-First-Out），即后进先出法则。而与队列相对应的叫做 FIFO（First-In-First-Out），即先进先出。 JavaScript 中的数组既可以用作队列，也可以用作栈。它们允许你从首端&#x2F;末端来添加&#x2F;删除元素。 这在计算机科学中，允许这样的操作的数据结构被称为<strong>双端队列（deque）</strong>。</p><p><strong>不能够使用&#x3D;&#x3D;来比较数组</strong> JavaScript 中的数组与其它一些编程语言的不同，不应该使用 &#x3D;&#x3D; 运算符比较 JavaScript 中的数组。 该运算符不会对数组进行特殊处理，它会像处理任意对象那样处理数组。 所以，<strong>如果我们使用 &#x3D;&#x3D; 来比较数组，除非我们比较的是两个引用同一数组的变量，否则它们永远不相等。</strong></p><h4 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h4><p><code>arr.find(function(item, index, array) &#123;如果返回 true，则返回 item 并停止迭代。对于假值（falsy）的情况，则返回 undefined&#125;)</code>可以找到具有特定条件的对象。 item 是元素。index 是它的索引。array 是数组本身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> users = [</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&quot;Mary&quot;</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = users.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span> == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">name</span>); <span class="comment">// John</span></span><br></pre></td></tr></table></figure><p>感觉同理可得如果想要看这个数组是不是全零数组，也可以使用这个来判断 <code>arr.find(item =&gt; item !=0)</code></p><p><code>arr.findIndex</code>方法（与 arr.find 方法）基本上是一样的，但它返回找到元素的索引，而不是元素本身。并且在未找到任何内容时返回 -1。</p><p>find 方法搜索的是使函数返回 true 的第一个（单个）元素。 如果需要匹配的有很多，我们可以使用 arr.filter(fn)。 语法与 find 大致相同，但是 filter 返回的是所有匹配元素组成的数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> users = [</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&quot;Mary&quot;</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回前两个用户的数组</span></span><br><span class="line"><span class="keyword">let</span> someUsers = users.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span> &lt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(someUsers.<span class="property">length</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><strong>map方法</strong>是最有用也最常用的方法 它对数组的每个元素都调用函数，并返回结果数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将每个元素转换为它的字符串长度</span></span><br><span class="line"><span class="keyword">let</span> lengths = [<span class="string">&quot;Bilbo&quot;</span>, <span class="string">&quot;Gandalf&quot;</span>, <span class="string">&quot;Nazgul&quot;</span>].<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">length</span>);</span><br><span class="line"><span class="title function_">alert</span>(lengths); <span class="comment">// 5,7,6</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个数组，数组的每个元素里又有一个子数组</span></span><br><span class="line"><span class="keyword">let</span> r = <span class="number">4</span>,c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(r).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(c).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>排序算法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums1.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a-b);</span><br><span class="line">nums2.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b-a);</span><br></pre></td></tr></table></figure><p>全新的对数字排序方法，本质还是一个函数，但是表示的更加方便了</p><p>通过<code>arr.some(fn)/arr.every(fn)</code>检查数组 与 map 类似，对数组的每个元素调用函数 fn。如果任何&#x2F;所有结果为 true，则返回 true，否则返回 false。 这两个方法的行为类似于 和 &amp;&amp; 运算符：如果 fn 返回一个真值，arr.some() 立即返回 true 并停止迭代其余数组项；如果 fn 返回一个假值，arr.every() 立即返回 false 并停止对其余数组项的迭代。 我们可以使用 every 来比较数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arraysEqual</span>(<span class="params">arr1, arr2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr1.<span class="property">length</span> === arr2.<span class="property">length</span> &amp;&amp; arr1.<span class="title function_">every</span>(<span class="function">(<span class="params">value, index</span>) =&gt;</span> value === arr2[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>( <span class="title function_">arraysEqual</span>([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>])); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>arr.fill(value, start, end) —— 从索引 start 到 end，用重复的 value 填充数组 <strong>一般用于制作全0或全1矩阵</strong></p><p>arr.flat(depth)&#x2F;arr.flatMap(fn) 从多维数组创建一个新的扁平数组。</p><p>有一个全局方法<code>Array.from</code>可以接受一个可迭代或类数组的值，并从中获取一个“真正的”数组。 <code>Array.from(obj[, mapFn, thisArg])</code>其完整语法允许我们提供一个可选的“映射（mapping）”函数。 可选的第二个参数 mapFn 可以是一个函数，该函数会在对象中的元素被添加到数组前，被应用于每个元素，此外 thisArg 允许我们为该函数设置 this。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">range = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 求每个数的平方</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(range, <span class="function"><span class="params">num</span> =&gt;</span> num * num);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(arr); <span class="comment">// 1,4,9,16,25</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;𝒳😂&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 str 拆分为字符数组</span></span><br><span class="line"><span class="keyword">let</span> chars = <span class="title class_">Array</span>.<span class="title function_">from</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(chars[<span class="number">0</span>]); <span class="comment">// 𝒳</span></span><br><span class="line"><span class="title function_">alert</span>(chars[<span class="number">1</span>]); <span class="comment">// 😂</span></span><br><span class="line"><span class="title function_">alert</span>(chars.<span class="property">length</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>与 str.split 方法不同，它依赖于字符串的可迭代特性。因此，就像 for..of 一样，可以正确地处理代理对（surrogate pair）。（译注：代理对也就是 UTF-16 扩展字符。） 技术上来讲，它和下面这段代码做的是相同的事：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;𝒳😂&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> chars = []; <span class="comment">// Array.from 内部执行相同的循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> str) &#123;</span><br><span class="line">  chars.<span class="title function_">push</span>(char);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(chars);</span><br></pre></td></tr></table></figure><p>……但 Array.from 精简很多。 我们甚至可以基于 Array.from 创建代理感知（surrogate-aware）的slice 方法（译注：也就是能够处理 UTF-16 扩展字符的 slice 方法）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">slice</span>(<span class="params">str, start, end</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(str).<span class="title function_">slice</span>(start, end).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;𝒳😂𩷶&#x27;</span>;</span><br><span class="line"><span class="title function_">alert</span>( <span class="title function_">slice</span>(str, <span class="number">1</span>, <span class="number">3</span>) ); <span class="comment">// 😂𩷶</span></span><br><span class="line"><span class="comment">// 原生方法不支持识别代理对（译注：UTF-16 扩展字符）</span></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">3</span>) ); <span class="comment">// 乱码（两个不同 UTF-16 扩展字符碎片拼接的结果）</span></span><br></pre></td></tr></table></figure><h3 id="Map-and-Set（映射和集合）"><a href="#Map-and-Set（映射和集合）" class="headerlink" title="Map and Set（映射和集合）"></a>Map and Set（映射和集合）</h3><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>Map 是一个带键的数据项的集合，就像一个 Object 一样。 但是它们最大的差别是 Map 允许任何类型的键（key）。</p><ul><li><p>new Map() —— 创建 map。</p></li><li><p>map.set(key, value) —— 根据键存储值。 每一次 map.set 调用都会返回 map 本身，所以我们可以进行“链式”调用：</p></li><li><p>map.get(key) —— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined。</p></li><li><p>map.has(key) —— 如果 key 存在则返回 true，否则返回 false。</p></li><li><p>map.delete(key) —— 删除指定键的值。</p></li><li><p>map.clear() —— 清空 map。</p></li><li><p>map.size —— 返回当前元素个数。 map的重点是key，其主要的操作都是对key进行的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br></pre></td></tr></table></figure></li></ul><p>map.set(‘1’, ‘str1’); &#x2F;&#x2F; 字符串键 map.set(1, ‘num1’); &#x2F;&#x2F; 数字键 map.set(true, ‘bool1’); &#x2F;&#x2F; 布尔值键 &#x2F;&#x2F; Map 则会保留键的类型，所以下面这两个结果不同： alert( map.get(1) ); &#x2F;&#x2F; ‘num1’ alert( map.get(‘1’) ); &#x2F;&#x2F; ‘str1’</p><p>alert( map.size ); &#x2F;&#x2F; 3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">使用对象作为键是 Map 最值得注意和重要的功能之一。在 Object 中，我们则无法使用对象作为键。在 Object 中使用字符串作为键是可以的，但我们无法使用另一个 Object 作为 Object 中的键。</span><br><span class="line"></span><br><span class="line">- map.keys() —— 遍历并返回所有的键（returns an iterable for keys），</span><br><span class="line">- map.values() —— 遍历并返回所有的值（returns an iterable for values），</span><br><span class="line">- map.entries() —— 遍历并返回所有的实体（returns an iterable for entries）[key, value]，for..of 在默认情况下使用的就是这个。</span><br><span class="line">```js</span><br><span class="line">let recipeMap = new Map([</span><br><span class="line">  [&#x27;cucumber&#x27;, 500],</span><br><span class="line">  [&#x27;tomatoes&#x27;, 350],</span><br><span class="line">  [&#x27;onion&#x27;,    50]</span><br><span class="line">]);</span><br><span class="line">// 遍历所有的键（vegetables）</span><br><span class="line">for (let vegetable of recipeMap.keys()) &#123;</span><br><span class="line">  alert(vegetable); // cucumber, tomatoes, onion</span><br><span class="line">&#125;</span><br><span class="line">// 遍历所有的值（amounts）</span><br><span class="line">for (let amount of recipeMap.values()) &#123;</span><br><span class="line">  alert(amount); // 500, 350, 50</span><br><span class="line">&#125;</span><br><span class="line">// 遍历所有的实体 [key, value]</span><br><span class="line">for (let entry of recipeMap) &#123; // 与 recipeMap.entries() 相同</span><br><span class="line">  alert(entry); // cucumber,500 (and so on)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不管使用什么方法，返回的都是一个可迭代对象，而不是一个数组，如果想要将返回的对象转变为一个数组，需要使用<code>Array.from(map.keys())</code></p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Set 是一个特殊的类型集合 —— “值的集合”（没有键），它的每一个值只能出现一次。</p><ul><li><p>new Set(iterable) —— 创建一个 set，如果提供了一个 iterable 对象（通常是数组），将会从数组里面复制值到 set 中。</p></li><li><p>set.add(value) —— 添加一个值，返回 set 本身</p></li><li><p>set.delete(value) —— 删除值，如果 value 在这个方法调用的时候存在则返回 true ，否则返回 false。</p></li><li><p>set.has(value) —— 如果 value 在 set 中，返回 true，否则返回 false。</p></li><li><p>set.clear() —— 清空 set。</p></li><li><p>set.size —— 返回元素个数。 <strong>它的主要特点是，重复使用同一个值调用 set.add(value) 并不会发生什么改变。这就是 Set 里面的每一个值只出现一次的原因。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="keyword">let</span> john = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> pete = &#123; <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mary = &#123; <span class="attr">name</span>: <span class="string">&quot;Mary&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// visits，一些访客来访好几次</span></span><br><span class="line">set.<span class="title function_">add</span>(john);</span><br><span class="line">set.<span class="title function_">add</span>(pete);</span><br><span class="line">set.<span class="title function_">add</span>(mary);</span><br><span class="line">set.<span class="title function_">add</span>(john);</span><br><span class="line">set.<span class="title function_">add</span>(mary);</span><br><span class="line"><span class="comment">// set 只保留不重复的值</span></span><br><span class="line"><span class="title function_">alert</span>( set.<span class="property">size</span> ); <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> user <span class="keyword">of</span> set) &#123;</span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">name</span>); <span class="comment">// John（然后 Pete 和 Mary）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Set 的替代方法可以是一个用户数组，用 arr.find 在每次插入值时检查是否重复。但是这样性能会很差，因为这个方法会遍历整个数组来检查每个元素。Set 内部对唯一性检查进行了更好的优化。</p></li></ul><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>JSON（JavaScript Object Notation）是表示值和对象的通用格式。在 RFC 4627 标准中有对其的描述。最初它是为 JavaScript 而创建的，但许多其他编程语言也有用于处理它的库。因此，当客户端使用 JavaScript 而服务器端是使用 Ruby&#x2F;PHP&#x2F;Java 等语言编写的时，使用 JSON 可以很容易地进行数据交换。</p><ul><li><code>JSON.stringify</code>将对象转换为 JSON。 方法 JSON.stringify() 接收对象并将其转换为字符串。</li><li><code>JSON.parse</code>将 JSON 转换回对象。</li></ul><h4 id="json的编码"><a href="#json的编码" class="headerlink" title="json的编码"></a>json的编码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> student = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">isAdmin</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">courses</span>: [<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;css&#x27;</span>, <span class="string">&#x27;js&#x27;</span>],</span><br><span class="line">  <span class="attr">wife</span>: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> json = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(student);</span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> json); <span class="comment">// we&#x27;ve got a string!</span></span><br><span class="line"><span class="title function_">alert</span>(json);</span><br><span class="line"><span class="comment">/* JSON 编码的对象：</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;name&quot;: &quot;John&quot;,</span></span><br><span class="line"><span class="comment">  &quot;age&quot;: 30,</span></span><br><span class="line"><span class="comment">  &quot;isAdmin&quot;: false,</span></span><br><span class="line"><span class="comment">  &quot;courses&quot;: [&quot;html&quot;, &quot;css&quot;, &quot;js&quot;],</span></span><br><span class="line"><span class="comment">  &quot;wife&quot;: null</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>得到的json字符串是一个被称为JSON编码（JSON-encoded）或序列化（serialized）或字符串化（stringified）或编组化（marshalled）的对象。 我们现在已经准备好通过有线发送它或将其放入普通数据存储。 JSON 编码的对象与对象字面量有几个重要的区别： 字符串使用双引号。JSON 中没有单引号或反引号。所以 ‘John’ 被转换为 “John”。 对象属性名称也是双引号的。这是强制性的。所以 age:30 被转换成 “age”:30。 <strong>JSON 是语言无关的纯数据规范，因此一些特定于 JavaScript 的对象属性会被 JSON.stringify 跳过。</strong> 函数属性（方法）。Symbol 类型的键和值。存储 undefined 的属性。会被跳过</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字在 JSON 还是数字</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="number">1</span>) ) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 字符串在 JSON 中还是字符串，只是被双引号扩起来</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="string">&#x27;test&#x27;</span>) ) <span class="comment">// &quot;test&quot;</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="literal">true</span>) ); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="title class_">JSON</span>.<span class="title function_">stringify</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) ); <span class="comment">// [1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123; <span class="comment">// 被忽略</span></span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>)]: <span class="number">123</span>, <span class="comment">// 被忽略</span></span><br><span class="line">  <span class="attr">something</span>: <span class="literal">undefined</span> <span class="comment">// 被忽略</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">alert</span>( <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(user) ); <span class="comment">// &#123;&#125;（空对象）</span></span><br></pre></td></tr></table></figure><p>并且json支持嵌套对象转换并进行自动转码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> meetup = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;Conference&quot;</span>,</span><br><span class="line">  <span class="attr">room</span>: &#123;</span><br><span class="line">    <span class="attr">number</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="attr">participants</span>: [<span class="string">&quot;john&quot;</span>, <span class="string">&quot;ann&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">alert</span>( <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(meetup) );</span><br><span class="line"><span class="comment">/* 整个解构都被字符串化了</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;title&quot;:&quot;Conference&quot;,</span></span><br><span class="line"><span class="comment">  &quot;room&quot;:&#123;&quot;number&quot;:23,&quot;participants&quot;:[&quot;john&quot;,&quot;ann&quot;]&#125;,</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>JSON.stringify</code>的完整语法是： <code>let json = JSON.stringify(value,[replacer, space])</code> value:要编码的值。 replacer:要编码的属性数组或映射函数 function(key, value)。 space:用于格式化的空格数量 如果space&#x3D;2则等于告诉JavaScript在多行中显示嵌套的对象，对象内部缩进2个空格。 <strong>spaces 参数仅用于日志记录和美化输出。</strong> 大部分情况，JSON.stringify仅与第一个参数一起使用。但是，如果我们需要微调替换过程，比如过滤掉循环引用，我们可以使用JSON.stringify的第二个参数。 如果我们传递一个属性数组给它，那么只有这些属性会被编码。</p><p>像 toString 进行字符串转换，对象也可以提供 toJSON 方法来进行 JSON 转换。如果可用，JSON.stringify 会自动调用它。</p><h4 id="json的解码"><a href="#json的解码" class="headerlink" title="json的解码"></a>json的解码</h4><p><code>let value = JSON.parse(str, [reviver]);</code> str:要解析的 JSON 字符串。 reviver:可选的函数 function(key,value)，该函数将为每个 (key, value) 对调用，并可以对值进行转换。</p><p>JSON 不支持注释。向 JSON 添加注释无效。 还有另一种名为 JSON5 的格式，它允许未加引号的键，也允许注释等。但这是一个独立的库，不在语言的规范中。 常规的 JSON 格式严格，并不是因为它的开发者很懒，而是为了实现简单，可靠且快速地实现解析算法。</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p><code>let func = (arg1, arg2, ..., argN) =&gt; expression;</code> 箭头函数左边是接受的参数，并对右边求值并返回 如果我们只有一个参数，还可以省略掉参数外的圆括号，使代码更短。<code>let double = n =&gt; n * 2;</code> 如果没有参数，括号则是空的（但括号必须保留）：<code>let sayHi = () =&gt; alert(&quot;Hello!&quot;);</code></p><p><strong>箭头函数对于简单的单行行为（action）来说非常方便，尤其是当我们懒得打太多字的时候。</strong> 带花括号：(…args) &#x3D;&gt; { body } — 花括号允许我们在函数中编写多个语句，但是我们需要显式地 return 来返回一些内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">a, b</span>) =&gt; &#123;  <span class="comment">// 花括号表示开始一个多行函数</span></span><br><span class="line">  <span class="keyword">let</span> result = a + b;</span><br><span class="line">  <span class="keyword">return</span> result; <span class="comment">// 如果我们使用了花括号，那么我们需要一个显式的 “return”</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( <span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>) ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><strong>箭头函数没有 this。如果访问 this，则会从外部获取。</strong> <strong>不具有 this 自然也就意味着另一个限制：箭头函数不能用作构造器（constructor）。不能用 new 调用它们。</strong> <strong>箭头函数也没有 arguments 变量。</strong></p><h3 id="调度setTimeout-amp-setInterval"><a href="#调度setTimeout-amp-setInterval" class="headerlink" title="调度setTimeout &amp; setInterval"></a>调度setTimeout &amp; setInterval</h3><p>有时我们并不想立即执行一个函数，而是等待特定一段时间之后再执行。这就是所谓的“计划调用（scheduling a call）”。 setTimeout 允许我们将函数推迟到一段时间间隔之后再执行。 setInterval 允许我们重复运行一个函数，从一段时间间隔之后开始运行，之后以该时间间隔连续重复运行该函数。 <code>let timerId = setTimeout(funccode, [delay], [arg1], [arg2], ...)</code> <code>funccode</code>想要执行的函数或代码字符串。 一般传入的都是函数。由于某些历史原因，支持传入代码字符串，但是不建议这样做。 <code>delay</code>执行前的延时，以毫秒为单位（1000 毫秒 &#x3D; 1 秒），默认值是 0； <code>arg1，arg2…</code>要传入被执行函数（或代码字符串）的参数列表（IE9 以下不支持）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(sayHi, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>需要注意的是，setTimeout()里的function不能加()，以上面为例，需要使用sayHi而不能使用sayHi()，因为这个方法是对函数的引用。</p><p><strong>任何 setTimeout 都只会在当前代码执行完毕之后才会执行。</strong></p><p><strong>可以用clearTimeout来取消调度</strong> setTimeout 在调用时会返回一个“定时器标识符（timer identifier）”，在我们的例子中是 timerId，我们可以使用它来取消执行。</p><p><code>setInterval</code>方法和<code>setTimeout</code>的语法相同：<code>let timerId = setInterval(funccode, [delay], [arg1], [arg2], ...)</code> 所有参数的意义也是相同的。不过与 setTimeout 只执行一次不同，setInterval 是每间隔给定的时间周期性执行。 想要阻止后续调用，我们需要调用 clearInterval(timerId)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每 2 秒重复一次</span></span><br><span class="line"><span class="keyword">let</span> timerId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="title function_">alert</span>(<span class="string">&#x27;tick&#x27;</span>), <span class="number">2000</span>);</span><br><span class="line"><span class="comment">// 5 秒之后停止</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="built_in">clearInterval</span>(timerId); <span class="title function_">alert</span>(<span class="string">&#x27;stop&#x27;</span>); &#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>在大多数浏览器中，包括Chrome和Firefox，在显示alert&#x2F;confirm&#x2F;prompt弹窗时，内部的定时器仍旧会继续“嘀嗒”。 所以，在运行上面的代码时，如果在一定时间内没有关掉alert弹窗，那么在你关闭弹窗后，下一个 alert 会立即显示。两次alert之间的时间间隔将小于2秒。</p><p><strong>嵌套的 setTimeout 能够精确地设置两次执行之间的延时，而 setInterval 却不能。</strong></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;现代模式&quot;&gt;&lt;a href=&quot;#现代模式&quot; class=&quot;headerlink&quot; title=&quot;现代模式&quot;&gt;&lt;/a&gt;现代模式&lt;/h3&gt;&lt;p&gt;现代模式&lt;code&gt;&amp;quot;use strict&amp;quot;;&lt;/code&gt;当它处于脚本文件的顶部时，则整个脚本文件都将以“现代”模式进行工作。 &lt;code&gt;&amp;quot;use strict&amp;quot;&lt;/code&gt;可以被放在函数体的开头。这样则可以只在该函数中启用严格模式。 但通常人们会在整个脚本中启用严格模式。&lt;/p&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>DOM</title>
    <link href="http://example.com/2022/06/22/dom/"/>
    <id>http://example.com/2022/06/22/dom/</id>
    <published>2022-06-22T05:34:11.000Z</published>
    <updated>2023-03-20T08:32:34.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二、dom介绍"><a href="#二、dom介绍" class="headerlink" title="二、dom介绍"></a>二、dom介绍</h1><h2 id="2-1-dom-简介"><a href="#2-1-dom-简介" class="headerlink" title="2.1 dom 简介"></a>2.1 dom 简介</h2><p>DOM –&gt; Document Object Model 文档对象模型 文档表示的就是整个的 HTML 网页文档 对象表示将网页中的每一个部分都转换成一个对象 模型表示对象之间的关系，从而方便获取对象 <strong>通过 DOM 将所有页面内容表示为可以修改的对象。</strong></p><p>window 是<strong>根对象</strong>，首先，它是 JavaScript 代码的全局对象。其次，它代表“浏览器窗口”，并提供了控制它的方法。</p><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将背景颜色修改为红色</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="comment">// 在 1 秒后将其修改回来</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> (<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&quot;&quot;</span>), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>节点(elem)是构成网页的最基本的组成部分，网页中的每一个部分都是一个节点 一共有12种节点类型，但是通常使用的只有4种;</p><ol><li><p><code>document</code>是页面的主要“入口点”。我们可以使用它来更改或创建页面上的任何内容。</p></li><li><p><strong>元素节点</strong>:HTML 文档中的标签,<code>&lt;html&gt;</code>是根节点，<code>&lt;head&gt;</code>,<code>&lt;body&gt;</code>是其子项</p></li><li><p><strong>文本节点</strong>:元素内的文本形成文本节点，一个文本节点只包含一个字符串。它没有子项，并且总是树的叶子。 <strong>空格和换行符都是完全有效的字符，就像字母和数字。它们形成文本节点并成为 DOM 的一部分。</strong> 由于历史原因,<code>&lt;head&gt;</code>之前的空格和换行符均被忽略。 如果我们在<code>&lt;/body&gt;</code>之后放置一些东西，那么它会被自动移动到<code>body</code>内，并处于<code>body</code>中的最下方，因为HTML规范要求所有内容必须位于<code>&lt;body&gt;</code>内。 <strong>所以<code>&lt;/body&gt;</code>之后不能有空格。</strong> <strong>字符串开头&#x2F;结尾处的空格，以及只有空格的文本节点，通常会被工具隐藏</strong> 与DOM一起使用的浏览器工具通常不会在文本的开始&#x2F;结尾显示空格，并且在标签之间也不会显示空文本节点（换行符）。</p></li><li><p><strong>注释</strong></p></li></ol><hr><p><strong>HTML中的所有内容，甚至注释，都会成为DOM的一部分。</strong> 注释会被标记为 comment node</p><hr><p>事件：就是用户和浏览器之间的交互行为 比如点击按钮，鼠标移动，关闭窗口等</p><p>可以在事件对应的属性中设置 js 代码，当事件被触发时，代码会被执行 所以可以通过对对应事件来绑定处理函数从而响应事件，当事件被触发时，函数会被调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取按钮对象</span></span><br><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line"><span class="comment">// 绑定一个单击事件</span></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为页面的加载是自上而下的，所以 script 标签如果想要运行，必须放到 body 里的标签的下面。 所以想要将 script 标签继续放在 head 里，则需要添加一个 onload 事件，从而使响应函数在页面加载完成之后再执行 这样可以保证代码执行时所有的 DOM 对象都已经加载完成了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  xxxx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-2-bom-简介"><a href="#2-2-bom-简介" class="headerlink" title="2.2 bom 简介"></a>2.2 bom 简介</h2><p>浏览器对象模型（Browser Object Model），简称 BOM，表示由浏览器（主机环境）提供的用于处理文档（document）之外的所有内容的其他对象。</p><p>例如：</p><ul><li><code>navigator</code>对象提供了有关浏览器和操作系统的背景信息。navigator 有许多属性，但是最广为人知的两个属性是：<code>navigator.userAgent</code>—关于当前浏览器，<code>navigator.platform</code>—关于平台（可以帮助区分 Windows&#x2F;Linux&#x2F;Mac 等）。</li><li><code>location</code>对象允许我们读取当前<code>URL</code>，并且可以将浏览器重定向到新的<code>URL</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(location.<span class="property">href</span>); <span class="comment">// 显示当前 URL</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">confirm</span>(<span class="string">&quot;Go to Wikipedia?&quot;</span>)) &#123;</span><br><span class="line">  location.<span class="property">href</span> = <span class="string">&quot;https://wikipedia.org&quot;</span>; <span class="comment">// 将浏览器重定向到另一个 URL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数<code>alert/confirm/prompt</code>也是<strong>BOM</strong>的一部分：它们与文档（document）没有直接关系，但它代表了与用户通信的纯浏览器方法。</p><h2 id="2-3-规范"><a href="#2-3-规范" class="headerlink" title="2.3 规范"></a>2.3 规范</h2><p><strong>DOM 规范</strong> 描述文档的结构、操作和事件，详见 <a href="https://dom.spec.whatwg.org/">DOM规范</a>。 CSSOM 规范 描述样式表和样式规则，对它们进行的操作，以及它们与文档的绑定，<a href="https://www.w3.org/TR/cssom-1/">CSSOM规范</a>。 <strong>HTML 规范</strong> 描述 HTML 语言（例如标签）以及 BOM（浏览器对象模型）— 各种浏览器函数：setTimeout,alert,location等，详见<a href="https://html.spec.whatwg.org/">HTML规范</a>。它采用了 DOM 规范，并使用了许多其他属性和方法对其进行了扩展。 此外，某些类被分别描述在 <a href="https://spec.whatwg.org/"></a>。</p><h2 id="2-4-浏览器开发工具"><a href="#2-4-浏览器开发工具" class="headerlink" title="2.4 浏览器开发工具"></a>2.4 浏览器开发工具</h2><p>开发者工具中的 DOM 结构是经过简化的。文本节点仅以文本形式显示。并且根本没有“空白”（只有空格）的文本节点。这其实挺好，因为大多数情况下，我们只关心元素节点。 点击左上角的按钮可以让我们使用鼠标（或其他指针设备）从网页中选择一个节点并“检查（inspect）”它（在元素选项卡中滚动到该节点）。当我们有一个巨大的HTML页面（和相应的巨大 DOM），并希望查看其中的一个特定元素的位置时，这很有用。 另一种方法是在网页上右键单击，然后在上下文菜单中选择“检查（Inspect）”。</p><ul><li><strong>Styles</strong> — 我们可以看到按规则应用于当前元素的CSS规则，包括内建规则（灰色）。几乎所有内容都可以就地编辑，包括下面的方框的dimension&#x2F;margin&#x2F;padding。</li><li><strong>Computed</strong> — 按属性查看应用于元素的 CSS：对于每个属性，我们可以都可以看到赋予它的规则（包括CSS继承等）。</li><li><strong>Event Listeners</strong> — 查看附加到 DOM 元素的事件侦听器。</li></ul><p>当然，在浏览器开发工具中，还能够通过与控制台交互来给页面中的元素添加一些js代码和命令。 <code>console.log(elem)</code> 显示元素的 DOM 树。 <code>console.dir(elem)</code> 将元素显示为 DOM 对象，非常适合探索其属性。</p><h1 id="三、dom学习"><a href="#三、dom学习" class="headerlink" title="三、dom学习"></a>三、dom学习</h1><h2 id="3-1-dom的遍历"><a href="#3-1-dom的遍历" class="headerlink" title="3.1 dom的遍历"></a>3.1 dom的遍历</h2><h3 id="3-1-1-顶部节点"><a href="#3-1-1-顶部节点" class="headerlink" title="3.1.1 顶部节点"></a>3.1.1 顶部节点</h3><p>最顶层的树节点可以直接作为 document 的属性来使用： <code>&lt;html&gt; = document.documentElement</code> 最顶层的document节点是<code>document.documentElement</code>。这是对应<code>&lt;html&gt;</code>标签的DOM节点。 <code>&lt;body&gt; = document.body</code> -<code>&lt;body&gt;</code>元素 <code>&lt;head&gt; = document.head</code> -<code>&lt;head&gt;</code>元素 脚本无法访问在运行时不存在的元素。 尤其是，如果一个脚本是在<code>&lt;head&gt;</code>中，那么脚本是访问不到<code>document.body</code>元素的，因为浏览器还没有读到它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">alert</span>( <span class="string">&quot;From HEAD: &quot;</span> + <span class="variable language_">document</span>.<span class="property">body</span> ); <span class="comment">// null，这里目前还没有 &lt;body&gt;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">alert</span>( <span class="string">&quot;From BODY: &quot;</span> + <span class="variable language_">document</span>.<span class="property">body</span> ); <span class="comment">// HTMLBodyElement，现在存在了</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><hr><p>在 DOM 中，null 值就意味着“不存在”或者“没有这个节点”。</p><hr><h3 id="3-1-2-子节点"><a href="#3-1-2-子节点" class="headerlink" title="3.1.2 子节点"></a>3.1.2 子节点</h3><p>子节点 — 对应的是直系的子元素。换句话说，它们被完全嵌套在给定的元素中。例如，<code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>就是<code>&lt;html&gt;</code>元素的子元素。 子孙元素 — 嵌套在给定元素中的所有元素，包括子元素，以及子元素的子元素等。</p><p><code>childNodes</code>属性会获取包括文本节点在内的所有节点，包括<strong>文字节点</strong> <code>firstChild</code>获取当前节点的第一个子节点 <code>lastChild</code>获取当前节点的最后一个子节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elem.<span class="property">childNodes</span>[<span class="number">0</span>] === elem.<span class="property">firstChild</span></span><br><span class="line">elem.<span class="property">childNodes</span>[elem.<span class="property">childNodes</span>.<span class="property">length</span> - <span class="number">1</span>] === elem.<span class="property">lastChild</span></span><br></pre></td></tr></table></figure><p>这里还有一个特别的函数<code>elem.hasChildNodes()</code>用于检查节点是否有子节点。</p><p><code>childNodes</code>看起来就像一个数组。但实际上它并不是一个数组，而是一个<strong>集合</strong>— 一个类数组的可迭代对象。</p><ul><li>可以使用for…of来迭代</li><li>无法使用数组的方法，因为他不是一个数组 如果我们想要使用数组的方法的话，我们可以使用<code>Array.from</code>方法来从集合创建一个“真”数组：</li></ul><p><strong>DOM 集合是只读的</strong> <strong>DOM 集合是实时的</strong> <strong>不要使用 for..in 来遍历集合</strong></p><h3 id="3-1-3-兄弟节点和父节点"><a href="#3-1-3-兄弟节点和父节点" class="headerlink" title="3.1.3 兄弟节点和父节点"></a>3.1.3 兄弟节点和父节点</h3><p><strong>兄弟节点（Sibling）</strong> 是指有同一个父节点的节点。 下一个兄弟节点在<code>nextSibling</code>属性中，上一个是在<code>previousSibling</code>属性中。 可以通过<code>parentNode</code>来访问父节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;body&gt; 的父节点是 &lt;html&gt;</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">parentNode</span> === <span class="variable language_">document</span>.<span class="property">documentElement</span> ); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// &lt;head&gt; 的后一个是 &lt;body&gt;</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="variable language_">document</span>.<span class="property">head</span>.<span class="property">nextSibling</span> ); <span class="comment">// HTMLBodyElement</span></span><br><span class="line"><span class="comment">// &lt;body&gt; 的前一个是 &lt;head&gt;</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">previousSibling</span> ); <span class="comment">// HTMLHeadElement</span></span><br></pre></td></tr></table></figure><h3 id="3-1-4-纯元素导航"><a href="#3-1-4-纯元素导航" class="headerlink" title="3.1.4 纯元素导航"></a>3.1.4 纯元素导航</h3><p>上面列出的导航（navigation）属性引用<strong>所有</strong>节点。例如，在<strong>childNodes</strong>中我们可以看到文本节点，元素节点，甚至包括注释节点（如果它们存在的话）。 但是对于很多任务来说，我们并不想要文本节点或注释节点。我们希望操纵的是代表标签的和形成页面结构的元素节点。 所以，让我们看看更多只考虑<strong>元素节点</strong>的导航链接（navigation link） 这些链接和我们在上面提到过的类似，只是在词中间加了 Element：</p><ul><li><code>children</code> — 仅那些作为元素节点的子代的节点。</li><li><code>firstElementChild</code>，<code>lastElementChild</code> — 第一个和最后一个子元素。</li><li><code>previousElementSibling</code>，<code>nextElementSibling</code> — 兄弟元素。</li><li><code>parentElement</code> — 父元素。</li></ul><p>parentElement 属性返回的是“元素类型”的父节点，而 parentNode 返回的是“任何类型”的父节点。这些属性通常来说是一样的：它们都是用于获取父节点。 唯一的例外就是 <strong>document.documentElement</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">parentNode</span> ); <span class="comment">// document</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">parentElement</span> ); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><h3 id="3-1-5-表格"><a href="#3-1-5-表格" class="headerlink" title="3.1.5 表格"></a>3.1.5 表格</h3><p>表格（Table）是一个很好的例子，它代表了一个特别重要的情况：</p><p><code>&lt;table&gt;</code>元素支持(除了上面给出的，之外) 以下这些属性: <code>table.rows</code> — <code>&lt;tr&gt;</code> 元素的集合。 <code>table.caption/tHead/tFoot</code> — 引用元素 <code>&lt;caption&gt;，&lt;thead&gt;，&lt;tfoot&gt;</code>。 <code>table.tBodies</code> — <code>&lt;tbody&gt;</code>元素的集合（根据标准还有很多元素，但是这里至少会有一个 — 即使没有被写在HTML源文件中，浏览器也会将其放入DOM中）。 <code>&lt;thead&gt;，&lt;tfoot&gt;，&lt;tbody&gt;</code> 元素提供了 rows 属性： <code>tbody.rows</code> — 表格内部<code>&lt;tr&gt;</code>元素的集合。 <code>&lt;tr&gt;</code>： <code>tr.cells</code> — 在给定 <code>&lt;tr&gt;</code> 中的 <code>&lt;td&gt;</code> 和 <code>&lt;th&gt;</code> 单元格的集合。 <code>tr.sectionRowIndex</code> — 给定的 <code>&lt;tr&gt;</code> 在封闭的 <code>&lt;thead&gt;/&lt;tbody&gt;/&lt;tfoot&gt;</code> 中的位置（索引）。 <code>tr.rowIndex</code> — 在整个表格中 <code>&lt;tr&gt;</code> 的编号（包括表格的所有行）。 <code>&lt;td&gt; 和 &lt;th&gt;</code>： <code>td.cellIndex</code> — 在封闭的 <code>&lt;tr&gt;</code>中单元格的编号。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">&quot;table&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>one<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>two<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>three<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>four<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 获取带有 &quot;two&quot; 的 td（第一行，第二列）</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> td = table.<span class="property">rows</span>[<span class="number">0</span>].<span class="property">cells</span>[<span class="number">1</span>];</span></span><br><span class="line"><span class="language-javascript">  td.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;red&quot;</span>; <span class="comment">// highlight it</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-2-搜索"><a href="#3-2-搜索" class="headerlink" title="3.2 搜索"></a>3.2 搜索</h2><h3 id="3-2-1-getElementsBy"><a href="#3-2-1-getElementsBy" class="headerlink" title="3.2.1 getElementsBy*"></a>3.2.1 getElementsBy*</h3><p>通过<strong>document</strong>对象调用获取元素节点 <strong>只有<code>document.getElementById</code>，没有<code>anyElem.getElementById</code></strong> getElementById() 通过 id 属性获取一个元素节点对象 getElementById方法只能被在document对象上调用。它会在整个文档中查找给定的id。</p><ol><li>document.getElementsByTagName() 通过标签名获取一组元素节点对象 这个会返回一个类数组对象，会将所有返回的内容封装到一个对象中，即使其只有一个</li><li>document.getElementsByName() 通过 name 属性获取一组元素节点对象</li></ol><p><code>elem.getElementsByClassName(className)</code>返回具有给定CSS类的元素。</p><p>所有的 “getElementsBy*“ 方法都会返回一个 <strong>实时的（live）</strong> 集合。这样的集合始终反映的是文档的当前状态，并且在文档发生更改时会“自动更新”。 相反，querySelectorAll 返回的是一个 <strong>静态的</strong> 集合。就像元素的固定数组。</p><h3 id="3-2-2-elem-querySelector"><a href="#3-2-2-elem-querySelector" class="headerlink" title="3.2.2 elem.querySelector*"></a>3.2.2 elem.querySelector*</h3><p>最常用的方法： <code>elem.querySelectorAll(css)</code>返回<strong>elem</strong>中与给定<strong>CSS</strong>选择器匹配的所有元素。 在这里，我们查找所有为最后一个子元素的<code>&lt;li&gt;</code>元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>The<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>test<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>has<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>passed<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> elements = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;ul &gt; li:last-child&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> elements) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(elem.<span class="property">innerHTML</span>); <span class="comment">// &quot;test&quot;, &quot;passed&quot;</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS选择器的伪类，例如 :hover 和 :active 也都是被支持的。例如，<code>document.querySelectorAll(&#39;:hover&#39;)</code> 将会返回鼠标指针正处于其上方的元素的集合（按嵌套顺序：从最外层 <code>&lt;html&gt;</code> 到嵌套最多的元素）。</p><p><code>elem.querySelector(css)</code>调用会返回给定CSS选择器的<strong>第一个</strong>元素。 换句话说，结果与<code>elem.querySelectorAll(css)[0]</code>相同，但是后者会查找<strong>所有</strong>元素，并从中选取一个，而<code>elem.querySelector</code>只会查找一个。因此它在速度上更快，并且写起来更短。</p><h3 id="3-2-3-matches"><a href="#3-2-3-matches" class="headerlink" title="3.2.3 matches"></a>3.2.3 matches</h3><p><code>elem.matches(css)</code>不会查找任何内容，它只会检查 elem 是否与给定的 CSS 选择器匹配。它返回 true 或 false。</p><p>当我们遍历元素（例如数组或其他内容）并试图过滤那些我们感兴趣的元素时，这个方法会很有用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com/file.zip&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://ya.ru&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 不一定是 document.body.children，还可以是任何集合</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">children</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// $=是以xxx结尾的意思，这里的意思是以zip结尾</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (elem.<span class="title function_">matches</span>(<span class="string">&#x27;a[href$=&quot;zip&quot;]&#x27;</span>)) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">alert</span>(<span class="string">&quot;The archive reference: &quot;</span> + elem.<span class="property">href</span> );</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-4-closest"><a href="#3-2-4-closest" class="headerlink" title="3.2.4 closest"></a>3.2.4 closest</h3><p>元素的祖先（ancestor）是：父级，父级的父级，它的父级等。祖先们一起组成了从元素到顶端的父级链。 <code>elem.closest(css)</code>方法会查找与 CSS 选择器匹配的最近的祖先。elem 自己也会被搜索。 换句话说，方法<code>closest</code>在元素中得到了提升，并检查每个父级。如果它与选择器匹配，则停止搜索并返回该祖先。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Contents<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;contents&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;book&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;chapter&quot;</span>&gt;</span>Chapter 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;chapter&quot;</span>&gt;</span>Chapter 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> chapter = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.chapter&#x27;</span>); <span class="comment">// LI</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(chapter.<span class="title function_">closest</span>(<span class="string">&#x27;.book&#x27;</span>)); <span class="comment">// UL</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(chapter.<span class="title function_">closest</span>(<span class="string">&#x27;.contents&#x27;</span>)); <span class="comment">// DIV</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(chapter.<span class="title function_">closest</span>(<span class="string">&#x27;h1&#x27;</span>)); <span class="comment">// null（因为 h1 不是祖先）</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-5-总结"><a href="#3-2-5-总结" class="headerlink" title="3.2.5 总结"></a>3.2.5 总结</h3><p>方法名</p><p>搜索方式</p><p>可以在元素上调用？</p><p>实时的？</p><p>querySelector</p><p>CSS-selector</p><p>✔</p><p>-</p><p>querySelectorAll</p><p>CSS-selector</p><p>✔</p><p>-</p><p>getElementById</p><p>id</p><p>-</p><p>-</p><p>getElementsByName</p><p>name</p><p>-</p><p>✔</p><p>getElementsByTagName</p><p>tag or ‘*‘</p><p>✔</p><p>✔</p><p>getElementsByClassName</p><p>class</p><p>✔</p><p>✔</p><p>用来检查子级与父级之间关系的方法： 如果 elemB 在 elemA 内（elemA 的后代）或者 elemA&#x3D;&#x3D;elemB，elemA.contains(elemB) 将返回 true。</p><h2 id="3-3-节点属性"><a href="#3-3-节点属性" class="headerlink" title="3.3 节点属性"></a>3.3 节点属性</h2><ul><li>EventTarget — 是根的“抽象（abstract）”类。该类的对象从未被创建。它作为一个基础，以便让所有 DOM 节点都支持所谓的“事件（event）”。</li><li>Node — 也是一个“抽象”类，充当 DOM 节点的基础。它提供了树的核心功能：parentNode，nextSibling，childNodes 等（它们都是 getter）。Node 类的对象从未被创建。但是有一些继承自它的具体的节点类，例如：文本节点的 Text，元素节点的 Element，以及更多异域（exotic）类，例如注释节点的 Comment。</li><li>Element — 是 DOM 元素的基本类。它提供了元素级的导航（navigation），例如 nextElementSibling，children，以及像 getElementsByTagName 和 querySelector 这样的搜索方法。浏览器中不仅有 HTML，还会有 XML 和 SVG。Element 类充当更多特定类的基本类：SVGElement，XMLElement 和 HTMLElement。</li><li>HTMLElement — 最终是所有 HTML 元素的基本类。各种 HTML 元素均继承自它：<ul><li>HTMLInputElement — <code>&lt;input&gt;</code> 元素的类，</li><li>HTMLBodyElement —<code>&lt;body&gt;</code> 元素的类，</li><li>HTMLAnchorElement — <code>&lt;a&gt;</code> 元素的类，</li></ul></li></ul><p>还有很多其他标签具有自己的类，可能还具有特定的属性和方法，而一些元素，如 <code>&lt;span&gt;、&lt;section&gt;、&lt;article&gt;</code> 等，没有任何特定的属性，所以它们是 HTMLElement 类的实例。</p><p><strong>给定节点的全部属性和方法都是继承的结果。</strong></p><ul><li>HTMLInputElement — 该类提供特定于输入的属性，</li><li>HTMLElement — 它提供了通用（common）的 HTML 元素方法（以及 getter 和 setter）</li><li>Element — 提供通用（generic）元素方法，</li><li>Node — 提供通用 DOM 节点属性，</li><li>EventTarget — 为事件（包括事件本身）提供支持，</li><li>……最后，它继承自 Object，因为像 hasOwnProperty 这样的“普通对象”方法也是可用的。</li></ul><p>可以通过回调来查看 DOM 节点类名,<strong>constructor.name</strong> 就是它的名称 <code>alert( document.body.constructor.name ); // HTMLBodyElement</code> 或者可以使用<strong>toString</strong>方法 可以使用 <strong>instanceof</strong> 来检查继承：</p><p>在规范中，DOM 类不是使用 JavaScript 来描述的，而是一种特殊的 <strong>接口描述语言</strong>（Interface description language），简写为 <strong>IDL</strong>，它通常很容易理解。 在 IDL 中，所有属性以其类型开头。例如，DOMString 和 boolean 等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 HTMLInputElement</span></span><br><span class="line"><span class="comment">// 冒号 &quot;:&quot; 表示 HTMLInputElement 继承自 HTMLElement</span></span><br><span class="line">interface <span class="title class_">HTMLInputElement</span>: <span class="title class_">HTMLElement</span> &#123;</span><br><span class="line">  <span class="comment">// 接下来是 &lt;input&gt; 元素的属性和方法</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// &quot;DOMString&quot; 表示属性的值是字符串</span></span><br><span class="line">  attribute <span class="title class_">DOMString</span> accept;</span><br><span class="line">  attribute <span class="title class_">DOMString</span> alt;</span><br><span class="line">  attribute <span class="title class_">DOMString</span> autocomplete;</span><br><span class="line">  attribute <span class="title class_">DOMString</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 布尔值属性（true/false）</span></span><br><span class="line">  attribute boolean autofocus;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 现在方法：&quot;void&quot; 表示方法没有返回值</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">select</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-1-nodetype"><a href="#3-3-1-nodetype" class="headerlink" title="3.3.1 nodetype"></a>3.3.1 nodetype</h3><p>nodeType属性时一种古老的用来获取DOM节点类型的方法 它有一个数值型值（numeric value）： 对于元素节点 elem.nodeType &#x3D;&#x3D; 1， 对于文本节点 elem.nodeType &#x3D;&#x3D; 3， 对于 document 对象 elem.nodeType &#x3D;&#x3D; 9， 在 规范 中还有一些其他值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> elem = <span class="variable language_">document</span>.<span class="property">body</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 让我们检查一下它是什么？</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(elem.<span class="property">nodeType</span>); <span class="comment">// 1 =&gt; element</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 第一个子节点是</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(elem.<span class="property">firstChild</span>.<span class="property">nodeType</span>); <span class="comment">// 3 =&gt; text</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 对于 document 对象，类型是 9</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>( <span class="variable language_">document</span>.<span class="property">nodeType</span> ); <span class="comment">// 9</span></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在现代脚本中，我们可以使用<strong>instanceof</strong>和其他基于类的检查方法来查看节点类型，但有时 nodeType 可能更简单。我们只能读取 nodeType 而不能修改它。</p><h3 id="3-3-2-标签"><a href="#3-3-2-标签" class="headerlink" title="3.3.2 标签"></a>3.3.2 标签</h3><p>给定一个 DOM 节点，我们可以从 <strong>nodeName</strong> 或者 <strong>tagName</strong> 属性中读取它的标签名：</p><ul><li>tagName 属性仅适用于 Element 节点。</li><li>nodeName 是为任意 Node 定义的：<ul><li>对于元素，它的意义与 tagName 相同。</li><li>对于其他节点类型（text，comment 等），它拥有一个对应节点类型的字符串。</li></ul></li></ul><p>tagName仅受<strong>元素节点</strong>支持（因为它起源于Element类），而nodeName则可以说明其他节点类型。</p><p><strong>标签名称始终是大写的，除非是在 XML 模式下</strong></p><h3 id="3-3-3-内容-innerHTML"><a href="#3-3-3-内容-innerHTML" class="headerlink" title="3.3.3 内容 innerHTML"></a>3.3.3 内容 innerHTML</h3><p>innerHTML 属性允许将元素中的 HTML 获取为字符串形式。 我们也可以修改它。因此，它是更改页面最有效的方法之一。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>A div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>( <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> ); <span class="comment">// 读取当前内容</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;The new BODY!&#x27;</span>; <span class="comment">// 替换它</span></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 输出显示 The new BODY! ，通过innerHTML修改了页面内容--&gt;</span></span><br></pre></td></tr></table></figure><p>如果 innerHTML 将一个<code>&lt;script&gt;</code>标签插入到 document 中 — 它会成为 HTML 的一部分，但是不会执行。</p><p>可以使用<code>elem.innerHTML+=&quot;more html&quot;</code>将 HTML 附加到元素上。 但是这是一种非常危险的方法，因为它会先将旧的内容删除，再写入新的内容，所以会产生重新加载等问题，使用需要谨慎。</p><h3 id="3-3-4-元素的完整HTML"><a href="#3-3-4-元素的完整HTML" class="headerlink" title="3.3.4 元素的完整HTML"></a>3.3.4 元素的完整HTML</h3><p>outerHTML 属性包含了元素的完整 HTML。就像 innerHTML 加上元素本身一样。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;elem&quot;</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">b</span>&gt;</span>World<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">  alert(elem.outerHTML); // <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;elem&quot;</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">b</span>&gt;</span>World<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>与 innerHTML 不同，写入 outerHTML 不会改变元素。而是在 DOM 中替换它。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 使用 &lt;p&gt;...&lt;/p&gt; 替换 div.outerHTML</span></span></span><br><span class="line"><span class="language-javascript">  div.<span class="property">outerHTML</span> = <span class="string">&#x27;&lt;p&gt;A new element&lt;/p&gt;&#x27;</span>; <span class="comment">// (*)</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 蛤！&#x27;div&#x27; 还是原来那样！</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(div.<span class="property">outerHTML</span>); <span class="comment">// &lt;div&gt;Hello, world!&lt;/div&gt; (**)</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>谨慎谨慎再谨慎！！！</strong></p><h3 id="3-3-5-文本节点内容"><a href="#3-3-5-文本节点内容" class="headerlink" title="3.3.5 文本节点内容"></a>3.3.5 文本节点内容</h3><p>innerHTML 属性仅对元素节点有效。 其他节点类型，例如文本节点，具有它们的对应项：<strong>nodeValue</strong> 和<strong>data</strong>属性。这两者在实际使用中几乎相同，只有细微规范上的差异。因此，我们将使用 data，因为它更短。 读取文本节点和注释节点的内容的示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  Hello</span><br><span class="line">  <span class="comment">&lt;!-- Comment --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> text = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(text.<span class="property">data</span>); <span class="comment">// Hello</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> comment = text.<span class="property">nextSibling</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(comment.<span class="property">data</span>); <span class="comment">// Comment</span></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>textContent</strong> 提供了对元素内的文本的访问权限：仅文本，去掉所有<code>&lt;tags&gt;</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;news&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Headline!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Martians attack people!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// Headline! Martians attack people!</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(news.<span class="property">textContent</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>写入 textContent 要有用得多，因为它允许以“安全方式”写入文本。</strong></p><h3 id="3-3-6-更多属性"><a href="#3-3-6-更多属性" class="headerlink" title="3.3.6 更多属性"></a>3.3.6 更多属性</h3><p>“hidden” 特性（attribute）和 DOM 属性（property）指定元素是否可见。 从技术上来说，hidden 与 style&#x3D;”display:none” 做的是相同的事。但 hidden 写法更简洁。 这里有一个 blinking 元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;elem&quot;</span>&gt;</span>A blinking element<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> elem.<span class="property">hidden</span> = !elem.<span class="property">hidden</span>, <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>value — <code>&lt;input&gt;，&lt;select&gt; 和 &lt;textarea&gt;</code>（HTMLInputElement，HTMLSelectElement……）的 value。</p></li><li><p>href — <code>&lt;a href=&quot;...&quot;&gt;</code>（HTMLAnchorElement）的 href。</p></li><li><p>id — 所有元素（HTMLElement）的 “id” 特性（attribute）的值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;elem&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">alert</span>(elem.<span class="property">type</span>); <span class="comment">// &quot;text&quot;</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">alert</span>(elem.<span class="property">id</span>); <span class="comment">// &quot;elem&quot;</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">alert</span>(elem.<span class="property">value</span>); <span class="comment">// value</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="3-4-特性和属性-attributes-amp-properties"><a href="#3-4-特性和属性-attributes-amp-properties" class="headerlink" title="3.4 特性和属性(attributes &amp; properties)"></a>3.4 特性和属性(attributes &amp; properties)</h2><p>当浏览器加载页面时，它会“读取”（或者称之为：“解析”）HTML 并从中生成 DOM 对象。对于元素节点，大多数标准的 HTML 特性（attributes）会自动变成 DOM 对象的属性（properties）。 attribute 和 property 两词意思相近，为作区分，全文将 attribute 译为“特性”，property 译为“属性”。</p><h3 id="3-4-1-DOM属性"><a href="#3-4-1-DOM属性" class="headerlink" title="3.4.1 DOM属性"></a>3.4.1 DOM属性</h3><p>DOM 节点是常规的 JavaScript 对象。我们可以 alert 它们。 <strong>可以创建新的属性</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">myData</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Caesar&#x27;</span>,</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;Imperator&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">myData</span>.<span class="property">title</span>); <span class="comment">// Imperator</span></span><br></pre></td></tr></table></figure><p><strong>可以添加新的方法</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">sayTagName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">tagName</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">sayTagName</span>(); <span class="comment">// BODY（这个方法中的 &quot;this&quot; 的值是 document.body）</span></span><br></pre></td></tr></table></figure><p><strong>可以修改内建属性的原型</strong>，例如修改 Element.prototype 为所有元素添加一个新方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Element</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">`Hello, I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.tagName&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">sayHi</span>(); <span class="comment">// Hello, I&#x27;m HTML</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">sayHi</span>(); <span class="comment">// Hello, I&#x27;m BODY</span></span><br></pre></td></tr></table></figure><p>DOM 属性和方法的行为就像常规的 Javascript 对象一样：</p><ul><li>它们可以有很多值。</li><li>它们是大小写敏感的（要写成 elem.nodeType，而不是 elem.NoDeTyPe）。</li><li>DOM属性是多类型的，其大部分属性都是字符串类型，但也存在个例.<ul><li><p><code>input.checked</code>属性是Boolean型</p></li><li><p><code>style</code>特性是字符串类型，但其属性是一个对象</p></li><li><p><code>href</code>的属性一直是一个完整的URL，即使该特性包含一个相对路径或者包含一个 #hash。</p><h3 id="3-4-2-HTML特性"><a href="#3-4-2-HTML特性" class="headerlink" title="3.4.2 HTML特性"></a>3.4.2 HTML特性</h3><p>在HTML中，标签可能拥有特性（attributes）。当浏览器解析HTML文本，并根据标签创建DOM对象时，浏览器会辨别<strong>标准的</strong>特性并以此创建DOM属性。 所以，当一个元素有id或其他<strong>标准的</strong>特性，那么就会生成对应的DOM属性。但是<strong>非标准</strong>的特性则不会。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">something</span>=<span class="string">&quot;non-standard&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">id</span>); <span class="comment">// test</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 非标准的特性没有获得对应的属性</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">something</span>); <span class="comment">// undefined</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>一个元素的标准的特性对于另一个元素可能是未知的。</strong> “type” 是<code>&lt;input&gt;</code>的一个标准的特性（HTMLInputElement），但对于<code>&lt;body&gt;</code>（HTMLBodyElement）来说则不是。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">id</span>=<span class="string">&quot;body&quot;</span> <span class="attr">type</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">alert</span>(input.<span class="property">type</span>); <span class="comment">// text</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">alert</span>(body.<span class="property">type</span>); <span class="comment">// undefined：DOM 属性没有被创建，因为它不是一个标准的特性</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>所有特性都可以通过使用以下方法进行访问：</p><ul><li><code>elem.hasAttribute(name)</code> — 检查特性是否存在。</li><li><code>elem.getAttribute(name)</code> — 获取这个特性值。</li><li><code>elem.setAttribute(name, value)</code> — 设置这个特性值。</li><li><code>elem.removeAttribute(name)</code> — 移除这个特性。</li><li><code>elem.attributes</code> 读取所有特性：属于内建 Attr 类的对象的集合，具有 name 和 value 属性。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">something</span>=<span class="string">&quot;non-standard&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;something&#x27;</span>)); <span class="comment">// 非标准的</span></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>HTML 特性有以下几个特征：</p><ul><li>它们的名字是大小写不敏感的（id 与 ID 相同）。</li><li>它们的值总是字符串类型的。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;elem&quot;</span> <span class="attr">about</span>=<span class="string">&quot;Elephant&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>( elem.<span class="title function_">getAttribute</span>(<span class="string">&#x27;About&#x27;</span>) ); <span class="comment">// (1) &#x27;Elephant&#x27;，读取</span></span></span><br><span class="line"><span class="language-javascript">    elem.<span class="title function_">setAttribute</span>(<span class="string">&#x27;Test&#x27;</span>, <span class="number">123</span>); <span class="comment">// (2) 写入</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>( elem.<span class="property">outerHTML</span> ); <span class="comment">// (3) 查看特性是否在 HTML 中（在）</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> attr <span class="keyword">of</span> elem.<span class="property">attributes</span>) &#123; <span class="comment">// (4) 列出所有</span></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">alert</span>( <span class="string">`<span class="subst">$&#123;attr.name&#125;</span> = <span class="subst">$&#123;attr.value&#125;</span>`</span> );</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>getAttribute(‘About’) — 这里的第一个字母是大写的，但是在 HTML 中，它们都是小写的。但这没有影响：特性的名称是大小写不敏感的。</li><li>我们可以将任何东西赋值给特性，但是这些东西会变成字符串类型的。所以这里我们的值为 “123”。</li><li>所有特性，包括我们设置的那个特性，在 outerHTML 中都是可见的。</li><li>attributes 集合是可迭代对象，该对象将所有元素的特性（标准和非标准的）作为 name 和 value 属性存储在对象中。</li></ol><h3 id="3-4-3-属性、特性同步"><a href="#3-4-3-属性、特性同步" class="headerlink" title="3.4.3 属性、特性同步"></a>3.4.3 属性、特性同步</h3><p>当一个标准的特性被改变，对应的属性也会自动更新，（除了几个特例）反之亦然。</p><p><code>input.value</code>只能从特性同步到属性，反过来则不行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 特性 =&gt; 属性</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  input.<span class="title function_">setAttribute</span>(<span class="string">&#x27;value&#x27;</span>, <span class="string">&#x27;text&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">alert</span>(input.<span class="property">value</span>); <span class="comment">// text</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 这个操作无效，属性 =&gt; 特性</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  input.<span class="property">value</span> = <span class="string">&#x27;newValue&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">alert</span>(input.<span class="title function_">getAttribute</span>(<span class="string">&#x27;value&#x27;</span>)); <span class="comment">// text（没有被更新！）</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>改变特性值value会更新属性。</li><li>但是属性的更改不会影响特性。</li></ul><h3 id="3-4-4-非标准属性，dataset"><a href="#3-4-4-非标准属性，dataset" class="headerlink" title="3.4.4 非标准属性，dataset"></a>3.4.4 非标准属性，dataset</h3><p>非标准的特性常常用于将自定义的数据从 HTML 传递到 JavaScript，或者用于为 JavaScript “标记” HTML 元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 标记这个 div 以在这显示 &quot;name&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">show-info</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 标记这个 div 以在这显示 &quot;age&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">show-info</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 这段代码找到带有标记的元素，并显示需要的内容</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> user = &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">age</span>: <span class="number">25</span></span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">for</span>(<span class="keyword">let</span> div <span class="keyword">of</span> <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;[show-info]&#x27;</span>)) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 在字段中插入相应的信息</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> field = div.<span class="title function_">getAttribute</span>(<span class="string">&#x27;show-info&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    div.<span class="property">innerHTML</span> = user[field]; <span class="comment">// 首先 &quot;name&quot; 变为 Pete，然后 &quot;age&quot; 变为 25</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>所有以 “data-” 开头的特性均被保留供程序员使用。它们可在 dataset 属性中使用。</strong> 例如，如果一个elem有一个名为 “data-about” 的特性，那么可以通过<code>elem.dataset.about</code>取到它。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">data-about</span>=<span class="string">&quot;Elephants&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">dataset</span>.<span class="property">about</span>); <span class="comment">// Elephants</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>像<code>data-order-state</code>这样的多词特性可以以驼峰式进行调用：<code>dataset.orderState</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.order</span><span class="selector-attr">[data-order-state=<span class="string">&quot;new&quot;</span>]</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: green;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.order</span><span class="selector-attr">[data-order-state=<span class="string">&quot;pending&quot;</span>]</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.order</span><span class="selector-attr">[data-order-state=<span class="string">&quot;canceled&quot;</span>]</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;order&quot;</span> <span class="attr">class</span>=<span class="string">&quot;order&quot;</span> <span class="attr">data-order-state</span>=<span class="string">&quot;new&quot;</span>&gt;</span></span><br><span class="line">  A new order.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 读取</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(order.<span class="property">dataset</span>.<span class="property">orderState</span>); <span class="comment">// new</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 修改</span></span></span><br><span class="line"><span class="language-javascript">  order.<span class="property">dataset</span>.<span class="property">orderState</span> = <span class="string">&quot;pending&quot;</span>; <span class="comment">// (*)</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//这里的输出会是蓝色</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>data-*</code>特性是一种合法且安全的传递自定义数据的方式。 请注意，我们不仅可以读取数据，还可以修改数据属性（data-attributes）。然后 CSS 会更新相应的视图：在上面这个例子中的最后一行 (*) 将颜色更改为了蓝色。</p><h3 id="3-5-修改文档（document）"><a href="#3-5-修改文档（document）" class="headerlink" title="3.5 修改文档（document）"></a>3.5 修改文档（document）</h3><p>要创建 DOM 节点，这里有两种方法： <code>document.createElement(tag)</code> –&gt; 用给定的标签创建一个<strong>新元素节点（element node）</strong> <code>document.createTextNode(text)</code> –&gt; 用给定的文本创建一个<strong>文本节点</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建 &lt;div&gt; 元素</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="comment">// 2. 将元素的类设置为 &quot;alert&quot;</span></span><br><span class="line">div.<span class="property">className</span> = <span class="string">&quot;alert&quot;</span>;</span><br><span class="line"><span class="comment">// 3. 填充消息内容</span></span><br><span class="line">div.<span class="property">innerHTML</span> = <span class="string">&quot;&lt;strong&gt;Hi there!&lt;/strong&gt; You&#x27;ve read an important message.&quot;</span>;</span><br></pre></td></tr></table></figure><p>通过这个方法，已经创建了元素，但是它目前在名为div的变量内，尚未在页面中，所以无法被看到。</p><p>如果想要使其在页面中显示出来，可以使用<code>append</code>方法 例如：<code>document.body.append(div)</code></p><p>当然，<strong>可以在其他任何元素上调用append方法</strong> 例如，通过调用<code>div.append(anotherElement)</code>，我们便可以在<code>&lt;div&gt;</code>末尾添加一些内容。</p><p>元素插入方法：</p><ul><li><code>node.append(...nodes or strings)</code> —— 在 node 末尾 插入节点或字符串，</li><li><code>node.prepend(...nodes or strings)</code> —— 在 node 开头 插入节点或字符串，</li><li><code>node.before(...nodes or strings)</code> —— 在 node 前面 插入节点或字符串，</li><li><code>node.after(...nodes or strings)</code> —— 在 node 后面 插入节点或字符串，</li><li><code>node.replaceWith(...nodes or strings)</code> —— 将 node 替换为给定的节点或字符串。</li></ul><p><strong>这些方法的参数可以是一个要插入的任意的 DOM 节点列表，或者文本字符串（会被自动转换成文本节点）。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">id</span>=<span class="string">&quot;ol&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>0<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  ol.<span class="title function_">before</span>(<span class="string">&#x27;before&#x27;</span>); <span class="comment">// 将字符串 &quot;before&quot; 插入到 &lt;ol&gt; 前面</span></span></span><br><span class="line"><span class="language-javascript">  ol.<span class="title function_">after</span>(<span class="string">&#x27;after&#x27;</span>); <span class="comment">// 将字符串 &quot;after&quot; 插入到 &lt;ol&gt; 后面</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> liFirst = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  liFirst.<span class="property">innerHTML</span> = <span class="string">&#x27;prepend&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  ol.<span class="title function_">prepend</span>(liFirst); <span class="comment">// 将 liFirst 插入到 &lt;ol&gt; 的最开始</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> liLast = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  liLast.<span class="property">innerHTML</span> = <span class="string">&#x27;append&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  ol.<span class="title function_">append</span>(liLast); <span class="comment">// 将 liLast 插入到 &lt;ol&gt; 的最末尾</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因此，最终列表将为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">id</span>=<span class="string">&quot;ol&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>prepend<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>0<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>append<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">after</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">getListContent</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> result = [];</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    li.<span class="title function_">append</span>(i);</span></span><br><span class="line"><span class="language-javascript">    result.<span class="title function_">push</span>(li);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">return</span> result;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript">ul.<span class="title function_">append</span>(...<span class="title function_">getListContent</span>()); <span class="comment">// append + &quot;...&quot; operator = friends!</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里出现了一个append(…)的方法，感觉这个方法应该是用来添加数组中内容的</p><h3 id="3-5-1-以html形式插入"><a href="#3-5-1-以html形式插入" class="headerlink" title="3.5.1 以html形式插入"></a>3.5.1 以html形式插入</h3><p>通过<code>elem.insertAdjacentHTML(where, html)</code>来插入html 该方法的第一个参数是<strong>代码字（code word）</strong>，指定相对于elem的插入位置。必须为以下之一：</p><ul><li><p><code>&quot;beforebegin&quot;</code> — 将 html 插入到 elem 前插入，</p></li><li><p><code>&quot;afterbegin&quot;</code> — 将 html 插入到 elem 开头，</p></li><li><p><code>&quot;beforeend&quot;</code> — 将 html 插入到 elem 末尾，</p></li><li><p><code>&quot;afterend&quot;</code> — 将 html 插入到 elem 后。 第二个参数是<strong>HTML字符串</strong>，该字符串会被“作为 HTML” 插入。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">div.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&#x27;beforebegin&#x27;</span>, <span class="string">&#x27;&lt;p&gt;Hello&lt;/p&gt;&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">div.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&#x27;afterend&#x27;</span>, <span class="string">&#x27;&lt;p&gt;Bye&lt;/p&gt;&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Bye<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><code>elem.insertAdjacentText(where, text)</code> — 语法一样，但是将 text 字符串“作为文本”插入而不是作为 HTML， <code>elem.insertAdjacentElement(where, elem)</code> — 语法一样，但是插入的是一个元素。 它们的存在主要是为了使语法“统一”。 实际上，大多数时候只使用<code>insertAdjacentHTML</code>。因为对于元素和文本，我们有<code>append/prepend/before/after</code>方法。它们也可以用于插入节点&#x2F;文本片段，但写起来更短。</p><h3 id="3-5-2-节点移除"><a href="#3-5-2-节点移除" class="headerlink" title="3.5.2 节点移除"></a>3.5.2 节点移除</h3><p>想要移除一个节点，可以使用<code>node.remove()</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  div.<span class="property">className</span> = <span class="string">&quot;alert&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  div.<span class="property">innerHTML</span> = <span class="string">&quot;&lt;strong&gt;Hi there!&lt;/strong&gt; You&#x27;ve read an important message.&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(div);</span></span><br><span class="line"><span class="language-javascript">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> div.<span class="title function_">remove</span>(), <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请注意：如果我们要将一个元素移动到另一个地方，则无需将其从原来的位置中删除。 <strong>所有插入方法都会自动从旧位置删除该节点。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;first&quot;</span>&gt;</span>First<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;second&quot;</span>&gt;</span>Second<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 无需调用 remove</span></span></span><br><span class="line"><span class="language-javascript">  second.<span class="title function_">after</span>(first); <span class="comment">// 获取 #second，并在其后面插入 #first</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//进行了元素交换</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-5-3-克隆节点-cloneNode"><a href="#3-5-3-克隆节点-cloneNode" class="headerlink" title="3.5.3 克隆节点(cloneNode)"></a>3.5.3 克隆节点(cloneNode)</h3><p>调用<code>elem.cloneNode(true)</code>来创建元素的一个“深”克隆 — 具有所有特性（attribute）和子元素。 如果我们调用<code>elem.cloneNode(false)</code>，那克隆就不包括子元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;alert&quot;</span> <span class="attr">id</span>=<span class="string">&quot;div&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">strong</span>&gt;</span>Hi there!<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> You&#x27;ve read an important message.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> div2 = div.<span class="title function_">cloneNode</span>(<span class="literal">true</span>); <span class="comment">// 克隆消息</span></span></span><br><span class="line"><span class="language-javascript">  div2.<span class="title function_">querySelector</span>(<span class="string">&#x27;strong&#x27;</span>).<span class="property">innerHTML</span> = <span class="string">&#x27;Bye there!&#x27;</span>; <span class="comment">// 修改克隆</span></span></span><br><span class="line"><span class="language-javascript">  div.<span class="title function_">after</span>(div2); <span class="comment">// 在已有的 div 后显示克隆</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-5-4-一些古老的方法"><a href="#3-5-4-一些古老的方法" class="headerlink" title="3.5.4 一些古老的方法"></a>3.5.4 一些古老的方法</h3><p><code>parentElem.appendChild(node)</code>将node加为parentElem的最后一个子元素。 <code>parentElem.insertBefore(node, nextSibling)</code>在parentElem的nextSibling前插入node。 <code>parentElem.replaceChild(node, oldChild)</code>将parentElem的后代中的oldChild替换为node。 <code>parentElem.removeChild(node)</code>从parentElem中删除node（假设node为parentElem的后代）。</p><p>一个非常古老的向网页添加内容的方法：<code>document.write</code> <strong>其调用时只在页面加载时工作。</strong> 要在页面加载完成之前将 HTML 附加到页面。 页面加载完成后，这样的调用将会擦除文档。多见于旧脚本。</p><h2 id="3-6-样式和类"><a href="#3-6-样式和类" class="headerlink" title="3.6 样式和类"></a>3.6 样式和类</h2><p><strong>更改类是脚本中最常见的操作之一。</strong> 对于类，引入了看起来类似的属性 “className”：elem.className 对应于 “class” 特性（attribute）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">&quot;main page&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span>); <span class="comment">// main page</span></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们对<code>elem.className</code>进行赋值，它将<strong>替换</strong>类中的<strong>整个字符串</strong>。有时，这正是我们所需要的，但通常我们希望添加&#x2F;删除单个类。</p><p><code>elem.classList</code>是一个特殊的对象,它具有 add&#x2F;remove&#x2F;toggle 单个类的方法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">&quot;main page&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 添加一个 class</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;article&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span>); <span class="comment">// main page article</span></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因此，我们既可以使用<code>className</code>对完整的类字符串进行操作，也可以使用使用<code>classList</code>对单个类进行操作。我们选择什么取决于我们的需求。</p><p><code>classList</code> 的方法：</p><ul><li><code>elem.classList.add/remove(class)</code> — 添加&#x2F;移除类。</li><li><code>elem.classList.toggle(class)</code> — 如果类不存在就添加类，存在就移除它。</li><li><code>elem.classList.contains(class)</code> — 检查给定类，返回 true&#x2F;false。</li></ul><p>此外，classList 是可迭代的，因此，我们可以像下面这样列出所有类：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">&quot;main page&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">of</span> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">classList</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">alert</span>(name); <span class="comment">// main，然后是 page</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-6-1-元素样式"><a href="#3-6-1-元素样式" class="headerlink" title="3.6.1 元素样式"></a>3.6.1 元素样式</h3><p>elem.style 属性是一个对象，它对应于 “style” 特性（attribute）中所写的内容。 elem.style.width&#x3D;”100px” 的效果等价于我们在 style 特性中有一个 width:100px 字符串。</p><p>对于多词（multi-word）属性，使用驼峰式 camelCase：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">background-color  =&gt; elem.style.backgroundColor</span><br><span class="line">z-index           =&gt; elem.style.zIndex</span><br><span class="line">border-left-width =&gt; elem.style.borderLeftWidth</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="title function_">prompt</span>(<span class="string">&#x27;background color?&#x27;</span>, <span class="string">&#x27;green&#x27;</span>);</span><br></pre></td></tr></table></figure><p>像<code>-moz-border-radius</code>和<code>-webkit-border-radius</code>这样的浏览器前缀属性，也遵循同样的规则： 连字符<code>-</code>表示大写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">button.<span class="property">style</span>.<span class="property">MozBorderRadius</span> = <span class="string">&#x27;5px&#x27;</span>;</span><br><span class="line">button.<span class="property">style</span>.<span class="property">WebkitBorderRadius</span> = <span class="string">&#x27;5px&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="3-6-2-重置样式属性"><a href="#3-6-2-重置样式属性" class="headerlink" title="3.6.2 重置样式属性"></a>3.6.2 重置样式属性</h3><p>有时我们想要分配一个样式属性，稍后移除它。 例如，为了隐藏一个元素，我们可以设置<code>elem.style.display = &quot;none&quot;</code>。 然后，稍后我们可能想要移除<code>style.display</code>，就像它没有被设置一样。这里不应该使用<code>delete elem.style.display</code>，而应该使用<code>elem.style.display = &quot;&quot;</code>将其赋值为空。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果我们运行这段代码，&lt;body&gt; 将会闪烁</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>; <span class="comment">// 隐藏</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;&quot;</span>, <span class="number">1000</span>); <span class="comment">// 恢复正常</span></span><br></pre></td></tr></table></figure><p>如果我们将display设置为空字符串，那么浏览器通常会应用CSS类以及内建样式，<strong>就好像根本没有这样的style属性一样</strong>。</p><p>用<code>style.cssText</code>进行完全的重写 这是一种很危险的属性，因为它会删除现有的样式再进行替换，所以很少用 可以通过设置一个特性（attribute）来实现同样的效果：<code>div.setAttribute(&#39;style&#39;, &#39;color: red...&#39;)</code>。</p><h3 id="3-6-3-计算样式getComputedStyle"><a href="#3-6-3-计算样式getComputedStyle" class="headerlink" title="3.6.3 计算样式getComputedStyle"></a>3.6.3 计算样式getComputedStyle</h3><p>style 属性仅对 “style” 特性（attribute）值起作用，而没有任何CSS级联（cascade）。 因此我们无法使用<code>elem.style</code>读取来自CSS类的任何内容。 例如，这里的 style 看不到 margin：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"> <span class="selector-tag">body</span> &#123; <span class="attribute">color</span>: red; <span class="attribute">margin</span>: <span class="number">5px</span> &#125; </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  The red text</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">color</span>); <span class="comment">// 空的</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">marginTop</span>); <span class="comment">// 空的</span></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过<code>getComputedStyle(element, [pseudo])</code>来获取元素的样式 <strong>element</strong>： 需要被读取样式值的元素 <strong>pseudo</strong>： 伪元素，例如<code>::before</code>。空字符串或无参数则意味着元素本身。</p><p>结果是一个具有样式属性的对象，像<code>elem.style</code>，但现在对于所有的 CSS 类来说都是如此</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"> <span class="selector-tag">body</span> &#123; <span class="attribute">color</span>: red; <span class="attribute">margin</span>: <span class="number">5px</span> &#125; </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> computedStyle = <span class="title function_">getComputedStyle</span>(<span class="variable language_">document</span>.<span class="property">body</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 现在我们可以读取它的 margin 和 color 了</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>( computedStyle.<span class="property">marginTop</span> ); <span class="comment">// 5px</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>( computedStyle.<span class="property">color</span> ); <span class="comment">// rgb(255, 0, 0)</span></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-7-元素大小和滚动"><a href="#3-7-元素大小和滚动" class="headerlink" title="3.7 元素大小和滚动"></a>3.7 元素大小和滚动</h2><h3 id="3-7-1-关于祖先的属性"><a href="#3-7-1-关于祖先的属性" class="headerlink" title="3.7.1 关于祖先的属性"></a>3.7.1 关于祖先的属性</h3><p><code>offsetParent</code> 定位最近的祖先：</p><ol><li>CSS 定位的（position 为 absolute，relative 或 fixed），</li><li>或 <code>&lt;td&gt;，&lt;th&gt;，&lt;table&gt;</code>，</li><li>或 <code>&lt;body&gt;</code>。</li></ol><p>属性<code>offsetLeft/offsetTop</code>提供相对于<code>offsetParent</code>左上角的 x&#x2F;y 坐标。</p><p>有以下几种情况下, <code>offsetParent</code>的值为 null： 对于未显示的元素（display:none 或者不在文档中）。 对于 <code>&lt;body&gt;</code> 与 <code>&lt;html&gt;</code>。 对于带有<code>position:fixed</code>的元素。</p><h3 id="3-7-2-关于元素本身的属性"><a href="#3-7-2-关于元素本身的属性" class="headerlink" title="3.7.2 关于元素本身的属性"></a>3.7.2 关于元素本身的属性</h3><h4 id="3-7-2-1-元素外部的属性"><a href="#3-7-2-1-元素外部的属性" class="headerlink" title="3.7.2.1 元素外部的属性"></a>3.7.2.1 元素外部的属性</h4><p><code>offsetWidth/Height</code>这两个属性是最简单的。它们提供了元素的“外部” width&#x2F;height。或者，换句话说，它的<strong>完整大小</strong>（包括边框）。 <strong>对于未显示的元素，几何属性为 0&#x2F;null</strong></p><h4 id="3-7-2-2-元素本身的属性"><a href="#3-7-2-2-元素本身的属性" class="headerlink" title="3.7.2.2 元素本身的属性"></a>3.7.2.2 元素本身的属性</h4><p>如果需要测量元素的<strong>边框</strong>(border)可以使用： <code>clientLeft</code> -&gt; 测量左边框宽度 <code>clientTop</code> -&gt; 测量上边框宽度 这些属性不是边框的 width&#x2F;height，而是<strong>内侧与外侧的相对坐标</strong>。 当文档从右到左显示（操作系统为阿拉伯语或希伯来语）时，影响就显现出来了。此时滚动条不在右边，而是在左边，此时<code>clientLeft</code>则包含了滚动条的宽度。</p><p><code>clientWidth/Height</code> 这些属性提供了元素边框内区域的大小。 它们包括了 “content width” 和 “padding”，但不包括滚动条宽度（scrollbar）。</p><p>如果这里没有 padding，那么 clientWidth&#x2F;Height 代表的就是内容区域。 即border和scrollbar（如果有）内的区域。</p><p><strong>因此，当没有 padding 时，我们可以使用 clientWidth&#x2F;clientHeight 来获取内容区域的大小。</strong></p><p><code>scrollWidth/Height</code>这些属性就像 clientWidth&#x2F;clientHeight，但它们还<strong>包括滚动（隐藏）的部分</strong>：</p><p>我们可以使用这些属性将元素展开（expand）到整个 width&#x2F;height。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将元素展开（expand）到完整的内容高度</span></span><br><span class="line">element.<span class="property">style</span>.<span class="property">height</span> = <span class="string">`<span class="subst">$&#123;element.scrollHeight&#125;</span>px`</span>;</span><br></pre></td></tr></table></figure><p><strong>所以可以用这个做展开全文吧</strong></p><p>属性<code>scrollLeft/scrollTop</code>是元素的隐藏、滚动部分的 width&#x2F;height。 <code>scrollTop</code>就是“已经滚动了多少”。 大多数几何属性是只读的，但是<code>scrollLeft/scrollTop</code>是可修改的，并且浏览器会滚动该元素。 将<code>scrollTop</code>设置为 0 或一个大的值，例如 1e9，将会使元素滚动到顶部&#x2F;底部。</p><hr><p><strong>不要直接读取CSS中的元素大小</strong></p><hr><h3 id="3-7-3-滚动"><a href="#3-7-3-滚动" class="headerlink" title="3.7.3 滚动"></a>3.7.3 滚动</h3><p>方法<code>scrollBy(x,y)</code>将页面滚动至相对于当前位置的(x, y)位置。例如，<code>scrollBy(0,10)</code>会将页面向下滚动10px。</p><p>方法<code>scrollTo(pageX,pageY)</code>将页面滚动至<strong>绝对坐标</strong>，使得可见部分的左上角具有相对于文档左上角的坐标 (pageX, pageY)。就像设置了scrollLeft&#x2F;scrollTop一样。</p><p><strong>要滚动到最开始，我们可以使用 scrollTo(0,0)。</strong> 这些方法适用于所有浏览器。</p><p><code>elem.scrollIntoView(top)</code>的调用将滚动页面以使elem可见。它有一个参数：</p><ul><li>如果 top&#x3D;true（默认值），页面滚动，使 elem 出现在窗口顶部。元素的上边缘将与窗口顶部对齐。</li><li>如果 top&#x3D;false，页面滚动，使 elem 出现在窗口底部。元素的底部边缘将与窗口底部对齐。 <code>this.scrollIntoView()</code>滚动页面，使其自身定位在窗口顶部 <code>this.scrollIntoView(false)</code>滚动页面，使其自身定位在窗口底部</li></ul><p><code>document.body.style.overflow = &quot;hidden&quot;</code> <strong>禁止滚动</strong> <code>document.body.style.overflow = &quot;&quot;</code> <strong>能够滚动</strong></p><h2 id="3-8-坐标"><a href="#3-8-坐标" class="headerlink" title="3.8 坐标"></a>3.8 坐标</h2><p>两个坐标系：</p><ol><li><strong>相对于窗口</strong> 类似于<code>position:fixed</code> 从窗口的顶部&#x2F;左侧边缘计算得出<ul><li>我们将这些坐标表示为 clientX&#x2F;clientY，当我们研究事件属性时，就会明白为什么使用这种名称来表示坐标。</li></ul></li><li><strong>相对于文档</strong> 与文档根（document root）中的<code>position:absolute</code>类似，从文档的顶部&#x2F;左侧边缘计算得出。<ul><li>我们将它们表示为 pageX&#x2F;pageY。</li></ul></li></ol><p>当页面滚动到最开始时，此时窗口的左上角恰好是文档的左上角，它们的坐标彼此相等。但是，在文档移动之后，<strong>元素的窗口相对坐标</strong>会发生变化，因为元素在窗口中移动，而<strong>元素在文档中的相对坐标</strong>保持不变。</p><p>在下图中，我们在文档中取一点，并演示了它滚动之前（左）和之后（右）的坐标：</p><p>当文档滚动了：</p><ul><li><code>pageY</code> — 元素在文档中的相对坐标保持不变，从文档顶部（现在已滚动出去）开始计算。</li><li><code>clientY</code> — 窗口相对坐标确实发生了变化（箭头变短了），因为同一个点越来越靠近窗口顶部。</li></ul><h3 id="3-8-1-元素坐标"><a href="#3-8-1-元素坐标" class="headerlink" title="3.8.1 元素坐标"></a>3.8.1 元素坐标</h3><p>方法<code>elem.getBoundingClientRect()</code>返回最小矩形的窗口坐标，该矩形将elem作为内建DOMRect类的对象。 主要的 DOMRect 属性：</p><ul><li>x&#x2F;y — 矩形原点相对于窗口的 X&#x2F;Y 坐标，</li><li>width&#x2F;height — 矩形的 width&#x2F;height（可以为负）。 此外，还有派生（derived）属性：</li><li>top&#x2F;bottom — 顶部&#x2F;底部矩形边缘的 Y 坐标，</li><li>left&#x2F;right — 左&#x2F;右矩形边缘的 X 坐标。</li></ul><p>对<code>document.elementFromPoint(x, y)</code>的调用会返回在窗口坐标 (x, y) 处嵌套最多（the most nested）的元素。</p><p>下面的代码会高亮显示并输出现在位于窗口中间的元素的标签：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> centerX = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span> / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> centerY = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span> / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> elem = <span class="variable language_">document</span>.<span class="title function_">elementFromPoint</span>(centerX, centerY);</span><br><span class="line"></span><br><span class="line">elem.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(elem.<span class="property">tagName</span>);</span><br></pre></td></tr></table></figure><p><strong>因为它使用的是窗口坐标，所以元素可能会因当前滚动位置而有所不同。</strong></p><p>对于在窗口之外的坐标，<code>elementFromPoint</code>返回<strong>null</strong></p><h3 id="3-8-2-用于“fixed”定位"><a href="#3-8-2-用于“fixed”定位" class="headerlink" title="3.8.2 用于“fixed”定位"></a>3.8.2 用于“fixed”定位</h3><p>为了显示元素附近的东西，我们可以使用<code>getBoundingClientRect</code>来获取其坐标，然后使用<code>CSS position</code>以及left&#x2F;top（或 right&#x2F;bottom）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> elem = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;coords-show-mark&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createMessageUnder</span>(<span class="params">elem, html</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建 message 元素</span></span><br><span class="line">  <span class="keyword">let</span> message = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  <span class="comment">// 在这里最好使用 CSS class 来定义样式</span></span><br><span class="line">  message.<span class="property">style</span>.<span class="property">cssText</span> = <span class="string">&quot;position:fixed; color: red&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配坐标，不要忘记 &quot;px&quot;！</span></span><br><span class="line">  <span class="keyword">let</span> coords = elem.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"></span><br><span class="line">  message.<span class="property">style</span>.<span class="property">left</span> = coords.<span class="property">left</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  message.<span class="property">style</span>.<span class="property">top</span> = coords.<span class="property">bottom</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line"></span><br><span class="line">  message.<span class="property">innerHTML</span> = html;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line"><span class="comment">// 在文档中添加 message 保持 5 秒</span></span><br><span class="line"><span class="keyword">let</span> message = <span class="title function_">createMessageUnder</span>(elem, <span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(message);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> message.<span class="title function_">remove</span>(), <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>页面上的任何点都有坐标：</p><p><strong>相对于窗口的坐标 — elem.getBoundingClientRect()。</strong> <strong>相对于文档的坐标 — elem.getBoundingClientRect() 加上当前页面滚动。</strong> 窗口坐标非常适合和 position:fixed 一起使用，文档坐标非常适合和 position:absolute 一起使用。 这两个坐标系统各有利弊。有时我们需要其中一个或另一个，就像 CSS position 的 absolute 和 fixed 一样。</p><h1 id="4-浏览器事件简介"><a href="#4-浏览器事件简介" class="headerlink" title="4 浏览器事件简介"></a>4 浏览器事件简介</h1><ul><li><p><strong>鼠标事件</strong>：</p><ul><li><code>click</code> —— 当鼠标点击一个元素时（触摸屏设备会在点击时生成）</li><li><code>contextmenu</code> —— 当鼠标右键点击一个元素时。</li><li><code>mouseover / mouseout</code> —— 当鼠标指针移入&#x2F;离开一个元素时。</li><li><code>mousedown / mouseup</code> —— 当在元素上按下&#x2F;释放鼠标按钮时。</li><li><code>mousemove</code> —— 当鼠标移动时。</li></ul></li><li><p><strong>键盘事件</strong>：</p><ul><li><code>keydown</code> 和 <code>keyup</code> —— 当按下和松开一个按键时。</li></ul></li><li><p><strong>表单（form）元素事件</strong>：</p><ul><li><code>submit</code> —— 当访问者提交了一个 <code>&lt;form&gt;</code> 时。</li><li><code>focus</code> —— 当访问者聚焦于一个元素时，例如聚焦于一个<code>&lt;input&gt;</code>。</li></ul></li><li><p><strong>Document事件</strong>：</p><ul><li><code>DOMContentLoaded</code> —— 当HTML的加载和处理均完成，DOM 被完全构建完成时。</li></ul></li><li><p><strong>CSS事件</strong>：</p><ul><li><code>transitionend</code> —— 当一个 CSS 动画完成时。</li></ul></li></ul><h2 id="4-1-事件处理程序"><a href="#4-1-事件处理程序" class="headerlink" title="4.1 事件处理程序"></a>4.1 事件处理程序</h2><p>为了对事件作出响应，我们可以分配一个 <strong>处理程序（handler）</strong>—— 一个在事件发生时运行的函数。 处理程序是在发生用户行为（action）时运行JavaScript代码的一种方式。</p><h3 id="4-1-1-HTML特性"><a href="#4-1-1-HTML特性" class="headerlink" title="4.1.1 HTML特性"></a>4.1.1 HTML特性</h3><p>处理程序可以设置在HTML中名为 <code>on&lt;event&gt;</code> 的特性（attribute）中。 <code>&lt;input value=&quot;Click me&quot; onclick=&quot;alert(&#39;Click!&#39;)&quot; type=&quot;button&quot;&gt;</code> 也就是为button绑定了一个点击特性 请注意，在<code>onclick</code>中，我们使用单引号，因为特性本身使用的是双引号。如果我们忘记了代码是在特性中的，而使用了双引号，像这样：<code>onclick=&quot;alert(&quot;Click!&quot;)&quot;</code>，那么它就无法正确运行。</p><p><strong>HTML特性不是编写大量代码的好位置，因此我们最好创建一个 JavaScript 函数，然后在 HTML 特性中调用这个函数。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">countRabbits</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">alert</span>(<span class="string">&quot;Rabbit number &quot;</span> + i);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;countRabbits()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Count rabbits!&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-1-2-DOM属性"><a href="#4-1-2-DOM属性" class="headerlink" title="4.1.2 DOM属性"></a>4.1.2 DOM属性</h3><p>我们可以使用DOM属性（property）<code>on&lt;event&gt;</code>来分配处理程序。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;elem&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click me&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  elem.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&#x27;Thank you&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果一个处理程序是通过HTML特性（attribute）分配的，那么随后浏览器读取它，并从特性的内容创建一个新函数，并将这个函数写入DOM属性（property）。</p><p><strong>所以说这两种方法本质上是一样的</strong> 唯一的区别就是初始化方法不一样，一个是通过HTML特性初始化的，另一个是通过脚本初始化的。</p><p>可以通过给js中添加处理程序，覆盖现有的处理程序。</p><p>要移除一个处理程序 —— 赋值<code>elem.onclick = null</code>。</p><h3 id="4-1-3-this元素"><a href="#4-1-3-this元素" class="headerlink" title="4.1.3 this元素"></a>4.1.3 this元素</h3><p>处理程序中的this的值是对应的元素。就是处理程序所在的那个元素。 <code>&lt;button onclick=&quot;alert(this.innerHTML)&quot;&gt;Click me&lt;/button&gt;</code> 这里显示的是click me，也就是标签里的内容</p><h3 id="4-1-4-一些需要注意的点"><a href="#4-1-4-一些需要注意的点" class="headerlink" title="4.1.4 一些需要注意的点"></a>4.1.4 一些需要注意的点</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayThanks</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;Thanks!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">elem.<span class="property">onclick</span> = sayThanks;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line">button.<span class="property">onclick</span> = sayThanks;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line">button.<span class="property">onclick</span> = <span class="title function_">sayThanks</span>();</span><br></pre></td></tr></table></figure><p>这是很关键的，如果加括号，则为调用函数，那么它需要得到函数执行的结果，因为它没有返回值，所以是undefined</p><p><strong>但在标记（markup）中，我们确实需要括号：</strong> <code>&lt;input type=&quot;button&quot; id=&quot;button&quot; onclick=&quot;sayThanks()&quot;&gt;</code></p><p><strong>不要对处理程序使用<code>setAttribute</code>。</strong></p><p><strong>DOM 属性是大小写敏感的。</strong> 所以<strong>不能</strong>使用<code>elem.ONCLICK</code></p><h3 id="4-1-5-addEventListener"><a href="#4-1-5-addEventListener" class="headerlink" title="4.1.5 addEventListener"></a>4.1.5 addEventListener</h3><p>如果需要对一个事件分配多个处理程序 则需要使用<code>addEventListener</code> 和<code>removeEventListener</code>来管理处理程序</p><p><code>element.addEventListener(event, handler[, options]);</code></p><p>event : 事件名，例如：‘click’</p><p>handler : 处理程序</p><p>options ： 可附加对象</p><ul><li>once：如果为 true，那么会在被触发后自动删除监听器。</li><li>capture：事件处理的阶段。由于历史原因，options 也可以是 false&#x2F;true，它与 {capture: false&#x2F;true} 相同。</li><li>passive：如果为 true，那么处理程序将不会调用 preventDefault()</li></ul><p><strong>移除需要相同的函数：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>( <span class="string">&#x27;Thanks!&#x27;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, handler);</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">input.<span class="title function_">removeEventListener</span>(<span class="string">&quot;click&quot;</span>, handler);</span><br></pre></td></tr></table></figure><p>多次调用<code>addEventListener</code>允许添加多个处理程序，如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;elem&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click me&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">handler1</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&#x27;Thanks!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">handler2</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&#x27;Thanks again!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  elem.<span class="property">onclick</span> = <span class="function">() =&gt;</span> <span class="title function_">alert</span>(<span class="string">&quot;Hello&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  elem.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, handler1); <span class="comment">// Thanks!</span></span></span><br><span class="line"><span class="language-javascript">  elem.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, handler2); <span class="comment">// Thanks again!</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于某些事件，只能通过<code>addEventListener</code>设置处理程序 例如<code>DOMContentLoaded</code>事件，该事件在文档加载完成并且 DOM 构建完成时触发。</p><h3 id="4-1-6-事件对象"><a href="#4-1-6-事件对象" class="headerlink" title="4.1.6 事件对象"></a>4.1.6 事件对象</h3><p><strong>当事件发生时，浏览器会创建一个<code>event</code>对象，将详细信息放入其中，并将其作为参数传递给处理程序。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click me&quot;</span> <span class="attr">id</span>=<span class="string">&quot;elem&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  elem.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 显示事件类型、元素和点击的坐标</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(event.<span class="property">type</span> + <span class="string">&quot; at &quot;</span> + event.<span class="property">currentTarget</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;Coordinates: &quot;</span> + event.<span class="property">clientX</span> + <span class="string">&quot;:&quot;</span> + event.<span class="property">clientY</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>event.type</strong> 事件类型，这里是 “click”。 <strong>event.currentTarget</strong> 处理事件的元素。这与 this 相同，除非处理程序是一个箭头函数，或者它的 this 被绑定到了其他东西上，之后我们就可以从 event.currentTarget 获取元素了。 <strong>event.clientX &#x2F; event.clientY</strong> 指针事件（pointer event）的指针的窗口相对坐标。</p><p>event对象在HTML特性或者是DOM属性中都能够被使用</p><h3 id="4-1-7-对象处理程序"><a href="#4-1-7-对象处理程序" class="headerlink" title="4.1.7 对象处理程序"></a>4.1.7 对象处理程序</h3><p>我们不仅可以分配函数，还可以使用<code>addEventListener</code>将一个对象分配为事件处理程序。当事件发生时，就会调用该对象的<code>handleEvent</code>方法。</p><p>当<code>addEventListener</code>接收一个对象作为处理程序时，在事件发生时，它就会调用<code>obj.handleEvent(event)</code>来处理事件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;elem&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">class</span> <span class="title class_">Menu</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">handleEvent</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">switch</span>(event.<span class="property">type</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">case</span> <span class="string">&#x27;mousedown&#x27;</span>:</span></span><br><span class="line"><span class="language-javascript">          elem.<span class="property">innerHTML</span> = <span class="string">&quot;Mouse button pressed&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">break</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">case</span> <span class="string">&#x27;mouseup&#x27;</span>:</span></span><br><span class="line"><span class="language-javascript">          elem.<span class="property">innerHTML</span> += <span class="string">&quot;...and released.&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">break</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> menu = <span class="keyword">new</span> <span class="title class_">Menu</span>();</span></span><br><span class="line"><span class="language-javascript">  elem.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, menu);</span></span><br><span class="line"><span class="language-javascript">  elem.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseup&#x27;</span>, menu);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-2-冒泡和捕获"><a href="#4-2-冒泡和捕获" class="headerlink" title="4.2 冒泡和捕获"></a>4.2 冒泡和捕获</h2><h3 id="4-2-1-冒泡-bubbing"><a href="#4-2-1-冒泡-bubbing" class="headerlink" title="4.2.1 冒泡(bubbing)"></a>4.2.1 冒泡(bubbing)</h3><p>当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。 假设我们有 3 层嵌套 <code>FORM &gt; DIV &gt; P</code>，它们各自拥有一个处理程序：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">body</span> * &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;form&#x27;)&quot;</span>&gt;</span>FORM</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;div&#x27;)&quot;</span>&gt;</span>DIV</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;p&#x27;)&quot;</span>&gt;</span>P<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击内部的<code>&lt;p&gt;</code>会首先运行<code>onclick</code>：</p><ol><li>在该<code>&lt;p&gt;</code>上的。</li><li>然后是外部<code>&lt;div&gt;</code>上的。</li><li>然后是外部<code>&lt;form&gt;</code>上的。</li><li>以此类推，直到最后的<code>document</code>对象。</li></ol><p>因此，如果我们点击<code>&lt;p&gt;</code>，那么我们将看到 3 个 alert：p → div → form。</p><p><strong>这个过程被称为“冒泡（bubbling）”，因为事件从内部元素“冒泡”到所有父级，就像在水里的气泡一样。</strong></p><p><strong>几乎</strong>所有事件都会冒泡。 例如，<code>focus</code>事件不会冒泡。同样，我们以后还会遇到其他例子。但这仍然是例外，而不是规则，大多数事件的确都是冒泡的。</p><h3 id="4-2-2-event-target"><a href="#4-2-2-event-target" class="headerlink" title="4.2.2 event.target"></a>4.2.2 event.target</h3><p>父元素上的处理程序始终可以获取事件实际发生位置的详细信息。 引发事件的那个嵌套层级最深的元素被称为目标元素,可以通过<code>event.target</code>访问。</p><p>this和event.target的区别：</p><ul><li><code>event.target</code> —— 是引发事件的“目标”元素，它在冒泡过程中不会发生变化。</li><li><code>this</code> —— 是“当前”元素，其中有一个当前正在运行的处理程序。</li></ul><p>在一个事件中，this代表的元素就是这个事件的元素，而event.target则不一定，它可能是这个事件的子元素</p><h3 id="4-2-3-停止冒泡"><a href="#4-2-3-停止冒泡" class="headerlink" title="4.2.3 停止冒泡"></a>4.2.3 停止冒泡</h3><p>冒泡事件从目标元素开始向上冒泡。通常，它会一直上升到<code>&lt;html&gt;</code>，然后再到<code>document</code>对象，有些事件甚至会到达 <code>window</code>，它们会调用路径上所有的处理程序。</p><p><strong>但是任意处理程序都可以决定事件已经被完全处理，并停止冒泡。</strong></p><p>用于停止冒泡的方法是<code>event.stopPropagation()</code>。</p><p>如果一个元素在一个事件上有多个处理程序，即使其中一个停止冒泡，其他处理程序仍会执行。 换句话说，<code>event.stopPropagation()</code>停止向上移动，但是当前元素上的其他处理程序都会继续运行。 有一个<code>event.stopImmediatePropagation()</code>方法，可以用于停止冒泡，并阻止当前元素上的处理程序运行。使用该方法之后，其他处理程序就不会被执行。</p><p><strong>不要在没有需要的情况下停止冒泡！</strong></p><p>通常，没有真正的必要去阻止冒泡。一项看似需要阻止冒泡的任务，可以通过其他方法解决。其中之一就是使用自定义事件，我们还可以将我们的数据写入一个处理程序中的<code>event</code>对象，并在另一个处理程序中读取该数据，这样我们就可以向父处理程序传递有关下层处理程序的信息。</p><h3 id="4-2-4-捕获"><a href="#4-2-4-捕获" class="headerlink" title="4.2.4 捕获"></a>4.2.4 捕获</h3><p>事件处理的另一个阶段被称为“捕获（capturing）”。它很少被用在实际开发中，但有时是有用的。</p><p>DOM 事件标准描述了事件传播的 3 个阶段：</p><ol><li>捕获阶段（Capturing phase）—— 事件（从 Window）向下走近元素。</li><li>目标阶段（Target phase）—— 事件到达目标元素。</li><li>冒泡阶段（Bubbling phase）—— 事件从元素上开始冒泡。</li></ol><h2 id="4-3-事件委托"><a href="#4-3-事件委托" class="headerlink" title="4.3 事件委托"></a>4.3 事件委托</h2><p>捕获和冒泡允许我们实现最强大的事件处理模式之一，即<strong>事件委托</strong>模式。</p><p>如果我们有许多以<strong>类似方式</strong>处理的元素，那么就不必为每个元素分配一个处理程序 —— 而是<strong>将单个处理程序放在它们的共同祖先上</strong>。</p><p>在处理程序中，我们获取<code>event.target</code>以查看事件实际发生的位置并进行处理。</p><h3 id="4-3-1-标记中的行为-action-in-markup"><a href="#4-3-1-标记中的行为-action-in-markup" class="headerlink" title="4.3.1 标记中的行为(action in markup)"></a>4.3.1 标记中的行为(action in markup)</h3><p>例如，我们想要编写一个有“保存”、“加载”和“搜索”等按钮的菜单。并且，这里有一个具有 save、load 和 search 等方法的对象。如何匹配它们？ 第一个想法可能是为每个按钮分配一个单独的处理程序。但是有一个更优雅的解决方案。我们可以为整个菜单添加一个处理程序，并为具有方法调用的按钮添加 data-action 特性（attribute）： <code>&lt;button data-action=&quot;save&quot;&gt;Click to Save&lt;/button&gt;</code></p><p>处理程序读取特性（attribute）并执行该方法。工作示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;menu&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-action</span>=<span class="string">&quot;save&quot;</span>&gt;</span>Save<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-action</span>=<span class="string">&quot;load&quot;</span>&gt;</span>Load<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-action</span>=<span class="string">&quot;search&quot;</span>&gt;</span>Search<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">class</span> <span class="title class_">Menu</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">constructor</span>(<span class="params">elem</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">_elem</span> = elem;</span></span><br><span class="line"><span class="language-javascript">      elem.<span class="property">onclick</span> = <span class="variable language_">this</span>.<span class="property">onClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>); <span class="comment">// (*)</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">save</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">alert</span>(<span class="string">&#x27;saving&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">load</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">alert</span>(<span class="string">&#x27;loading&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">search</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">alert</span>(<span class="string">&#x27;searching&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">onClick</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> action = event.<span class="property">target</span>.<span class="property">dataset</span>.<span class="property">action</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (action) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>[action]();</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">new</span> <span class="title class_">Menu</span>(menu);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>我们不需要编写代码来为每个按钮分配一个处理程序。只需要创建一个方法并将其放入标记（markup）中即可。</li><li>HTML 结构非常灵活，我们可以随时添加&#x2F;移除按钮。</li></ul><h3 id="4-3-2-行为模式"><a href="#4-3-2-行为模式" class="headerlink" title="4.3.2 行为模式"></a>4.3.2 行为模式</h3><p>我们还可以使用事件委托将“行为（behavior）”以 声明方式 添加到具有特殊特性（attribute）和类的元素中。 行为模式分为两个部分：</p><ul><li>我们将自定义特性添加到描述其行为的元素。</li><li>用文档范围级的处理程序追踪事件，如果事件发生在具有特定特性的元素上 —— 则执行行为（action）。</li></ul><p><strong>行为：计数器</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Counter: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">data-counter</span>&gt;</span></span><br><span class="line">One more counter: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> <span class="attr">data-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (event.<span class="property">target</span>.<span class="property">dataset</span>.<span class="property">counter</span> != <span class="literal">undefined</span>) &#123; <span class="comment">// 如果这个特性存在...</span></span></span><br><span class="line"><span class="language-javascript">      event.<span class="property">target</span>.<span class="property">value</span>++;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于文档级的处理程序 —— 始终使用的是<code>addEventListener</code> 当我们将事件处理程序分配给<code>document</code>对象时，我们应该始终使用<code>addEventListener</code>，而不是<code>document.on&lt;event&gt;</code>，因为后者会引起冲突：新的处理程序会覆盖旧的处理程序。</p><p>对于实际项目来说。在<code>document</code>上有许多由代码的不同部分设置的处理程序，这是很正常的。</p><p><strong>行为：切换器</strong> 点击一个具有 data-toggle-id 特性的元素将显示&#x2F;隐藏具有给定 id 的元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">button data-toggle-id=&quot;subscribe-mail&quot;&gt;</span><br><span class="line">  Show the subscription form</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;subscribe-mail&quot;</span> <span class="attr">hidden</span>&gt;</span></span><br><span class="line">  Your mail: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> id = event.<span class="property">target</span>.<span class="property">dataset</span>.<span class="property">toggleId</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (!id) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> elem = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    elem.<span class="property">hidden</span> = !elem.<span class="property">hidden</span>;</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>让我们再次注意我们做了什么。现在，要向元素添加切换功能 —— 无需了解JavaScript，只需要使用特性<code>data-toggle-id</code> 即可。 这可能变得非常方便 —— 无需为每个这样的元素编写 JavaScript。只需要使用行为。文档级处理程序使其适用于页面的任意元素。</p><p><strong>我们也可以组合单个元素上的多个行为。</strong></p><p><strong>“行为”模式可以替代 JavaScript 的小片段。</strong></p><h3 id="4-3-3-总结"><a href="#4-3-3-总结" class="headerlink" title="4.3.3 总结"></a>4.3.3 总结</h3><p><strong>它通常用于为许多相似的元素添加相同的处理，但不仅限于此。</strong></p><ol><li>在容器（container）上放一个处理程序。</li><li>在处理程序中 —— 检查源元素 event.target。</li><li>如果事件发生在我们感兴趣的元素内，那么处理该事件。</li></ol><p>好处：</p><ul><li>简化初始化并节省内存：无需添加许多处理程序。</li><li>更少的代码：添加或移除元素时，无需添加&#x2F;移除处理程序。</li><li>DOM 修改 ：我们可以使用 innerHTML 等，来批量添加&#x2F;移除元素。</li></ul><p>局限：</p><ul><li>首先，事件必须冒泡。而有些事件不会冒泡。此外，低级别的处理程序不应该使用 event.stopPropagation()。</li><li>其次，委托可能会增加 CPU 负载，因为容器级别的处理程序会对容器中任意位置的事件做出反应，而不管我们是否对该事件感兴趣。但是，通常负载可以忽略不计，所以我们不考虑它。</li></ul><h2 id="4-4-浏览器默认行为"><a href="#4-4-浏览器默认行为" class="headerlink" title="4.4 浏览器默认行为"></a>4.4 浏览器默认行为</h2><p>许多事件会自动触发浏览器执行某些行为。</p><p>例如：</p><ul><li>点击一个链接 —— 触发导航（navigation）到该 URL。</li><li>点击表单的提交按钮 —— 触发提交到服务器的行为。</li><li>在文本上按下鼠标按钮并移动 —— 选中文本。</li></ul><p>如果我们使用 JavaScript 处理一个事件，那么我们通常不希望发生相应的浏览器行为。而是想要实现其他行为进行替代。</p><h3 id="4-4-1-阻止浏览器行为"><a href="#4-4-1-阻止浏览器行为" class="headerlink" title="4.4.1 阻止浏览器行为"></a>4.4.1 阻止浏览器行为</h3><p>有两种方式来告诉浏览器我们不希望它执行默认行为：</p><p>主流的方式是使用<code>event</code>对象。有一个<code>event.preventDefault()</code>方法。 如果处理程序是使用<code>on&lt;event&gt;</code>（而不是<code>addEventListener</code>）分配的，那返回<code>false</code>也同样有效。 在下面这个示例中，点击链接不会触发导航（navigation），浏览器不会执行任何操作：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;return false&quot;</span>&gt;</span>Click here<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">or</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;event.preventDefault()&quot;</span>&gt;</span>here<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从处理程序返回<code>false</code>是一个例外 事件处理程序返回的值通常会被忽略。 唯一的例外是从使用<code>on&lt;event&gt;</code>分配的处理程序中返回的 return false。 在所有其他情况下，return 值都会被忽略。并且，返回 true 没有意义。</p><h3 id="4-4-2-处理程序选项“passive”"><a href="#4-4-2-处理程序选项“passive”" class="headerlink" title="4.4.2 处理程序选项“passive”"></a>4.4.2 处理程序选项“passive”</h3><p><code>addEventListener</code>的可选项<code>passive: true</code>向浏览器发出信号，表明处理程序将不会调用<code>preventDefault()</code>。</p><p>为什么需要这样做？</p><p>移动设备上会发生一些事件，例如<code>touchmove</code>（当用户在屏幕上移动手指时），默认情况下会导致滚动，但是可以使用处理程序的<code>preventDefault()</code>来阻止滚动。</p><p>因此，当浏览器检测到此类事件时，它必须首先处理所有处理程序，然后如果没有任何地方调用<code>preventDefault</code>，则页面可以继续滚动。但这可能会导致 UI 中不必要的延迟和“抖动”。</p><p><code>passive: true</code>选项告诉浏览器，处理程序不会取消滚动。然后浏览器立即滚动页面以提供最大程度的流畅体验，并通过某种方式处理事件。</p><p>对于某些浏览器（Firefox，Chrome），默认情况下，<code>touchstart</code>和<code>touchmove</code>事件的<code>passive</code>为 true。</p><h3 id="4-4-3-event-defaultPrevented"><a href="#4-4-3-event-defaultPrevented" class="headerlink" title="4.4.3 event.defaultPrevented"></a>4.4.3 event.defaultPrevented</h3><p>如果默认行为被阻止，那么<code>event.defaultPrevented</code>属性为<code>true</code>，否则为<code>false</code>。</p><p>在冒泡和捕获中的 event.stopPropagation()，可以使用<code>event.defaultPrevented</code>来代替，来通知其他事件处理程序，该事件已经被处理。</p><p>默认情况下，浏览器在<code>contextmenu</code>事件（单击鼠标右键）时，显示带有标准选项的上下文菜单。我们可以阻止它并显示我们自定义的菜单，就像这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>Right-click shows browser context menu<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">oncontextmenu</span>=<span class="string">&quot;alert(&#x27;Draw our menu&#x27;); return false&quot;</span>&gt;</span></span><br><span class="line">  Right-click shows our context menu</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Right-click for the document menu (added a check for event.defaultPrevented)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;elem&quot;</span>&gt;</span>Right-click for the button menu<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  elem.<span class="property">oncontextmenu</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    event.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;Button context menu&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="property">oncontextmenu</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (event.<span class="property">defaultPrevented</span>) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    event.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;Document context menu&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在一切都可以正常工作了。如果我们有嵌套的元素，并且每个元素都有自己的上下文菜单，那么这也是可以运行的。只需确保检查每个<code>contextmenu</code>处理程序中的<code>event.defaultPrevented</code>。</p><p><code>event.stopPropagation()</code> 和 <code>event.preventDefault()</code> 正如我们所看到的，<code>event.stopPropagation()</code>和<code>event.preventDefault()</code>（也被认为是 return false）是两个不同的东西。它们之间毫无关联。</p><h2 id="4-5-创建自定义事件"><a href="#4-5-创建自定义事件" class="headerlink" title="4.5 创建自定义事件"></a>4.5 创建自定义事件</h2><p>我们不仅可以分配事件处理程序，还可以从JavaScript生成事件。</p><p>自定义事件可用于创建“图形组件”。例如，我们自己的基于JavaScript的菜单的根元素可能会触发<code>open</code>（打开菜单），<code>select</code>（有一项被选中）等事件来告诉菜单发生了什么。另一个代码可能会监听事件，并观察菜单发生了什么。</p><p>我们不仅可以生成出于自身目的而创建的全新事件，还可以生成例如<code>click</code>和<code>mousedown</code>等内建事件。这可能会有助于自动化测试。</p><h3 id="4-5-1-事件构造器"><a href="#4-5-1-事件构造器" class="headerlink" title="4.5.1 事件构造器"></a>4.5.1 事件构造器</h3><p>内建事件类形成一个层次结构（hierarchy），类似于DOM元素类。根是内建的<code>Event</code>类。</p><p>我们可以像这样创建<code>Event</code>对象： <code>let event = new Event(type[, options]);</code> 参数：</p><ul><li><strong>type</strong> —— 事件类型，可以是像这样 “click” 的字符串，或者我们自己的像这样 “my-event” 的参数。</li><li><strong>options</strong> —— 具有两个可选属性的对象：<ul><li>bubbles: true&#x2F;false —— 如果为 true，那么事件会冒泡。</li><li>cancelable: true&#x2F;false —— 如果为 true，那么“默认行为”就会被阻止。稍后我们会看到对于自定义事件，它意味着什么。 默认情况下，以上两者都为 false：{bubbles: false, cancelable: false}。</li></ul></li></ul><h3 id="4-5-2-dispatchEvent"><a href="#4-5-2-dispatchEvent" class="headerlink" title="4.5.2 dispatchEvent"></a>4.5.2 dispatchEvent</h3><p>事件对象被创建后，我们应该使用<code>elem.dispatchEvent(event)</code> 调用在元素上“运行”它。</p><p>然后，处理程序会对它做出反应，就好像它是一个常规的浏览器事件一样。如果事件是用<code>bubbles</code>标志创建的，那么它会冒泡。</p><p>在下面这个示例中，<code>click</code>事件是用JavaScript初始化创建的。处理程序工作方式和点击按钮的方式相同：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;elem&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;Click!&#x27;);&quot;</span>&gt;</span>Autoclick<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> event = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&quot;click&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  elem.<span class="title function_">dispatchEvent</span>(event);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>event.isTrusted</code>可以用来区分“真实”用户事件和通过脚本生成的事件。 对于来自真实用户操作的事件，<code>event.isTrusted</code>属性为true。 对于脚本生成的事件，<code>event.isTrusted</code>属性为 false。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;elem&quot;</span>&gt;</span>Hello from the script!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 在 document 上捕获...</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;hello&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123; <span class="comment">// (1)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;Hello from &quot;</span> + event.<span class="property">target</span>.<span class="property">tagName</span>); <span class="comment">// Hello from H1</span></span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// ...在 elem 上 dispatch！</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> event = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&quot;hello&quot;</span>, &#123;<span class="attr">bubbles</span>: <span class="literal">true</span>&#125;); <span class="comment">// (2)</span></span></span><br><span class="line"><span class="language-javascript">  elem.<span class="title function_">dispatchEvent</span>(event);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 在 document 上的处理程序将被激活，并显示消息。</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于自定义事件，应该使用<code>addEventListener</code>,而不是<code>on&lt;event&gt;</code> 必须设置<code>bubbles.true</code>,否则事件不会向上冒泡。</p><h3 id="4-5-3-UI事件"><a href="#4-5-3-UI事件" class="headerlink" title="4.5.3 UI事件"></a>4.5.3 UI事件</h3><p>对于一些UI事件，比如MouseEvent,KeyBoardEvent事件等，创建不能够使用new Event。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> event = <span class="keyword">new</span> <span class="title class_">MouseEvent</span>(<span class="string">&quot;click&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">cancelable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">clientX</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">clientY</span>: <span class="number">100</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(event.<span class="property">clientX</span>); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><h3 id="4-5-4-自定义事件"><a href="#4-5-4-自定义事件" class="headerlink" title="4.5.4 自定义事件"></a>4.5.4 自定义事件</h3><p>对于我们自己的全新事件类型，例如 “hello”，我们应该使用<code>new CustomEvent</code>。从技术上讲，<code>CustomEvent</code>和 <code>Event</code>一样。除了一点不同。 在第二个参数（对象）中，我们可以为我们想要与事件一起传递的任何自定义信息添加一个附加的属性<code>detail</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;elem&quot;</span>&gt;</span>Hello for John!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 事件附带给处理程序的其他详细信息</span></span></span><br><span class="line"><span class="language-javascript">  elem.<span class="title function_">addEventListener</span>(<span class="string">&quot;hello&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(event.<span class="property">detail</span>.<span class="property">name</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  elem.<span class="title function_">dispatchEvent</span>(<span class="keyword">new</span> <span class="title class_">CustomEvent</span>(<span class="string">&quot;hello&quot;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">detail</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;));</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>detail</code>属性可以有任何数据。从技术上讲，我们可以不用，因为我们可以在创建后将任何属性分配给常规的<code>new Event</code> 对象中。但是<code>CustomEvent</code>提供了特殊的<code>detail</code>字段，以避免与其他事件属性的冲突。</p><p>此外，事件类描述了它是“什么类型的事件”，如果事件是自定义的，那么我们应该使用<code>CustomEvent</code>来明确它是什么。</p><h3 id="4-5-5-event-preventDefault"><a href="#4-5-5-event-preventDefault" class="headerlink" title="4.5.5 event.preventDefault()"></a>4.5.5 event.preventDefault()</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span> <span class="attr">id</span>=<span class="string">&quot;rabbit&quot;</span>&gt;</span></span><br><span class="line">  \   /</span><br><span class="line">   \_/</span><br><span class="line">   /. .\</span><br><span class="line">  =\_Y_/=</span><br><span class="line">   &#123;&gt;o&lt;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;hide()&quot;</span>&gt;</span>Hide()<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">hide</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> event = <span class="keyword">new</span> <span class="title class_">CustomEvent</span>(<span class="string">&quot;hide&quot;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">cancelable</span>: <span class="literal">true</span> <span class="comment">// 没有这个标志，preventDefault 将不起作用</span></span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (!rabbit.<span class="title function_">dispatchEvent</span>(event)) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">alert</span>(<span class="string">&#x27;The action was prevented by a handler&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      rabbit.<span class="property">hidden</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  rabbit.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hide&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (<span class="title function_">confirm</span>(<span class="string">&quot;Call preventDefault?&quot;</span>)) &#123;</span></span><br><span class="line"><span class="language-javascript">      event.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>通过调用<code>event.preventDefault()</code>，事件处理程序可以发出一个信号，指出默认行为应该被取消。</li><li>在这种情况下，<code>elem.dispatchEvent(event)</code>的调用会返回false。那么分派（dispatch）该事件的代码就会知道不应该再继续。</li><li>请注意：该事件必须具有<code>cancelable: true</code>标志，否则<code>event.preventDefault()</code>调用将会被忽略。</li></ul><h3 id="4-5-6-同步事件"><a href="#4-5-6-同步事件" class="headerlink" title="4.5.6 同步事件"></a>4.5.6 同步事件</h3><p>通常事件是在队列中处理的。也就是说：如果浏览器正在处理<code>onclick</code>，这时发生了一个新的事件，例如鼠标移动了，那么它的处理程序会被排入队列，相应的<code>mousemove</code>处理程序将在<code>onclick</code>事件处理完成后被调用。</p><p>值得注意的例外情况就是，一个事件是在另一个事件中发起的。例如使用<code>dispatchEvent</code>。这类事件将会被立即处理，即在新的事件处理程序被调用之后，恢复到当前的事件处理程序。</p><h2 id="4-6-鼠标事件"><a href="#4-6-鼠标事件" class="headerlink" title="4.6 鼠标事件"></a>4.6 鼠标事件</h2><p>鼠标事件不仅可能来自于“鼠标设备”，还可能来自于对此类操作进行了模拟以实现兼容性的其他设备，例如手机和平板电脑。</p><p>dbclick 双击鼠标 因为双击鼠标会造成副作用，比如说如果给文本绑定双击的话，还会选择文本 所以为了避免造成副作用，应该防止浏览器对<code>mousedown</code>进行操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Before</span>...</span><br><span class="line">&lt;b ondblclick=<span class="string">&quot;alert(&#x27;Click!&#x27;)&quot;</span> onmousedown=<span class="string">&quot;return false&quot;</span>&gt;</span><br><span class="line">  <span class="title class_">Double</span>-click me</span><br><span class="line">&lt;/b&gt;</span><br><span class="line">...<span class="title class_">After</span></span><br></pre></td></tr></table></figure><p>contextmenu 鼠标右键被按下时触发</p><p><strong>鼠标事件的顺序：</strong> 在单个动作触发多个事件时，事件的顺序是固定的。也就是说，会遵循 mousedown → mouseup → click 的顺序调用处理程序。 <code>button</code>属性允许检测鼠标按键</p><h3 id="4-6-1-鼠标按钮"><a href="#4-6-1-鼠标按钮" class="headerlink" title="4.6.1 鼠标按钮"></a>4.6.1 鼠标按钮</h3><p>与点击相关的事件始终具有<code>button</code>属性，该属性允许获取确切的鼠标按钮。</p><p>通常我们不在<code>click</code>和<code>contextmenu</code>事件中使用这一属性，因为前者只在单击鼠标左键时触发，后者只在单击鼠标右键时触发。 不过，在<code>mousedown</code>和<code>mouseup</code>事件中则可能需要用到<code>event.button</code>，因为这两个事件在任何按键上都会触发，所以我们可以使用<code>button</code>属性来区分是左键单击还是右键单击。</p><p>鼠标按键状态</p><p>event.button</p><p>左键 (主要按键)</p><p>0</p><p>中键 (辅助按键)</p><p>1</p><p>右键 (次要按键)</p><p>2</p><p>X1 键 (后退按键)</p><p>3</p><p>X2 键 (前进按键)</p><p>4</p><p>大多数鼠标设备只有左键和右键，对应的值就是 0 和 2。触屏设备中的点按操作也会触发类似的事件。</p><p>另外，还有一个<code>event.buttons</code>属性，其中以整数的形式存储着当前所有按下的鼠标按键，每个按键一个比特位。</p><p><strong>event.which已经被弃用，其是一种非常古老的获得按下的按键的方式</strong></p><h3 id="4-6-2-组合键"><a href="#4-6-2-组合键" class="headerlink" title="4.6.2 组合键"></a>4.6.2 组合键</h3><p>shift：shiftKey alt: altKey ctrl: ctrlKey metakey: 对于mac是cmd</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个按钮只有在alt+shift+click才会生效</span></span><br><span class="line">&lt;button id=<span class="string">&quot;button&quot;</span>&gt;<span class="title class_">Alt</span>+<span class="title class_">Shift</span>+<span class="title class_">Click</span> on me!&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  button.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">if</span> (event.<span class="property">altKey</span> &amp;&amp; event.<span class="property">shiftKey</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">alert</span>(<span class="string">&#x27;Hooray!&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>在mac上的不同操作：</strong> 在Windows和Linux上有Alt，Shift和Ctrl。在Mac上还有：Cmd，它对应于属性 metaKey。 在大多数情况下，当在 Windows&#x2F;Linux 上使用Ctrl时，在Mac是使用Cmd。 也就说：当 Windows 用户按下Ctrl+Enter或Ctrl+A时，Mac用户会按下Cmd+Enter或 Cmd+A，以此类推。 因此，如果我们想支持Ctrl+click，那么对于Mac应该使用 Cmd+click。对于Mac用户而言，这更舒适。 即使我们想强制Mac用户使用Ctrl+click —— 这非常困难。问题是：在MacOS上左键单击和Ctrl一起使用会被解释为右键单击，并且会生成contextmenu事件，而不是像 Windows&#x2F;Linux中的click事件。 因此，如果我们想让所有操作系统的用户都感到舒适，那么我们应该将ctrlKey与 metaKey一起进行检查。 对于 JS 代码，这意味着我们应该检查<code>if (event.ctrlKey event.metaKey)</code>。</p><h3 id="4-6-3-坐标"><a href="#4-6-3-坐标" class="headerlink" title="4.6.3 坐标"></a>4.6.3 坐标</h3><ol><li>相对于窗口的坐标：<code>clientX</code>和<code>clientY</code>。</li><li>相对于文档的坐标：<code>pageX</code>和<code>pageY</code>。</li></ol><p>相对于文档的坐标不会随着页面的滚动而改变。 相对于窗口的坐标是以当前窗口的左上角为参照物</p><h3 id="4-6-4-防止复制"><a href="#4-6-4-防止复制" class="headerlink" title="4.6.4 防止复制"></a>4.6.4 防止复制</h3><p>万恶之源来了 如果我们想禁用选择以保护我们页面的内容不被复制粘贴，那么我们可以使用另一个事件：<code>oncopy</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div oncopy=<span class="string">&quot;alert(&#x27;Copying forbidden!&#x27;);return false&quot;</span>&gt;</span><br><span class="line">  <span class="title class_">Dear</span> user,</span><br><span class="line">  <span class="title class_">The</span> copying is forbidden <span class="keyword">for</span> you.</span><br><span class="line">  <span class="title class_">If</span> you know <span class="variable constant_">JS</span> or <span class="variable constant_">HTML</span>, then you can get everything <span class="keyword">from</span> the page source though.</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="4-6-5-移动鼠标事件"><a href="#4-6-5-移动鼠标事件" class="headerlink" title="4.6.5 移动鼠标事件"></a>4.6.5 移动鼠标事件</h3><p><code>mouseover/mouseout</code>:当鼠标指针移到某个元素上时，<code>mouseover</code>事件就会发生，而当鼠标离开该元素时，<code>mouseout</code>事件就会发生。</p><p><code>mouseover</code>:</p><ul><li><code>event.target</code>——是鼠标移过的那个元素</li><li><code>event.relatedTarget</code>——是鼠标来自的那个元素（relatedtarget -&gt; target）</li></ul><p><code>mouseout</code>:</p><ul><li><code>event.target</code>——是鼠标离开的元素</li><li><code>event.relatedTarget</code>——是鼠标移动到的，当前指针位置下的元素（target-&gt; relatedTarget）</li></ul><p>mouseover 和 mouseout 完全相反</p><p><strong><code>relatedTarget</code>属性可以为null。</strong> 这是正常现象，仅仅是意味着鼠标不是来自另一个元素，而是来自窗口之外。或者它离开了窗口。 当我们在代码中使用<code>event.relatedTarget</code>时，我们应该牢记这种可能性。如果我们访问<code>event.relatedTarget.tagName</code>，那么就会出现错误。</p><p>在移动鼠标时，就会触发<code>mousemove</code>事件。 如果访问者移动鼠标非常快的话，某些元素可能会被跳过。</p><p>如果mouseover被触发了，则必须有mouseout</p><p>当从父元素转到子元素时，也会触发mouseover&#x2F;out事件。 浏览器假定鼠标一次只会位于一个元素上 —— 最深的那个。</p><p><code>mouseenter/mouseleave</code>: mouseenter&#x2F;mouseleave的最大区别就是，当鼠标指针进入一个元素时，会触发mouseenter,而就算它移动到child里也不会有影响，所以说其会忽略后代之间的移动，只有其移出元素时，才会触发mouseleave 并且其不会冒泡</p><h3 id="4-6-6-鼠标拖放事件"><a href="#4-6-6-鼠标拖放事件" class="headerlink" title="4.6.6 鼠标拖放事件"></a>4.6.6 鼠标拖放事件</h3><ol><li>在<code>mousedown</code>上 —— 根据需要准备要移动的元素（也许创建一个它的副本，向其中添加一个类或其他任何东西）。</li><li>然后在<code>mousemove</code>上，通过更改 position:absolute 情况下的 left&#x2F;top 来移动它。</li><li>在<code>mouseup</code>上 —— 执行与完成的拖放相关的所有行为。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ball.<span class="property">onmousedown</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// (1) 准备移动：确保 absolute，并通过设置 z-index 以确保球在顶部</span></span><br><span class="line">  ball.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;absolute&#x27;</span>;</span><br><span class="line">  ball.<span class="property">style</span>.<span class="property">zIndex</span> = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将其从当前父元素中直接移动到 body 中</span></span><br><span class="line">  <span class="comment">// 以使其定位是相对于 body 的</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(ball);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 现在球的中心在 (pageX, pageY) 坐标上</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">moveAt</span>(<span class="params">pageX, pageY</span>) &#123;</span><br><span class="line">    ball.<span class="property">style</span>.<span class="property">left</span> = pageX - ball.<span class="property">offsetWidth</span> / <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">    ball.<span class="property">style</span>.<span class="property">top</span> = pageY - ball.<span class="property">offsetHeight</span> / <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将我们绝对定位的球移到指针下方</span></span><br><span class="line">  <span class="title function_">moveAt</span>(event.<span class="property">pageX</span>, event.<span class="property">pageY</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">onMouseMove</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="title function_">moveAt</span>(event.<span class="property">pageX</span>, event.<span class="property">pageY</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// (2) 在 mousemove 事件上移动球</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, onMouseMove);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// (3) 放下球，并移除不需要的处理程序</span></span><br><span class="line">  ball.<span class="property">onmouseup</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, onMouseMove);</span><br><span class="line">    ball.<span class="property">onmouseup</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 因为页面本身可能会有冲突，所以需要禁止这些行为</span></span><br><span class="line">  ball.<span class="property">ondragstart</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://zh.javascript.info/mouse-drag-and-drop">更多详情</a></p><p><a href="./js/dom/%E4%BA%8B%E4%BB%B6/%E6%BB%91%E5%8A%A8%E6%9D%A1.html">滑动条</a></p><h2 id="4-7-指针事件"><a href="#4-7-指针事件" class="headerlink" title="4.7 指针事件"></a>4.7 指针事件</h2><p>指针事件（Pointer Events）是一种用于处理来自各种输入设备（例如鼠标、触控笔和触摸屏等）的输入信息的现代化解决方案。</p><p>指针事件是用来替代鼠标事件的，而且和鼠标事件兼容，就是换成了pointer。 比如<code>mousedown</code>可以被替换成<code>pointerdown</code>。 我们可以把代码中的<code>mouse&lt;event&gt;</code>都替换成<code>pointer&lt;event&gt;</code>，程序仍然正常兼容鼠标设备。 替换之后，程序对触屏设备的支持会“魔法般”地提升。但是，我们可能需要在 CSS 中的某些地方添加<code>touch-action: none</code>。</p><h3 id="4-7-1-指针事件属性"><a href="#4-7-1-指针事件属性" class="headerlink" title="4.7.1 指针事件属性"></a>4.7.1 指针事件属性</h3><ul><li><code>pointerId</code>—— 触发当前事件的指针唯一标识符。 浏览器生成的。使我们能够处理多指针的情况，例如带有触控笔和多点触控功能的触摸屏（下文会有相关示例）。</li><li><code>pointerType</code> —— 指针的设备类型。必须为字符串，可以是：“mouse”、“pen” 或 “touch”。 我们可以使用这个属性来针对不同类型的指针输入做出不同响应。</li><li><code>isPrimary</code> —— 当指针为首要指针（多点触控时按下的第一根手指）时为 true。</li></ul><p>有些指针设备会测量接触面积和点按压力（例如一根手指压在触屏上），对于这种情况可以使用以下属性：</p><ul><li><code>width</code>—— 指针（例如手指）接触设备的区域的宽度。对于不支持的设备（如鼠标），这个值总是 1。</li><li><code>height</code>—— 指针（例如手指）接触设备的区域的长度。对于不支持的设备，这个值总是 1。</li><li><code>pressure</code>—— 触摸压力，是一个介于 0 到 1 之间的浮点数。对于不支持压力检测的设备，这个值总是 0.5（按下时）或 0。</li><li><code>tangentialPressure</code>—— 归一化后的切向压力（tangential pressure）。</li><li><code>tiltX, tiltY, twist</code>—— 针对触摸笔的几个属性，用于描述笔和屏幕表面的相对位置。</li></ul><h3 id="4-7-2-多点触控"><a href="#4-7-2-多点触控" class="headerlink" title="4.7.2 多点触控"></a>4.7.2 多点触控</h3><p><strong>多点触控（用户在手机或平板上同时点击若干个位置，或执行特殊手势）是鼠标事件完全不支持的功能之一。</strong></p><p>第一根手指触摸时： <code>pointerdown</code>事件触发，<code>isPrimary=true</code>，指派一个<code>pointerId</code>` 第二个和后续的更多个手指触摸（假设第一个手指仍在触摸）： <code>pointerdown</code>事件触发，<code>isPrimary=false</code>，并且每一个触摸都被指派了不同的 <code>pointerId</code>。</p><p><strong>对于多点触控事件来说，pointerId是由浏览器进行分配的，所以说如果有多根手指同时触摸屏幕，就会得到多个pointerdown事件和对应的坐标以及不同的pointerId。</strong></p><p>利用<code>pointerId</code>，我们可以追踪多根正在触摸屏幕的手指。当用户移动或抬起某根手指时，我们会得到和<code>pointerdown</code>事件具有相同<code>pointerId</code>的<code>pointermove</code>或<code>pointerup</code>事件。</p><h3 id="4-7-3-pointercancel"><a href="#4-7-3-pointercancel" class="headerlink" title="4.7.3 pointercancel"></a>4.7.3 pointercancel</h3><p><code>pointercancel</code>事件将会在一个正处于活跃状态的指针交互由于某些原因被中断时触发。也就是在这个事件之后，该指针就不会继续触发更多事件了。 导致指针中断的可能原因如下：</p><ul><li>指针设备硬件在物理层面上被禁用。</li><li>设备方向旋转（例如给平板转了个方向）。</li><li>浏览器打算自行处理这一交互，比如将其看作是一个专门的鼠标手势或缩放操作等。</li></ul><p><strong>阻止浏览器的默认行为来防止<code>pointercancel</code>触发。</strong></p><p>需要做两件事：</p><ol><li>阻止原生的拖放操作发生<ul><li>event.ondragstart &#x3D; () &#x3D;&gt; false</li></ul></li><li>对于触屏设备，还有其他和触摸相关的浏览器行为（除了拖放）。为了避免它们所引发的问题<ul><li>通过在 CSS 中设置 #event { touch-action: none } 来阻止它们。</li></ul></li></ol><h3 id="4-7-4-指针捕获"><a href="#4-7-4-指针捕获" class="headerlink" title="4.7.4 指针捕获"></a>4.7.4 指针捕获</h3><p><strong>指针捕获可以被用于简化拖放类的交互。</strong></p><p><code>elem.setPointerCapture(pointerId)</code>将所有具有给定<code>pointerId</code>的后续事件重新定位到<code>elem</code>。</p><p>绑定会在以下情况下被移除：</p><ul><li>当<code>pointerup</code>或<code>pointercancel</code>事件出现时，绑定会被自动地移除。</li><li>当<code>elem</code>被从文档中移除后，绑定会被自动地移除。</li><li>当<code>elem.releasePointerCapture(pointerId)</code>被调用，绑定会被移除。</li></ul><p>在<a href="./js/dom/%E4%BA%8B%E4%BB%B6/%E6%BB%91%E5%8A%A8%E6%9D%A1.html">滑动条</a>的处理中，我们可以在<code>pointerdown</code>事件的处理程序中调用<code>thumb.setPointerCapture(event.pointerId)</code>， 这样接下来在<code>pointerup/cancel</code>之前发生的所有指针事件都会被重定向到<code>thumb</code>上。 当<code>pointerup</code>发生时（拖动完成），绑定会被自动移除，我们不需要关心它。 因此，即使用户在整个文档上移动指针，事件处理程序也将仅在<code>thumb</code>上被调用。尽管如此，事件对象的坐标属性，例如<code>clientX/clientY</code>仍将是正确的 —— 捕获仅影响<code>target/currentTarget</code>。</p><p>所以说这个操作一下子就简化了拖拽的问题，以前鼠标事件的时候，它因为不是完全水平的拖动，所以移动的范围在整个document文档里，但是现在只指向了thumb上，就节省了很多空间，也减少了bug。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">thumb.<span class="property">onpointerdown</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// 把所有指针事件（pointerup 之前发生的）重定向到 thumb</span></span><br><span class="line">  thumb.<span class="title function_">setPointerCapture</span>(event.<span class="property">pointerId</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始跟踪指针的移动</span></span><br><span class="line">  thumb.<span class="property">onpointermove</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 移动滑动条：在 thumb 上监听即可，因为所有指针事件都被重定向到了 thumb</span></span><br><span class="line">    <span class="keyword">let</span> newLeft = event.<span class="property">clientX</span> - slider.<span class="title function_">getBoundingClientRect</span>().<span class="property">left</span>;</span><br><span class="line">    thumb.<span class="property">style</span>.<span class="property">left</span> = newLeft + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当结束(pointerup)时取消对指针移动的跟踪</span></span><br><span class="line">  thumb.<span class="property">onpointerup</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    thumb.<span class="property">onpointermove</span> = <span class="literal">null</span>;</span><br><span class="line">    thumb.<span class="property">onpointerup</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// ...这里还可以处理“拖动结束”相关的逻辑</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：无需调用 thumb.releasePointerCapture，</span></span><br><span class="line"><span class="comment">// 它会在 pointerup 时被自动调用```</span></span><br></pre></td></tr></table></figure><p>言而总之，指针捕获为我们带来了两个好处： 代码变得更加简洁，我们不再需要在整个 document 上添加&#x2F;移除处理程序。绑定会被自动释放。 如果文档中有其他指针事件处理程序，则在用户拖动滑动条时，它们不会因指针的移动被意外地触发。</p><p>还有两个与指针捕获相关的事件： <code>gotpointercapture</code>会在一个元素使用<code>setPointerCapture</code>来启用捕获后触发。 <code>lostpointercapture</code>会在捕获被释放后触发：其触发可能是由于<code>releasePointerCapture</code>的显式调用，或是<code>pointerup/pointercancel</code>事件触发后的自动调用。</p><h2 id="4-8-键盘事件"><a href="#4-8-键盘事件" class="headerlink" title="4.8 键盘事件"></a>4.8 键盘事件</h2><p>键盘事件不光是指键盘内容的输入，因为现代设备中还包括语音识别或者是鼠标的复制粘贴等。</p><p>当一个按键被按下时，会触发<code>keydown</code>事件，当按键被释放时，会触发<code>keyup</code>事件</p><h3 id="4-8-1-event-code-和-event-key"><a href="#4-8-1-event-code-和-event-key" class="headerlink" title="4.8.1 event.code 和 event.key"></a>4.8.1 event.code 和 event.key</h3><p>事件对象的<code>key</code>属性允许获取字符，而事件对象的<code>code</code>属性则允许获取“物理按键代码”。</p><p>例如，同一个按键 Z，可以与或不与 Shift 一起按下。我们会得到两个不同的字符：小写的 z 和大写的 Z。 (所以说shift+字母能获得大写字母0.0，新知识)</p><p><code>event.key</code>正是这个字符，并且它将是不同的。但是,<code>event.code</code>是相同的：</p><p>key</p><p>event.key</p><p>event.code</p><p>z</p><p>z</p><p>KeyZ</p><p>z</p><p>Z(大写)</p><p>KeyZ</p><p>所以说，event.key代表的是其本身所显示的值，但是event.code代表的是其的位置</p><p>如果用户使用不同的语言，那么切换到另一种语言将产生完全不同的字符，而不是 “Z”。它将成为 event.key 的值，而 event.code 则始终都是一样的：”KeyZ”。</p><ul><li>字符键的代码为 <code>&quot;Key&lt;letter&gt;&quot;</code>：”KeyA”，”KeyB” 等。</li><li>数字键的代码为：<code>&quot;Digit&lt;number&gt;&quot;</code>：”Digit0”，”Digit1” 等。</li><li>特殊按键的代码为按键的名字：<code>&quot;Enter&quot;</code>，”Backspace”，”Tab” 等。</li></ul><p><strong>在event.code中”KeyZ” 的首字母必须大写。</strong></p><p><code>event.code</code>准确地标明了哪个键被按下了。例如，大多数键盘有两个 Shift 键，一个在左边，一个在右边。<code>event.code</code>会准确地告诉我们按下了哪个键，而<code>event.key</code>对按键的“含义”负责：它是什么（一个 “Shift”）。</p><hr><p>key</p><p>event.key</p><p>event.code</p><p>F1</p><p>F1</p><p>F1</p><p>Backspace</p><p>Backspace</p><p>Backspace</p><p>Shift</p><p>Shift</p><p>ShiftRight&#x2F;ShiftLeft</p><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">code</span> == <span class="string">&#x27;KeyZ&#x27;</span> &amp;&amp; (event.<span class="property">ctrlKey</span>  event.<span class="property">metaKey</span>)) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;Undo!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>给按键绑定一个ctrl+z的行为，就是event.code更好，因为event.code只代表位置，而event.key会随语言等产生变化。并且要兼容mac，所以需要metaKey</p><p>但是event.code也有问题，就是美式布局和德式布局的不同。（但是感觉现在用德式布局的很少哎）</p><p>所以说，对于会切换语言的问题，event.code更合适 而对于不同布局的问题，event.key更合适</p><p>如果按下一个键足够长的时间，它就会开始“自动重复”：keydown 会被一次又一次地触发，然后当按键被释放时，我们最终会得到 keyup。因此，有很多 keydown 却只有一个 keyup 是很正常的。 对于由自动重复触发的事件，event 对象的<code>event.repeat</code>属性被设置为 true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkPhoneKey</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (key &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; key &lt;= <span class="string">&#x27;9&#x27;</span>)  [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;ArrowLeft&#x27;</span>,<span class="string">&#x27;ArrowRight&#x27;</span>,<span class="string">&#x27;Delete&#x27;</span>,<span class="string">&#x27;Backspace&#x27;</span>].<span class="title function_">includes</span>(key);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onkeydown</span>=<span class="string">&quot;return checkPhoneKey(event.key)&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入手机号&quot;</span> <span class="attr">type</span>=<span class="string">&quot;tel&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>对手机号进行检查，如果无效输入则不会返回。</p><p><strong>即使我们对按键进行了过滤，但仍然可以使用鼠标右键单击 + 粘贴来输入任何内容。移动端设备提供了其他输入内容的方式。因此，这个过滤器并不是 100% 可靠。</strong></p><p>另一种方式是跟踪<code>oninput</code>事件 —— 在任何修改后都会触发此事件。这样我们就可以检查新的<code>input.value</code>，并在其无效时修改它&#x2F;高亮显示<code>&lt;input&gt;</code>。或者我们可以同时使用这两个事件处理程序。</p><h2 id="4-9-滚动事件"><a href="#4-9-滚动事件" class="headerlink" title="4.9 滚动事件"></a>4.9 滚动事件</h2><p>滚动事件通过<code>scroll</code>来进行，允许对页面或元素滚动做出反应。</p><p><code>scroll</code>事件在<code>window</code>和可滚动元素上都可以运行。</p><p>启动滚动的方式有很多，使用 CSS 的<code>overflow</code>属性更加可靠。</p><h1 id="五、表单属性和方法"><a href="#五、表单属性和方法" class="headerlink" title="五、表单属性和方法"></a>五、表单属性和方法</h1><p>学习关于表单（form）和<code>&lt;input&gt;</code>控件的属性和事件</p><p>表单可以从<code>document.forms</code>中找到 表单在document中是一个特殊的集合，其既是命名的，也是有序的。 所以可以通过名字或者在文档中的编号来获取表单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>.<span class="property">my</span>; <span class="comment">// name=&quot;my&quot; 的表单</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>]; <span class="comment">// 文档中的第一个表单</span></span><br></pre></td></tr></table></figure><p>当我们有了一个表单时，其中的任何元素都可以通过命名的集合<code>form.elements</code>来获取到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;form name=<span class="string">&quot;my&quot;</span>&gt;</span><br><span class="line">  &lt;input name=&quot;one&quot; value=&quot;1&quot;&gt;</span><br><span class="line">  &lt;input name=&quot;two&quot; value=&quot;2&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  // 获取表单</span><br><span class="line">  let form = document.forms.my; // &lt;form name=&quot;my&quot;&gt; 元素</span><br><span class="line"></span><br><span class="line">  // 获取表单中的元素</span><br><span class="line">  let elem = form.elements.one; // &lt;input name=&quot;one&quot;&gt; 元素</span><br><span class="line"></span><br><span class="line">  alert(elem.value); // 1</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>可能会有多个名字相同的元素，这种情况经常在处理单选按钮中出现。</p><p>在这种情况下,<code>form.elements[name]</code>将会是一个集合。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>];</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">let</span> ageElems = form.<span class="property">elements</span>.<span class="property">age</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">alert</span>(ageElems[<span class="number">0</span>]); <span class="comment">// [object HTMLInputElement]</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>可以通过<code>form[index/name]</code>来访问元素。 换句话说，我们可以将<code>form.elements.login</code>写成<code>form.login</code>。 这也有效，但是会有一个小问题：如果我们访问一个元素，然后修改它的 name，之后它仍然可以被通过旧的 name 访问到（当然也能通过新的 name 访问）。</p><p><strong>form可以反向引用</strong> 比如说我可以通过<code>form.element</code>来找到这个元素，那么也可以通过<code>element.form</code>来反向引用这个表单</p><p>我们可以通过<code>input.value</code>（字符串）或<code>input.checked</code>（布尔值）来访问复选框（checkbox）和单选按钮（radio button）中的 value。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input.<span class="property">value</span> = <span class="string">&quot;New value&quot;</span>;</span><br><span class="line">textarea.<span class="property">value</span> = <span class="string">&quot;New text&quot;</span>;</span><br><span class="line"></span><br><span class="line">input.<span class="property">checked</span> = <span class="literal">true</span>; <span class="comment">// 对于复选框（checkbox）或单选按钮（radio button）</span></span><br></pre></td></tr></table></figure><p><code>&lt;select&gt;元素就是下滑框</code> 一个<code>&lt;select&gt;</code>元素有 3 个重要的属性：</p><ul><li><code>select.options</code> —— <code>&lt;option&gt;</code>的子元素的集合，</li><li><code>select.value</code> —— 当前所选择的<code>&lt;option&gt;</code>的 value，</li><li><code>select.selectedIndex</code> —— 当前所选择的<code>&lt;option&gt;</code>的编号。</li></ul><p>它们提供了三种为<code>&lt;select&gt;</code>设置 value 的不同方式： 找到对应的<code>&lt;option&gt;</code>元素（例如在<code>select.options</code>中），并将其<code>option.selected</code>设置为 true。 如果我们知道新的值：将<code>select.value</code>设置为对应的新的值。 如果我们知道新的选项的索引：将<code>select.selectedIndex</code>设置为对应 <code>&lt;option&gt;</code>的编号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;select&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;apple&quot;</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;pear&quot;</span>&gt;</span>Pear<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;banana&quot;</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 下面这三行做的都是同一件事</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  select.<span class="property">options</span>[<span class="number">2</span>].<span class="property">selected</span> = <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  select.<span class="property">selectedIndex</span> = <span class="number">2</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  select.<span class="property">value</span> = <span class="string">&#x27;banana&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 请注意：选项编号是从零开始的，所以编号 2 表示的是第三项</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>如果<code>&lt;select&gt;</code>具有<code>multiple</code>特性（attribute），则允许多选。尽管这个特性（attribute）很少被用到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;select&quot;</span> multiple&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;blues&quot;</span> <span class="attr">selected</span>&gt;</span>Blues<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;rock&quot;</span> <span class="attr">selected</span>&gt;</span>Rock<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;classic&quot;</span>&gt;</span>Classic<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 从 multi-select 中获取所有选定的 `value`</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> selected = <span class="title class_">Array</span>.<span class="title function_">from</span>(select.<span class="property">options</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    .<span class="title function_">filter</span>(<span class="function"><span class="params">option</span> =&gt;</span> option.<span class="property">selected</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    .<span class="title function_">map</span>(<span class="function"><span class="params">option</span> =&gt;</span> option.<span class="property">value</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">alert</span>(selected); <span class="comment">// blues,rock</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>如何创建一个新的option <code>option = new Option(text, value, defaultSelected, selected);</code> 其中text代表文本，value代表值，defaultSelected如果为true，则selected特性会被创建，selected为true，则其会被选中</p><p><code>defaultSelected</code>和<code>selected</code>的区别是，<code>defaultSelected</code>设置的是 HTML-特性（attribute），我们可以使用<code>option.getAttribute(&#39;selected&#39;)</code> 来获得。而 selected 设置的是选项是否被选中。</p><p>在实际使用中，通常应该将同时将这两个值设置为 true 或 false。（或者，直接省略它们；两者都默认为 false。）</p><h2 id="5-1-聚焦（focus-x2F-blur）"><a href="#5-1-聚焦（focus-x2F-blur）" class="headerlink" title="5.1 聚焦（focus&#x2F;blur）"></a>5.1 聚焦（focus&#x2F;blur）</h2><p>当用户点击某个元素或使用键盘上的 Tab 键选中时，该元素将会获得聚焦（focus）。还有一个 HTML 特性（attribute）autofocus 可以让焦点在网页加载时默认落在一个元素上，此外还有其它途径可以获得焦点。</p><p>聚焦到一个元素通常意味着：“准备在此处接受数据”，所以，这正是我们可以运行代码以初始化所需功能的时刻。</p><p>失去焦点的时刻（“blur”）可能更为重要。它可能发生在用户点击页面的其它地方，或者按下 Tab 键跳转到下一个表单字段，亦或是其它途径的时候。</p><p>失去焦点通常意味着：“数据已经输入完成”，所以我们可以运行代码来检查它，甚至可以将其保存到服务器上，或进行其他操作。</p><p><strong>当元素聚焦时，会触发<code>focus</code>事件，当元素失去焦点时，会触发<code>blur</code>事件。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.invalid</span> &#123; <span class="attribute">border-color</span>: red; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-id">#error</span> &#123; <span class="attribute">color</span>: red &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Your email please: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;error&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">input.<span class="property">onblur</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span> (!input.<span class="property">value</span>.<span class="title function_">includes</span>(<span class="string">&#x27;@&#x27;</span>)) &#123; <span class="comment">// not email</span></span></span><br><span class="line"><span class="language-javascript">    input.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;invalid&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    error.<span class="property">innerHTML</span> = <span class="string">&#x27;Please enter a correct email.&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">input.<span class="property">onfocus</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;invalid&#x27;</span>)) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 移除 &quot;error&quot; 指示，因为用户想要重新输入一些内容</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;invalid&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    error.<span class="property">innerHTML</span> = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这段就是一个关于focus和blur的示例，当元素不聚焦时，如果输入框中的值不包含@，则会添加一个使框变红的类，并且添加一个错误信息。 而当元素再进入聚焦时，则会将这些信息清除掉。以此来重新输入信息</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.error</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Your email please: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:220px&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;make email invalid and try to focus here&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  input.<span class="property">onblur</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">value</span>.<span class="title function_">includes</span>(<span class="string">&#x27;@&#x27;</span>)) &#123; <span class="comment">// not email</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 显示 error</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;error&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// ...将焦点放回来</span></span></span><br><span class="line"><span class="language-javascript">      input.<span class="title function_">focus</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;error&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这段代码更有意思，其通过给非聚焦元素添加了一个设置焦点，从而使如果没有@这个符号，焦点就不会转移 所以说：可以通过<code>elem.focus()</code>来设置元素的焦点。或者通过<code>elem.blur()</code>来移除元素的焦点</p><p><strong>这段代码在除了火狐（bug）之外的浏览器上都可以正常工作。</strong></p><p><strong>JavaScript 导致的焦点丢失</strong></p><ul><li>一个 alert 会将焦点移至自身，因此会导致元素失去焦点（触发 blur 事件），而当 alert 对话框被取消时，焦点又回重新回到原元素上（触发 focus 事件）。</li><li>如果一个元素被从 DOM 中移除，那么也会导致焦点丢失。如果稍后它被重新插入到 DOM，焦点也不会回到它身上。</li></ul><p>这些特性有时候会导致 focus&#x2F;blur 处理程序发生异常 —— 在不需要它们时触发。</p><h3 id="5-1-1-tabindex-强行聚焦"><a href="#5-1-1-tabindex-强行聚焦" class="headerlink" title="5.1.1 tabindex(强行聚焦)"></a>5.1.1 tabindex(强行聚焦)</h3><p>默认情况下，很多元素不支持聚焦。</p><p>列表（list）在不同的浏览器表现不同，但有一件事总是正确的：focus&#x2F;blur 保证支持那些用户可以交互的元素：<code>&lt;button&gt;</code>，<code>&lt;input&gt;</code>，<code>&lt;select&gt;</code>，<code>&lt;a&gt;</code> 等。</p><p>另一方面，为了格式化某些东西而存在的元素像<code>&lt;div&gt;</code>，<code>&lt;span&gt;</code>和<code>&lt;table&gt;</code>—— 默认是不能被聚焦的。<code>elem.focus()</code>方法不适用于它们，并且 focus&#x2F;blur 事件也绝不会被触发。</p><p>使用 HTML-特性（attribute)<code>tabindex</code>可以改变这种情况。</p><p>任何具有<code>tabindex</code>特性的元素，都会变成可聚焦的。该特性的value是当使用 Tab（或类似的东西）在元素之间进行切换时，元素的顺序号。</p><p>也就是说：如果我们有两个元素，第一个具有<code>tabindex=&quot;1&quot;</code>，第二个具有 <code>tabindex=&quot;2&quot;</code>，然后当焦点在第一个元素的时候，按下 Tab 键，会使焦点移动到第二个元素身上。</p><p>切换顺序为：从 1 开始的具有 tabindex 的元素排在前面（按 tabindex 顺序），然后是不具有 tabindex 的元素（例如常规的<code>&lt;input&gt;</code>）。</p><p>不具有 tabindex 的元素按文档源顺序（默认顺序）切换。</p><p><strong>特殊情况</strong></p><ul><li><p><code>tabindex=&quot;0&quot;</code>会使该元素被与那些不具有 tabindex 的元素放在一起。也就是说，当我们切换元素时，具有 <code>tabindex=&quot;0&quot;</code>的元素将排在那些具有 tabindex ≥ 1 的元素的后面。 通常，它用于使元素具有焦点，但是保留默认的切换顺序。使元素成为与<code>&lt;input&gt;</code>一样的表单的一部分。</p></li><li><p><code>tabindex=&quot;-1&quot;</code>只允许以编程的方式聚焦于元素。Tab 键会忽略这样的元素，但是 <code>elem.focus()</code>有效。</p></li></ul><p>我们可以使用<code>elem.tabIndex</code>通过 JavaScript 来添加<code>tabindex</code>。效果是一样的。</p><h3 id="5-1-2-委托"><a href="#5-1-2-委托" class="headerlink" title="5.1.2 委托"></a>5.1.2 委托</h3><p><code>focus</code>和<code>blur</code>事件不会向上冒泡。</p><p>因为当用户聚焦于<code>&lt;input&gt;</code>时，focus 事件只会在该<code>&lt;input&gt;</code>上触发。它不会向上冒泡。所以<code>form.onfocus</code>永远不会触发。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;form&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Name&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;surname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Surname&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"> <span class="selector-class">.focused</span> &#123; <span class="attribute">outline</span>: <span class="number">1px</span> solid red; &#125; </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 将处理程序置于捕获阶段（最后一个参数为 true）</span></span></span><br><span class="line"><span class="language-javascript">  form.<span class="title function_">addEventListener</span>(<span class="string">&quot;focus&quot;</span>, <span class="function">() =&gt;</span> form.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;focused&#x27;</span>), <span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">  form.<span class="title function_">addEventListener</span>(<span class="string">&quot;blur&quot;</span>, <span class="function">() =&gt;</span> form.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;focused&#x27;</span>), <span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以通过在捕获阶段添加focus事件来解决问题</p><p>或者说可以通过<code>focusin</code>和<code>focusout</code>事件来进行，其和<code>focus/blur</code>完全一样，但是他们会冒泡。</p><p>值得注意的是，必须使用<code>elem.addEventListener</code>来分配它们，而不是 <code>on&lt;event&gt;</code>。</p><h2 id="5-2-事件：change、input、cut、copy、paste"><a href="#5-2-事件：change、input、cut、copy、paste" class="headerlink" title="5.2 事件：change、input、cut、copy、paste"></a>5.2 事件：change、input、cut、copy、paste</h2><h3 id="5-2-1-change"><a href="#5-2-1-change" class="headerlink" title="5.2.1 change"></a>5.2.1 change</h3><p>当元素更改完成时，将触发<code>change</code>事件。 对于文本输入框，当其失去焦点时，就会触发<code>change</code>事件。</p><p>例如，当我们在下面的文本字段中键入内容时 —— 不会触发 change 事件。但是，当我们将焦点移到其他位置时，例如，点击按钮 —— 就会触发 change 事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> onchange=<span class="string">&quot;alert(this.value)&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Button&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>对于其它元素：<code>select</code>，<code>input type=checkbox/radio</code>，会在选项更改后立即触发change事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;select onchange=<span class="string">&quot;alert(this.value)&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>Select something<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>Option 1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>Option 2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span>Option 3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h3 id="5-2-2-input"><a href="#5-2-2-input" class="headerlink" title="5.2.2 input"></a>5.2.2 input</h3><p>每当用户对输入值进行修改后，就会触发<code>input</code>事件。</p><p>与键盘事件不同，只要值改变了，<code>input</code>事件就会触发，即使那些不涉及键盘行为（action）的值的更改也是如此：使用鼠标粘贴，或者使用语音识别来输入文本。</p><p>如果我们想要处理对<code>&lt;input&gt;</code>的每次更改，那么<code>oninput</code>事件是最佳选择。</p><p>另一方面，input 事件不会在那些不涉及值更改的键盘输入或其他行为上触发，例如在输入时按方向键 ⇦ ⇨。</p><p>当输入值更改后，就会触发<code>input</code>事件。</p><p>所以，我们无法使用<code>event.preventDefault()</code> —— 已经太迟了，不会起任何作用了。</p><h3 id="5-2-3-cut、copy、paste"><a href="#5-2-3-cut、copy、paste" class="headerlink" title="5.2.3 cut、copy、paste"></a>5.2.3 cut、copy、paste</h3><p>这些事件发生于剪切&#x2F;拷贝&#x2F;粘贴一个值的时候。 它们属于 <a href="https://www.w3.org/TR/clipboard-apis/#clipboard-event-interfaces">ClipboardEvent</a> 类，并提供了对剪切&#x2F;拷贝&#x2F;粘贴的数据的访问方法。 我们也可以使用<code>event.preventDefault()</code>来中止行为，然后什么都不会被复制&#x2F;粘贴。</p><p>下面的代码阻止了剪切&#x2F;拷贝&#x2F;粘贴的事件，并显示出了我们所尝试剪切&#x2F;拷贝&#x2F;粘贴的内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  input.<span class="property">onpaste</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;paste: &quot;</span> + event.<span class="property">clipboardData</span>.<span class="title function_">getData</span>(<span class="string">&#x27;text/plain&#x27;</span>));</span></span><br><span class="line"><span class="language-javascript">    event.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  input.<span class="property">oncut</span> = input.<span class="property">oncopy</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(event.<span class="property">type</span> + <span class="string">&#x27;-&#x27;</span> + <span class="variable language_">document</span>.<span class="title function_">getSelection</span>());</span></span><br><span class="line"><span class="language-javascript">    event.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在剪切&#x2F;复制事件处理程序中调用<code>event.clipboardData.getData(...)</code>只会得到一个空字符串。从技术上讲，这是因为此时数据还未存入剪切板。如果我们使用<code>event.preventDefault()</code>，则它根本不会被复制。</p><p>所以上面的例子中使用<code>document.getSelection()</code>来得到被选中的文本。</p><p>我们不仅可以复制&#x2F;粘贴文本，也可以复制&#x2F;粘贴其他各种内容。例如，我们可以在操作系统的文件管理器中复制一个文件并进行粘贴。</p><p>这是因为<code>clipboardData</code>实现了<code>DataTransfer</code>接口，通常用于拖放和复制&#x2F;粘贴。这超出了本文所讨论的范围，但你可以在<a href="https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface">DataTransfer规范</a> 中进行详细了解。</p><p>另外，还有一个可以访问剪切板的异步API：<code>navigator.clipboard</code>，详见 <a href="https://www.w3.org/TR/clipboard-apis/">Clipboard API 和事件规范</a></p><h3 id="5-2-4-安全限制"><a href="#5-2-4-安全限制" class="headerlink" title="5.2.4 安全限制"></a>5.2.4 安全限制</h3><p>剪贴板是“全局”操作系统级别的东西。用户可能会在各种应用程序之间切换，复制&#x2F;粘贴不同的内容，而浏览器页面不应该能访问这些内容。</p><p>因此，大多数浏览器仅允许在某些用户操作范围内（例如复制&#x2F;粘贴等）对剪切板进行无缝的读&#x2F;写访问。</p><p>除火狐（Firefox）浏览器外，所有浏览器都禁止使用<code>dispatchEvent</code>生成“自定义”剪贴板事件，即使我们设法调度此类事件。规范也明确声明了，合成（syntetic）事件不得提供对剪切板的访问权限。</p><p>此外，如果有人想将<code>event.clipboardData</code>保存在事件处理程序中，然后稍后再访问它 —— 这也不会生效。</p><p>重申，<code>event.clipboardData</code>仅在用户启动的事件处理程序的上下文中生效。</p><p>另外, <code>navigator.clipboard</code>是一个较新的 API，适用于任何上下文。如果需要，它会请求用户的许可。火狐（Firefox）浏览器尚未支持。</p><h2 id="5-3-表单：事件和方法提交"><a href="#5-3-表单：事件和方法提交" class="headerlink" title="5.3 表单：事件和方法提交"></a>5.3 表单：事件和方法提交</h2><p>提交表单时，会触发<code>submit</code>事件，它通常用于在将表单发送到服务器之前对表单进行校验，或者中止提交，并使用 JavaScript 来处理表单。</p><p><code>form.submit()</code>方法允许从 JavaScript 启动表单发送。我们可以使用此方法动态地创建表单，并将其发送到服务器。</p><h3 id="5-3-1-submit"><a href="#5-3-1-submit" class="headerlink" title="5.3.1 submit"></a>5.3.1 submit</h3><p>提交表单主要有两种方式：</p><ol><li>第一种 —— 点击<code>&lt;input type=&quot;submit&quot;&gt;</code>或<code>&lt;input type=&quot;image&quot;&gt;</code>。</li><li>第二种 —— 在 input 字段中按下 Enter 键。</li></ol><p>这两个行为都会触发表单的 submit 事件。处理程序可以检查数据，如果有错误，就显示出来，并调用<code>event.preventDefault()</code>，这样表单就不会被发送到服务器了。</p><p><strong>在输入框中使用 Enter 发送表单时，会在<code>&lt;input type=&quot;submit&quot;&gt;</code>上触发一次 <code>click</code>事件。</strong> 但实际上，其没有进行点击</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return false&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">size</span>=<span class="string">&quot;30&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Focus here and press enter&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;click&#x27;)&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-3-2-手动提交"><a href="#5-3-2-手动提交" class="headerlink" title="5.3.2 手动提交"></a>5.3.2 手动提交</h3><p>如果要手动将表单提交到服务器，我们可以调用<code>form.submit()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;form&#x27;</span>);</span><br><span class="line">form.<span class="property">action</span> = <span class="string">&#x27;https://google.com/search&#x27;</span>;</span><br><span class="line">form.<span class="property">method</span> = <span class="string">&#x27;GET&#x27;</span>;</span><br><span class="line"></span><br><span class="line">form.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;input name=&quot;q&quot; value=&quot;test&quot;&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该表单必须在文档中才能提交</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(form);</span><br><span class="line"></span><br><span class="line">form.<span class="title function_">submit</span>();</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;二、dom介绍&quot;&gt;&lt;a href=&quot;#二、dom介绍&quot; class=&quot;headerlink&quot; title=&quot;二、dom介绍&quot;&gt;&lt;/a&gt;二、dom介绍&lt;/h1&gt;&lt;h2 id=&quot;2-1-dom-简介&quot;&gt;&lt;a href=&quot;#2-1-dom-简介&quot; class=&quot;headerlink&quot; title=&quot;2.1 dom 简介&quot;&gt;&lt;/a&gt;2.1 dom 简介&lt;/h2&gt;&lt;p&gt;DOM –&amp;gt; Document Object Model 文档对象模型 文档表示的就是整个的 HTML 网页文档 对象表示将网页中的每一个部分都转换成一个对象 模型表示对象之间的关系，从而方便获取对象 &lt;strong&gt;通过 DOM 将所有页面内容表示为可以修改的对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;window 是&lt;strong&gt;根对象&lt;/strong&gt;，首先，它是 JavaScript 代码的全局对象。其次，它代表“浏览器窗口”，并提供了控制它的方法。&lt;/p&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>SimCLRv2</title>
    <link href="http://example.com/2022/05/26/simclrv2/"/>
    <id>http://example.com/2022/05/26/simclrv2/</id>
    <published>2022-05-26T08:11:20.000Z</published>
    <updated>2023-03-20T08:32:37.181Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-1653552327889.png" alt="file"> SimCLRv2 和 SimCLR 的区别并不是很大，它的主要贡献是提出<strong>经过训练的无监督模型很适合去做半监督学习</strong>。 模型的区别主要是三个点：</p><ol><li>从 resnet50 到 152-layer-resnet，整了个更大的模型</li><li>加深了 projection head 的深度，变成了两层</li><li>动量编码器</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-1653552327889.png&quot; alt=&quot;file&quot;&gt; SimCLRv2 和 SimCLR 的区别并不是很大，它的主要贡献是提出&lt;strong</summary>
      
    
    
    
    <category term="计算机视觉" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
  </entry>
  
</feed>
