<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小吴的Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-29T09:00:58.431Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Wh&amp;CC</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>牛客输入输出</title>
    <link href="http://example.com/2023/03/29/%E7%89%9B%E5%AE%A2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>http://example.com/2023/03/29/%E7%89%9B%E5%AE%A2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</id>
    <published>2023-03-29T03:39:00.000Z</published>
    <updated>2023-03-29T09:00:58.431Z</updated>
    
    <content type="html"><![CDATA[<h3 id="牛客输入输出——以JS为例"><a href="#牛客输入输出——以JS为例" class="headerlink" title="牛客输入输出——以JS为例"></a>牛客输入输出——以JS为例</h3><p>牛客的JS输入输出是以node.js为基础整的，反正有点恶心-。-</p><p>每种输入前三行是示例内容，为固定内容</p><h4 id="单行输入"><a href="#单行输入" class="headerlink" title="单行输入"></a>单行输入</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rl = <span class="built_in">require</span>(<span class="string">&quot;readline&quot;</span>).<span class="title function_">createInterface</span>(&#123; <span class="attr">input</span>: process.<span class="property">stdin</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> iter = rl[<span class="title class_">Symbol</span>.<span class="property">asyncIterator</span>]();</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">readline</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; (<span class="keyword">await</span> iter.<span class="title function_">next</span>()).<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> line = <span class="keyword">await</span> <span class="title function_">readline</span>(); <span class="comment">//获得的是一个字符串</span></span><br><span class="line">    <span class="comment">//如果需要对其进行处理，比如 “1 2 3 4 5”，想以数组形式获取每个数字</span></span><br><span class="line">    <span class="keyword">let</span> arr = line.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>); <span class="comment">// 数组内元素为字符串，eg: arr[0]=&quot;1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>单行输入只能适用于一行的输入，不以空格作为分割符</p><span id="more"></span><h4 id="多行输入"><a href="#多行输入" class="headerlink" title="多行输入"></a>多行输入</h4><p>多行输入可以通过循环方法或几次单行输入来分别读取每行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rl = <span class="built_in">require</span>(<span class="string">&quot;readline&quot;</span>).<span class="title function_">createInterface</span>(&#123; <span class="attr">input</span>: process.<span class="property">stdin</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> iter = rl[<span class="title class_">Symbol</span>.<span class="property">asyncIterator</span>]();</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">readline</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; (<span class="keyword">await</span> iter.<span class="title function_">next</span>()).<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 代码应该写在这个while循环里</span></span><br><span class="line">    <span class="keyword">while</span>(line = <span class="keyword">await</span> <span class="title function_">readline</span>())&#123;</span><br><span class="line">        <span class="keyword">let</span> tokens = line.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> a = <span class="built_in">parseInt</span>(tokens[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">parseInt</span>(tokens[<span class="number">1</span>])</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(tokens);        <span class="comment">// 使输入字符串变为了数组形式</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a+b);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>用一个例子来说明：</p><h5 id="输入n个整数，输出其中最小的k个"><a href="#输入n个整数，输出其中最小的k个" class="headerlink" title="输入n个整数，输出其中最小的k个"></a>输入n个整数，输出其中最小的k个</h5><p>这道题是典型的<strong>多行输入且每次操作不同</strong>：输入了两行，需要用两个 readline 分别读取。</p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230329164012779.png" alt="image-20230329164012779"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rl = <span class="built_in">require</span>(<span class="string">&quot;readline&quot;</span>).<span class="title function_">createInterface</span>(&#123; <span class="attr">input</span>: process.<span class="property">stdin</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> iter = rl[<span class="title class_">Symbol</span>.<span class="property">asyncIterator</span>]();</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">readline</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; (<span class="keyword">await</span> iter.<span class="title function_">next</span>()).<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 代码应该写在这个while循环里</span></span><br><span class="line">    <span class="keyword">while</span> (input = <span class="keyword">await</span> <span class="title function_">readline</span>()) &#123; <span class="comment">// 获取输入更方便 ‘5 2’</span></span><br><span class="line">        <span class="comment">// input.split(&#x27; &#x27;) // [&#x27;5&#x27;, &#x27;2&#x27;]</span></span><br><span class="line">        <span class="keyword">let</span> n = <span class="title class_">Number</span>(input.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>]) <span class="comment">// 5</span></span><br><span class="line">        <span class="keyword">let</span> k = <span class="title class_">Number</span>(input.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>]) <span class="comment">// 2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// #2. 第二个 readline() 获取第二行输入 //  &#x27;1 3 5 7&#x27;</span></span><br><span class="line">        <span class="comment">// trim() 去除字符串的头尾空格</span></span><br><span class="line">        <span class="comment">// readline().trim().split(&#x27; &#x27;) // [&#x27;1&#x27;, &#x27;3&#x27;, &#x27;5&#x27;, &#x27;7&#x27;]</span></span><br><span class="line">        <span class="keyword">let</span> arr = <span class="keyword">await</span> <span class="title function_">readline</span>();</span><br><span class="line">        <span class="keyword">let</span> arrr = arr.<span class="title function_">trim</span>().<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 排序 sor()</span></span><br><span class="line">        arrr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a - b</span><br><span class="line">        &#125;);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">const</span> res = arrr.<span class="title function_">splice</span>(<span class="number">0</span> , k).<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>通过两个readline，第一个readline读取第一行的数据，第二个readline读取第二行数据</p><p>或者说可以通过多个单行选取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rl = <span class="built_in">require</span>(<span class="string">&quot;readline&quot;</span>).<span class="title function_">createInterface</span>(&#123; <span class="attr">input</span>: process.<span class="property">stdin</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> iter = rl[<span class="title class_">Symbol</span>.<span class="property">asyncIterator</span>]();</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">readline</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; (<span class="keyword">await</span> iter.<span class="title function_">next</span>()).<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="keyword">await</span> <span class="title function_">readline</span>();</span><br><span class="line"><span class="keyword">let</span> k = <span class="keyword">await</span> <span class="built_in">parseInt</span>(<span class="title function_">readline</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>感觉这种比较方便</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;牛客输入输出——以JS为例&quot;&gt;&lt;a href=&quot;#牛客输入输出——以JS为例&quot; class=&quot;headerlink&quot; title=&quot;牛客输入输出——以JS为例&quot;&gt;&lt;/a&gt;牛客输入输出——以JS为例&lt;/h3&gt;&lt;p&gt;牛客的JS输入输出是以node.js为基础整的，反正有点恶心-。-&lt;/p&gt;
&lt;p&gt;每种输入前三行是示例内容，为固定内容&lt;/p&gt;
&lt;h4 id=&quot;单行输入&quot;&gt;&lt;a href=&quot;#单行输入&quot; class=&quot;headerlink&quot; title=&quot;单行输入&quot;&gt;&lt;/a&gt;单行输入&lt;/h4&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; rl = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;readline&amp;quot;&lt;/span&gt;).&lt;span class=&quot;title function_&quot;&gt;createInterface&lt;/span&gt;(&amp;#123; &lt;span class=&quot;attr&quot;&gt;input&lt;/span&gt;: process.&lt;span class=&quot;property&quot;&gt;stdin&lt;/span&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; iter = rl[&lt;span class=&quot;title class_&quot;&gt;Symbol&lt;/span&gt;.&lt;span class=&quot;property&quot;&gt;asyncIterator&lt;/span&gt;]();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;readline&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) =&amp;gt; (&lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; iter.&lt;span class=&quot;title function_&quot;&gt;next&lt;/span&gt;()).&lt;span class=&quot;property&quot;&gt;value&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; line = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;readline&lt;/span&gt;(); &lt;span class=&quot;comment&quot;&gt;//获得的是一个字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//如果需要对其进行处理，比如 “1 2 3 4 5”，想以数组形式获取每个数字&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; arr = line.&lt;span class=&quot;title function_&quot;&gt;split&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot; &amp;quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 数组内元素为字符串，eg: arr[0]=&amp;quot;1&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;单行输入只能适用于一行的输入，不以空格作为分割符&lt;/p&gt;</summary>
    
    
    
    <category term="面试相关" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>restful-api</title>
    <link href="http://example.com/2023/03/27/restful-api/"/>
    <id>http://example.com/2023/03/27/restful-api/</id>
    <published>2023-03-27T06:39:38.000Z</published>
    <updated>2023-03-27T09:29:45.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/v2-5016de164cff86f8aa48e9c108dc20bc_r.jpg" alt="img"></p><p>RESTful API是一套结构清晰、符合标准、易于理解、拓展方便的<strong>接口风格</strong>。</p><p>REST（英文：Representational State Transfer，简称REST，直译过来表现层状态转换）是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><p><strong>REST并没有一个明确的标准，而更像是一种设计的风格</strong>，满足这种设计风格的程序或接口我们称之为RESTful(从单词字面来看就是一个形容词)。所以RESTful API 就是满足REST架构风格的接口。</p><span id="more"></span><h4 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h4><ol><li><strong>以资源为基础：</strong>资源可以是一个图片、音乐、一个XML格式、HTML格式或者JSON格式等网络上的一个实体，除了一些二进制的资源外普通的文本资源更多以JSON为载体、面向用户的一组数据(通常从数据库中查询而得到)。</li><li><strong>统一接口</strong>: 对资源的操作包括获取、创建、修改和删除，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。换言而知，使用RESTful风格的接口可能只能定位其资源，但是无法知晓它具体进行了什么操作，需要具体了解其发生了什么操作动作要从其HTTP请求方法类型上进行判断。具体的HTTP方法和方法含义如下：<ul><li>GET（SELECT）：从服务器取出资源（一项或多项）。</li><li>POST（CREATE）：在服务器新建一个资源。</li><li>PUT（UPDATE）：在服务器更新资源（客户端提供完整资源数据）。</li><li>PATCH（UPDATE）：在服务器更新资源（客户端提供需要修改的资源数据）。</li><li>DELETE（DELETE）：从服务器删除资源。</li></ul></li></ol><p>当然也有很多在具体使用的时候使用PUT表示更新。从请求的流程来看，RESTful API和传统API大致架构如下：</p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/v2-4c87f23be230fdf16dc99398781ebb1b_r.jpg" alt="img"></p><ol start="3"><li><p><strong>URI指向资源</strong>：URI &#x3D; Universal Resource Identifier 统一资源标志符，用来标识抽象或物理资源的一个紧凑字符串。URI包括URL和URN，在这里更多时候可能代指URL(统一资源定位符)。RESTful是<strong>面向资源</strong>的，每种资源可能由一个或多个URI对应，但一个URI只指向一种资源。</p></li><li><p><strong>无状态</strong>：服务器不能保存客户端的信息， 每一次从客户端发送的请求中，<strong>要包含所有必须的状态信息</strong>，会话信息由客户端保存， 服务器端根据这些状态信息来处理请求。 当客户端可以切换到一个新状态的时候发送请求信息， 当一个或者多个请求被发送之后, 客户端就处于一个状态变迁过程中。 每一个应用的状态描述可以被客户端用来初始化下一次的状态变迁。</p></li></ol><h4 id="REST架构限制条件"><a href="#REST架构限制条件" class="headerlink" title="REST架构限制条件"></a>REST架构限制条件</h4><p><strong>客户端-服务端（Client-Server）</strong>: 这个更专注客户端和服务端的分离，服务端独立可更好服务于前端、安卓、IOS等客户端设备。</p><p><strong>无状态（Stateless）</strong>：服务端不保存客户端状态，客户端保存状态信息每次请求携带状态信息。</p><p><strong>可缓存性（Cacheability）</strong> ：服务端需回复是否可以缓存以让客户端甄别是否缓存提高效率。</p><p><strong>统一接口（Uniform Interface）</strong>：通过一定原则设计接口降低耦合，简化系统架构，这是RESTful设计的基本出发点。</p><p><strong>分层系统（Layered System）</strong>：客户端无法直接知道连接的到终端还是中间设备，分层允许你灵活的部署服务端项目。</p><p><strong>按需代码（Code-On-Demand，可选）</strong>：按需代码允许我们灵活的发送一些看似特殊的代码给客户端例如JavaScript代码。</p><h3 id="RESTful-API设计规范"><a href="#RESTful-API设计规范" class="headerlink" title="RESTful API设计规范"></a>RESTful API设计规范</h3><p>URL为统一资源定位器 ,接口属于服务端资源，首先要通过URL这个定位到资源才能去访问，而通常一个完整的URL组成由以下几个部分构成：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URI = scheme &quot;://&quot; host  &quot;:&quot;  port &quot;/&quot; path [ &quot;?&quot; query ][ &quot;#&quot; fragment ]</span><br></pre></td></tr></table></figure><ul><li>scheme: 指底层用的协议，如http、https、ftp</li><li>host: 服务器的IP地址或者域名</li><li>port: 端口，http默认为80端口</li><li>path: 访问资源的路径，就是各种web 框架中定义的route路由</li><li>query: 查询字符串，为发送给服务器的参数，在这里更多发送数据分页、排序等参数</li><li>fragment: 锚点，定位到页面的资源</li></ul><p>我们在设计API时URL的path是需要认真考虑的，而RESTful对path的设计做了一些规范，通常一个RESTful API的path组成如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;</span><br></pre></td></tr></table></figure><p>version：API版本号，有些版本号放置在头信息中也可以，通过控制版本号有利于应用迭代。<br>resources：资源，RESTful API推荐用小写英文单词的复数形式。<br>resource_id：资源的id，访问或操作该资源。</p><p>当然，有时候可能资源级别较大，其下还可细分很多子资源也可以灵活设计URL的path，例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;/&#123;subresources&#125;/&#123;subresource_id&#125;</span><br></pre></td></tr></table></figure><p>此外，有时可能增删改查无法满足业务要求，可以在URL末尾加上action，例如</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;/action</span><br></pre></td></tr></table></figure><p>其中action就是对资源的操作。</p><h4 id="具体设计规范"><a href="#具体设计规范" class="headerlink" title="具体设计规范"></a>具体设计规范</h4><p>从大体样式了解URL路径组成之后，对于RESTful API的URL具体设计的规范如下：</p><ol><li>不用大写字母，所有单词使用英文且小写。</li><li>连字符用中杠<code>&quot;-&quot;</code>而不用下杠<code>&quot;_&quot;</code></li><li>正确使用 <code>&quot;/&quot;</code>表示层级关系,URL的层级不要过深，并且越靠前的层级应该相对越稳定</li><li>结尾不要包含正斜杠分隔符<code>&quot;/&quot;</code></li><li><strong>URL中不出现动词，用请求方式表示动作</strong></li><li>资源表示用复数不要用单数</li><li>不要使用文件扩展名</li></ol><h4 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /collection：从服务器查询资源的列表（数组）</span><br><span class="line">GET /collection/resource：从服务器查询单个资源</span><br><span class="line">POST /collection：在服务器创建新的资源</span><br><span class="line">PUT /collection/resource：更新服务器资源</span><br><span class="line">DELETE /collection/resource：从服务器删除资源</span><br></pre></td></tr></table></figure><p>在非RESTful风格的API中，我们通常使用GET请求和POST请求完成增删改查以及其他操作，查询和删除一般使用GET方式请求，更新和插入一般使用POST请求。从请求方式上无法知道API具体是干嘛的，所有在URL上都会有操作的动词来表示API进行的动作，例如：query，add，update，delete等等。</p><p>而RESTful风格的API则<strong>要求在URL上都以名词的方式出现</strong>，从几种请求方式上就可以看出想要进行的操作，这点与非RESTful风格的API形成鲜明对比。</p><p>在谈及GET,POST,PUT,DELETE的时候，就必须提一下接口的<strong>安全性和幂等性</strong>，其中安全性是指方法不会修改资源状态，即读的为安全的，写的操作为非安全的。而幂等性的意思是操作一次和操作多次的最终效果相同，客户端重复调用也只返回同一个结果。</p><p>上述四个HTTP请求方法的安全性和幂等性如下：</p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/v2-3d59c2beffb51d40d7c05fcf83ed372c_r.jpg" alt="img"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>RESTful风格的API 固然很好很规范，但大多数互联网公司并没有按照或者完全按照其规则来设计，因为REST是一种风格，而不是一种约束或规则，过于理想的RESTful API 会付出太多的成本。</p><p>比如RESTful API也有一些缺点</p><ul><li>比如操作方式繁琐，RESTful API通常根据GET、POST、PUT、DELETE 来区分操作资源的动作，而HTTP Method 本身不可直接见，是隐藏的，而如果将动作放到URL的path上反而清晰可见，更利于团队的理解和交流。</li><li>并且有些浏览器对GET,POST之外的请求支持不太友好，还需要特殊额外的处理。</li><li>过分强调资源，而实际业务API可能有各种需求比较复杂，单单使用资源的增删改查可能并不能有效满足使用需求，强行使用RESTful风格API只会增加开发难度和成本。</li></ul><p>所以，当你或你们的技术团队在设计API的时候，如果使用场景和REST风格很匹配，那么你们可以采用RESTful 风格API。但是如果业务需求和RESTful风格API不太匹配或者很麻烦，那也可以不用RESTful风格API或者可以借鉴一下，毕竟无论那种风格的API都是为了方便团队开发、协商以及管理，不能墨守成规。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;RESTful-API&quot;&gt;&lt;a href=&quot;#RESTful-API&quot; class=&quot;headerlink&quot; title=&quot;RESTful API&quot;&gt;&lt;/a&gt;RESTful API&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://blogwh.oss-cn-beijing.aliyuncs.com/img/v2-5016de164cff86f8aa48e9c108dc20bc_r.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;RESTful API是一套结构清晰、符合标准、易于理解、拓展方便的&lt;strong&gt;接口风格&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;REST（英文：Representational State Transfer，简称REST，直译过来表现层状态转换）是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;REST并没有一个明确的标准，而更像是一种设计的风格&lt;/strong&gt;，满足这种设计风格的程序或接口我们称之为RESTful(从单词字面来看就是一个形容词)。所以RESTful API 就是满足REST架构风格的接口。&lt;/p&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Next.js</title>
    <link href="http://example.com/2023/03/14/Next-js/"/>
    <id>http://example.com/2023/03/14/Next-js/</id>
    <published>2023-03-14T06:52:51.000Z</published>
    <updated>2023-03-27T09:29:46.720Z</updated>
    
    <content type="html"><![CDATA[<p>官网：<a href="https://nextjs.org/">https://nextjs.org/</a></p><p><strong>为前端工程师提供全栈解决方案</strong></p><h3 id="React和next-js的区别"><a href="#React和next-js的区别" class="headerlink" title="React和next.js的区别"></a>React和next.js的区别</h3><ol><li><p>next.js基于React框架，React不解决路由、样式、状态这些，只是单纯的负责打通html和js</p></li><li><p>React是单页面应用，但是next.js会生成多个页面</p></li></ol><span id="more"></span><h2 id="create-next-app"><a href="#create-next-app" class="headerlink" title="create next-app"></a>create next-app</h2><ol><li><p>创建项目：<code>yarn create next-app</code></p></li><li><p><code>package.json</code>里可以查看一些选项：dev是开发模式；使用build构建脚本；start用于生产环境；全静态网页使用export命令</p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230314152116747.png" alt="image-20230314152116747"></p></li><li><p>生产模式（build &amp; start）的运行过程：</p><ol><li>将现有代码生成一份静态页面，比如生成了静态的Index.html</li><li>首先加载静态界面，然后加载js脚本，之后再通过js脚本将页面重新渲染一遍</li><li>所以说等于build的过程是生成静态页面和动态js脚本，是一个动静结合的过程</li></ol><p>所以说next.js生成的服务是需要运行在服务器上的，比如页面响应等内容是通过next来进行操作的，如果想生成纯静态页面，则需要使用<code>next export</code>命令</p></li></ol><h2 id="静态路由和动态路由"><a href="#静态路由和动态路由" class="headerlink" title="静态路由和动态路由"></a>静态路由和动态路由</h2><h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><p>next中的静态路由通过pages下面的页面来实现</p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230314155444669.png" alt="image-20230314155444669"></p><p>如上图所示，如果在pages页面中添加了一个about页面，则可以通过&#x2F;about来访问这个页面</p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230314155534736.png" alt="image-20230314155534736"></p><p>可以通过往pages目录中添加子文件夹来实现嵌套路由</p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230314155905260.png" alt="image-20230314155905260"></p><p>比如现在pages文件夹中存在名为posts的子文件夹，而这个文件夹中存在index和post</p><ul><li><p>通过<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230314160023786.png" alt="image-20230314160023786">来访问post</p></li><li><p>通过<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230314160057639.png" alt="image-20230314160057639">来访问posts&#x2F;index</p></li></ul><p><strong>嵌套路由可以一直叠加</strong></p><p>如果pages文件夹中存在404、500等特殊页面，则会替代它自动生成的特殊页面</p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>next使用带中括号的名称来标记动态路由。例如：<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230314160800455.png" alt="image-20230314160800455"></p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230314161235512.png" alt="image-20230314161235512"></p><p>通过next中提供的hook，即<code>useRouter()</code>便可以得到此时的路由参数</p><p>同理，文件夹也可以通过中括号的形式来完成动态路由</p><p>另一种方式可以通过<code>[...params].tsx</code>这种形式来实现动态路由</p><p>如果是两层中括号的形式，则表示这个动态路由是可有可无的，例如：<code>[[...params]].tsx</code></p><p>这种动态路由的好处就是可以获得多个参数</p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230314163632195.png" alt="image-20230314163632195"></p><p>例如上图就是有who和what两个参数</p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230314164034403.png" alt="image-20230314164034403"></p><p>同理，获得参数还是使用<code>useRouter()</code>这个hook</p><h2 id="页面加载时获取数据"><a href="#页面加载时获取数据" class="headerlink" title="页面加载时获取数据"></a>页面加载时获取数据</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useState,useEffect&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Page</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [dt,setDT] = <span class="title function_">useState</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> [data, setData] = useState&lt;<span class="built_in">any</span>[]&gt;([])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">fetchData</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">fetch</span>(<span class="string">&#x27;https://dummyjson.com/posts&#x27;</span>)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> response.<span class="title function_">json</span>()</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">reply</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">setData</span>(reply.<span class="property">posts</span>)</span><br><span class="line">            <span class="title function_">setDT</span>((<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">toString</span>())</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">fetchData</span>()</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>posts List Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;dt&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;data.map((item) =&gt; (</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                ))</span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过react中已有的一些hook去抓取数据，首先生成了静态页面，但是数据是动态抓取的</p><h2 id="构建页面时获取数据生成静态界面"><a href="#构建页面时获取数据生成静态界面" class="headerlink" title="构建页面时获取数据生成静态界面"></a>构建页面时获取数据生成静态界面</h2><p><strong>爬虫搞不定动态页面加载</strong></p><p>通过暴露一个静态页面函数，通过这个静态页面函数获取数据后传回到props中，再将props当作页面生成的参数，这样生成的就是静态界面</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Page</span>(<span class="params">props:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>posts List Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;props.dt&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;props.data.map((item:any,index:number) =&gt; (</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                ))</span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStaticProps</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dt = (<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">toString</span>();</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://dummyjson.com/posts&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> reply = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">props</span>:&#123;</span><br><span class="line">                dt,</span><br><span class="line">                <span class="attr">data</span>: reply.<span class="property">posts</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;<span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Page</span>(<span class="params">props:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>posts List Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;props.dt&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;props.data.map((item:any,index:number) =&gt; (</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                ))</span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStaticProps</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dt = (<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">toString</span>();</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://dummyjson.com/posts&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> reply = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">props</span>:&#123;</span><br><span class="line">                dt,</span><br><span class="line">                <span class="attr">data</span>: reply.<span class="property">posts</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果相将类似于这种的<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230314160800455.png" alt="image-20230314160800455">动态路由界面生成静态页面的话，就需要额外的函数，因为一开始他不知道url里的动态参数是多少，所以需要一个<code>getStaticPaths()</code>通过params传递postId，再将这个参数通过context进行传递，就能得到n个静态子页面</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Page</span>(<span class="params">props:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Posts Details Page &#123;props.id&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; !!props.data?.id &amp;&amp;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;props.data.title&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h6</span>&gt;</span>&#123;props.dt&#125;<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;props.data.body&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        &lt;/main&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStaticPaths</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">paths</span>:[</span><br><span class="line">            &#123;<span class="attr">params</span>: &#123;<span class="attr">postId</span>: <span class="string">&#x27;1&#x27;</span>&#125;&#125;,</span><br><span class="line">            &#123;<span class="attr">params</span>: &#123;<span class="attr">postId</span>:<span class="string">&#x27;2&#x27;</span>&#125;&#125;,</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">fallback</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStaticProps</span>(<span class="params">context:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> dt = (<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">toString</span>();</span><br><span class="line">    <span class="keyword">const</span> id = context.<span class="property">params</span>.<span class="property">postId</span>;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`https://dummyjson.com/posts/<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">const</span> reply = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">    <span class="keyword">return</span>(&#123;</span><br><span class="line">        <span class="attr">props</span>:&#123;</span><br><span class="line">            dt,</span><br><span class="line">            <span class="attr">data</span>: reply,</span><br><span class="line">            id</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Link-x2F-Router进行前端路由跳转及next中的数据预取"><a href="#使用Link-x2F-Router进行前端路由跳转及next中的数据预取" class="headerlink" title="使用Link&#x2F;Router进行前端路由跳转及next中的数据预取"></a>使用Link&#x2F;Router进行前端路由跳转及next中的数据预取</h2><p>可以通过Link组件来完成页面的跳转</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Link</span> <span class="keyword">from</span> <span class="string">&quot;next/link&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Home Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/posts&quot;</span>&gt;</span>Posts List<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如上所示，通过Link组件可以进行路由的跳转，跳转到任意一个界面</p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230321154317143.png" alt="image-20230321154317143"></p><p>或者说可以通过自定义组件来进行路由跳转，比如这里通过一个自己封装的RouterButton组件实现点击返回上一级或者返回主页</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useRouter&#125; <span class="keyword">from</span> <span class="string">&#x27;next/router&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">RouterButton</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;marginTop:</span> &#x27;<span class="attr">1rem</span>&#x27;, <span class="attr">display:</span> &#x27;<span class="attr">flex</span>&#x27;,<span class="attr">gap:</span>&#x27;<span class="attr">1rem</span>&#x27;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> router.back()&#125;&gt;Back<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> router.push(&#x27;/&#x27;)&#125;&gt;Home<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230321154638901.png" alt="image-20230321154638901"></p><p>Link组件具有<strong>预取功能</strong>，也就是在加载含有Link组件的页面时，会预先提取Link下的其他页面的脚本和数据，所以在进行跳转的时候不会进行额外的网络请求，从而加载速度很快。</p><h2 id="按需构成静态页面"><a href="#按需构成静态页面" class="headerlink" title="按需构成静态页面"></a>按需构成静态页面</h2><p>通过<code>fallback</code>来进行按需索取，当<code>fallback</code>为<code>false</code>时，如果选取到不存在的页面时，会返回404。但当<code>fallback</code>为<code>blocking</code>时，当选取到不存在的页面，next会通过后台服务来创建这个页面，从而达到<strong>按需生成</strong>。</p><p>在<code>yarn build</code>时会生成规定的静态页面，当用户点击时，再按需生成动态页面</p><p>但是这个是服务端生成（SSG）,不是服务端渲染（SSR）</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStaticPaths</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// const response = await fetch(&#x27;https://dummyjson.com/posts&#x27;)</span></span><br><span class="line">    <span class="comment">// const reply = await response.json();</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">paths</span>:[</span><br><span class="line">            &#123;<span class="attr">params</span>: &#123;<span class="attr">postId</span>: <span class="string">&#x27;1&#x27;</span>&#125;&#125;,</span><br><span class="line">            &#123;<span class="attr">params</span>: &#123;<span class="attr">postId</span>:<span class="string">&#x27;2&#x27;</span>&#125;&#125;,</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// paths: reply.posts.map((p:any) =&gt; (&#123;</span></span><br><span class="line">        <span class="comment">//     params:&#123;postId: p.id.toString()&#125;</span></span><br><span class="line">        <span class="comment">// &#125;)),</span></span><br><span class="line">        <span class="attr">fallback</span>: <span class="string">&#x27;blocking&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>fallback</code>为true时，可以通过<code>fallback</code>来提供一个等待页面，就是当页面还没生成时，提供一个<strong>中间页</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&quot;next/router&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">RouterButton</span> <span class="keyword">from</span> <span class="string">&quot;../../components&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Page</span>(<span class="params">props:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(router.<span class="property">isFallback</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Posts Details Page &#123;props.id&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">RouterButton</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; !!props.data?.id &amp;&amp;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;props.data.title&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h6</span>&gt;</span>&#123;props.dt&#125;<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;props.data.body&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        &lt;/main&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStaticPaths</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">paths</span>:[</span><br><span class="line">            &#123;<span class="attr">params</span>: &#123;<span class="attr">postId</span>: <span class="string">&#x27;1&#x27;</span>&#125;&#125;,</span><br><span class="line">            &#123;<span class="attr">params</span>: &#123;<span class="attr">postId</span>:<span class="string">&#x27;2&#x27;</span>&#125;&#125;,</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">fallback</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说可以只生成用户最常使用的页面，而用户不怎么使用的页面，可以通过<code>fallback</code>来进行动态生成</p><p>可以通过生命周期<code>revalidate</code>对页面生命进行监控，其页面响应头里会有一个<code>Cache-Control</code>的参数，里面有<code>maxage</code>记录页面的生命周期，如果页面超过生命周期，重新请求的话就会重新加载。<strong>需要注意的是，使用生命周期时，fallback需要为false</strong></p><h2 id="服务端渲染（SSR）"><a href="#服务端渲染（SSR）" class="headerlink" title="服务端渲染（SSR）"></a>服务端渲染（SSR）</h2><p>服务端渲染是在用户请求时进行构建，不是提前构建。</p><p>其请求过程就是首先通过后端next框架进行请求，然后构建页面，然后返回前端</p><p>其实现主要是通过<code>getServerSideProps</code>这个函数来进行</p><p>其内部包含了context这个参数，可以方便的进行传参，实现动态路由</p><p>服务端渲染可以通过响应头返回信息，实现用户登录等功能</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Page</span>(<span class="params">props:<span class="built_in">any</span></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Posts List Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;props.dt&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;props.data.map((item:any,index:number) =&gt; (</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;item.price&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                ))</span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getServerSideProps</span> (<span class="attr">context</span>:<span class="built_in">any</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dt = (<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">toString</span>();</span><br><span class="line">    <span class="keyword">const</span> &#123;req, res, params,query,...rest&#125; = context</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://dummyjson.com/products&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> reply = <span class="keyword">await</span> response.<span class="title function_">json</span>()</span><br><span class="line">    <span class="keyword">return</span>(&#123;</span><br><span class="line">        <span class="attr">props</span>:&#123;</span><br><span class="line">            dt,</span><br><span class="line">            <span class="attr">data</span>:reply.<span class="property">products</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建后端API"><a href="#创建后端API" class="headerlink" title="创建后端API"></a>创建后端API</h2><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">NextApiRequest</span>, <span class="title class_">NextApiResponse</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;next&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Data</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params"></span></span><br><span class="line"><span class="params">  req: NextApiRequest,</span></span><br><span class="line"><span class="params">  res: NextApiResponse&lt;Data&gt;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;John Doe&#x27;</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>next作为一个全栈框架，可以自己创建api，可以通过方法进行增删改查，一般是通过一个数据库进行数据的连接。</p><h2 id="网站页面信息设置"><a href="#网站页面信息设置" class="headerlink" title="网站页面信息设置"></a>网站页面信息设置</h2><p>通过对<code>pages/_app.tsx</code>中进行修改来实现全局的布局设置</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@/styles/globals.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">AppProps</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;next/app&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Header</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span> &#x27;<span class="attr">red</span>&#x27;&#125;&#125;&gt;</span>Header<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Footer</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span>&#x27;<span class="attr">red</span>&#x27;&#125;&#125;&gt;</span>Footer<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">&#123; Component, pageProps &#125;: AppProps</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Header</span>&gt;</span><span class="tag">&lt;/<span class="name">Header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...pageProps</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Footer</span>&gt;</span><span class="tag">&lt;/<span class="name">Footer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子就是给所有页面添加了一个统一的Header和Footer</p><p>而next框架中自带Head模块，通过这个模块可以方便的设置<code>&lt;head&gt;...&lt;/head&gt;</code>中的信息，比如页面标题、浏览器标识等</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">RouterButton</span> <span class="keyword">from</span> <span class="string">&#x27;../components&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Head</span> <span class="keyword">from</span> <span class="string">&#x27;next/head&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Page</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">title</span>&gt;</span>About<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>About Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">RouterButton</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三方托管"><a href="#第三方托管" class="headerlink" title="第三方托管"></a>第三方托管</h3><p>第三方托管平台vercel：<a href="https://vercel.com/">https://vercel.com</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;官网：&lt;a href=&quot;https://nextjs.org/&quot;&gt;https://nextjs.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为前端工程师提供全栈解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;React和next-js的区别&quot;&gt;&lt;a href=&quot;#React和next-js的区别&quot; class=&quot;headerlink&quot; title=&quot;React和next.js的区别&quot;&gt;&lt;/a&gt;React和next.js的区别&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;next.js基于React框架，React不解决路由、样式、状态这些，只是单纯的负责打通html和js&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;React是单页面应用，但是next.js会生成多个页面&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>JS中的链表</title>
    <link href="http://example.com/2023/02/15/JS%E4%B8%AD%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2023/02/15/JS%E4%B8%AD%E7%9A%84%E9%93%BE%E8%A1%A8/</id>
    <published>2023-02-15T03:21:42.000Z</published>
    <updated>2023-03-20T08:32:35.030Z</updated>
    
    <content type="html"><![CDATA[<p>​链表格是一种线性数据结构，类似于数组，但不像数组的元素存储在特定的存储器位置或索引中，链表格的每个元素都是一个独立的对象，其中包含一个指针或链接指向列表中的下一个对象。</p><p>​每一个元素（通常 称为节点）包含两个项目：存储的数据和到下一个节点的链接，这些数据可以是任何有效数据类型 。下面的图表显示：</p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/1.jpg" alt="1"></p><span id="more"></span><p>​我们通常使用 “head” 作为链表入口，这个 “head” 是对链表中第一个节点的引用，而链表的最后一个节点指向 null。如果是空链表，则 head 的引用就是 null。</p><p>在 JavaScript 中，链表长这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = &#123;</span><br><span class="line">    <span class="attr">head</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">6</span></span><br><span class="line">        <span class="attr">next</span>: &#123;</span><br><span class="line">            <span class="attr">value</span>: <span class="number">10</span>                                             </span><br><span class="line">            <span class="attr">next</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">12</span></span><br><span class="line">                <span class="attr">next</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="number">3</span></span><br><span class="line">                    <span class="attr">next</span>: <span class="literal">null</span>    </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="链表的优点"><a href="#链表的优点" class="headerlink" title="链表的优点"></a>链表的优点</h2><p>可以很容易地从链表中删除或添加节点，而无需重组整个数据结构。这是它相对于数组的一个优势。</p><h2 id="链表的缺点"><a href="#链表的缺点" class="headerlink" title="链表的缺点"></a>链表的缺点</h2><ul><li>链表的搜索操作很慢，与数组不同，不允许随机访问数据元素，必须从第一个节点开始按顺序访问节点。</li><li>由于需要储存指针，相较于数组需要更多内存。</li></ul><h2 id="链表的类型"><a href="#链表的类型" class="headerlink" title="链表的类型"></a>链表的类型</h2><p>链表有以下三种类型：</p><ul><li>****单向链表****：每个节点只包含一个指向下一个节点的指针。也就是我们到上面一直在讨论的。</li><li>****双向链表****：每个节点包含两个指针，一个指向下一个节点，另一个指向前一个节点。</li><li>****循形链表****：循环链表是链表的一种变体，它的最后一个节点指向第一个节点或它之前的任何其他节点，从而形成一个循环。</li></ul><h2 id="用-JavaScript-实现一个表节点"><a href="#用-JavaScript-实现一个表节点" class="headerlink" title="用 JavaScript 实现一个表节点"></a>用 JavaScript 实现一个表节点</h2><p>前面我们讲到，列表节点包含两项：数据和指向下一个节点的指针。我们可以用 JavaScript 实现如下所示的列表节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">data</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span> = data</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用-JavaScript-实现一个链表"><a href="#用-JavaScript-实现一个链表" class="headerlink" title="用 JavaScript 实现一个链表"></a>用 JavaScript 实现一个链表</h2><p>下面的代码展示了使用构造函数实现链表类的方法。注意，如果未传递 “head” 节点，则它将初始化为 null：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">head = <span class="literal">null</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span> = head</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将它们合在一起"><a href="#将它们合在一起" class="headerlink" title="将它们合在一起"></a>将它们合在一起</h2><p>让我们用刚刚创建的类创建一个链表。 首先，我们创建两个表节点，<em>node1</em> 和 <em>node2</em>，以及他们之间的指针：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node1 = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> node2 = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>)</span><br><span class="line">node1.<span class="property">next</span> = node2</span><br></pre></td></tr></table></figure><p>接着，我们使用 <em>node1</em> 创建一个链表：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>(node1)        </span><br></pre></td></tr></table></figure><p>让我们尝试访问刚刚创建的列表中的节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(list.<span class="property">head</span>.<span class="property">next</span>.<span class="property">data</span>) <span class="comment">//returns 5    </span></span><br></pre></td></tr></table></figure><h2 id="一些链表方法："><a href="#一些链表方法：" class="headerlink" title="一些链表方法："></a>一些链表方法：</h2><p>接下来，我们将为链表实现四个 helper 方法：</p><ol><li>size()</li><li>clear()</li><li>getList()</li><li>getFirst()</li></ol><h3 id="1-size"><a href="#1-size" class="headerlink" title="1. size()"></a>1. size()</h3><p>该方法返回链表中存在的节点数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        node = node.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-clear"><a href="#2-clear" class="headerlink" title="2. clear()"></a>2. clear()</h3><p>该方法清空链表：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-getList"><a href="#3-getList" class="headerlink" title="3. getList()"></a>3. getList()</h3><p>该方法返回链表的最后一个节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getLast</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> lastNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastNode) &#123;</span><br><span class="line">        <span class="keyword">while</span> (lastNode.<span class="property">next</span>) &#123;</span><br><span class="line">            lastNode = lastNode.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lastNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-getFirst"><a href="#4-getFirst" class="headerlink" title="4. getFirst()"></a>4. getFirst()</h3><p>该方法返回链表第一个节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getFirst</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;​		链表格是一种线性数据结构，类似于数组，但不像数组的元素存储在特定的存储器位置或索引中，链表格的每个元素都是一个独立的对象，其中包含一个指针或链接指向列表中的下一个对象。&lt;/p&gt;
&lt;p&gt;​		每一个元素（通常 称为节点）包含两个项目：存储的数据和到下一个节点的链接，这些数据可以是任何有效数据类型 。下面的图表显示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogwh.oss-cn-beijing.aliyuncs.com/img/1.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>博客更新流程</title>
    <link href="http://example.com/2023/02/15/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B/"/>
    <id>http://example.com/2023/02/15/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B/</id>
    <published>2023-02-15T03:12:23.000Z</published>
    <updated>2023-03-20T08:32:38.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="博客更新流程"><a href="#博客更新流程" class="headerlink" title="博客更新流程"></a>博客更新流程</h2><ol><li>在hexo文件夹中的<code>source/_posts/</code>路径下右键打开git，即<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230215111444888.png" alt="image-20230215111444888"></li><li>在页面中输入<code>hexo new &lt;title&gt;</code>来进行文章的创建，title有空格的话需要有引号，比如<code>hexo new &quot;博客 更新 流程&quot;</code></li><li>如果需要调整博客的预设置，可以进入<code>scaffolds/post.md</code>中进行调整<ol><li><code>tags：</code>表示标签</li><li><code>categories：</code>表示种类，即大分类</li><li><code>&lt;!-- more --&gt;</code>表示分界线，即显示在主界面中的内容</li></ol></li></ol><span id="more"></span><ol start="4"><li>在博客更新完后，使用<code>hexo g &amp;&amp; hexo d</code>命令来将新的博客推送到远端主页</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;博客更新流程&quot;&gt;&lt;a href=&quot;#博客更新流程&quot; class=&quot;headerlink&quot; title=&quot;博客更新流程&quot;&gt;&lt;/a&gt;博客更新流程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在hexo文件夹中的&lt;code&gt;source/_posts/&lt;/code&gt;路径下右键打开git，即&lt;img src=&quot;https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20230215111444888.png&quot; alt=&quot;image-20230215111444888&quot;&gt;&lt;/li&gt;
&lt;li&gt;在页面中输入&lt;code&gt;hexo new &amp;lt;title&amp;gt;&lt;/code&gt;来进行文章的创建，title有空格的话需要有引号，比如&lt;code&gt;hexo new &amp;quot;博客 更新 流程&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果需要调整博客的预设置，可以进入&lt;code&gt;scaffolds/post.md&lt;/code&gt;中进行调整&lt;ol&gt;
&lt;li&gt;&lt;code&gt;tags：&lt;/code&gt;表示标签&lt;/li&gt;
&lt;li&gt;&lt;code&gt;categories：&lt;/code&gt;表示种类，即大分类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;!-- more --&amp;gt;&lt;/code&gt;表示分界线，即显示在主界面中的内容&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo+github+PicGo+阿里云OSS博客搭建流程</title>
    <link href="http://example.com/2022/12/28/Hexo+github+PicGo+%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
    <id>http://example.com/2022/12/28/Hexo+github+PicGo+%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/</id>
    <published>2022-12-28T02:16:47.000Z</published>
    <updated>2023-03-20T08:32:34.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HEXO博客的本地搭建"><a href="#HEXO博客的本地搭建" class="headerlink" title="HEXO博客的本地搭建"></a>HEXO博客的本地搭建</h2><ol><li>下载node.js和Git</li><li>本地安装hexo，在你想要存放博客的文件夹根目录下右键，选择<code>Git Bash Here</code>，输入下列命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 安装hexo框架</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line">#初始化文件夹</span><br><span class="line">hexo init</span><br><span class="line"># 安装 hexo 依赖包</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>hexo官网：<a href="https://hexo.io/zh-cn/index.html">https://hexo.io/zh-cn/index.html</a></p><ol start="3"><li>在git bash命令行窗口里，依次执行</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 生成静态网站</span><br><span class="line">hexo g</span><br><span class="line"># 启动服务器</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>此时在<code>http://localhost:4000/</code>就能看到Hexo搭建的博客示例</p><p>我使用的主题：NEXT</p><p>Github主页：<a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a></p><p>如何更换主题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 下载主题仓库到 themes 文件夹， git clone &lt;仓库地址&gt; themes/&lt;主题名&gt; </span><br><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>然后用记事本打开博客根目录下的 _config.yml ，找到<code>theme</code>标签，默认值是<code>landscape</code>主题，把它改为要更换的主题名字<code>next</code>，然后执行启动命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: ayer</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 清理 &amp;&amp; 生成 &amp;&amp; 启动</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p>如何修改主题内容可以根据next主题中文官方文档查看：<a href="http://theme-next.iissnan.com/">http://theme-next.iissnan.com/</a></p><h2 id="从WORDPRESS迁移博客"><a href="#从WORDPRESS迁移博客" class="headerlink" title="从WORDPRESS迁移博客"></a>从WORDPRESS迁移博客</h2><p>如果需要从WordPress迁移自己的博客内容，可以通过插件来进行迁移</p><p>首先需要安装<code>hexo-migrator-wordpress</code> 插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-migrator-wordpress --save</span><br></pre></td></tr></table></figure><p>在 WordPress 仪表盘中导出数据(“Tools” → “Export” → “WordPress”)（详情参考<a href="https://wordpress.com/zh-cn/support/export/">WP支持页面</a>）。</p><p>插件安装完成后，执行下列命令来迁移所有文章。<code>source</code> 可以是 WordPress 导出的文件路径或网址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo migrate wordpress &lt;source&gt;</span><br></pre></td></tr></table></figure><p>这个迁移完成后会在<code>source/_posts/</code>目录下迁移完所有的文章，但是会有一些小问题，就是你之前引用的图片路径仍然是WordPress上的媒体路径，需要自己手动更新一下，这部分会在接下来详细讲解，我使用的是阿里云OSS方案</p><h2 id="Github-Pages建站"><a href="#Github-Pages建站" class="headerlink" title="Github Pages建站"></a>Github Pages建站</h2><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20201229224505117.png" alt="image-20201229224505117"></p><p>由于每个 GitHub 账户只能建立一个 GitHub Pages 页面，所以 Repository name 必须填<code>&lt;你的用户名&gt;.github.io</code>，否则就会建立一个普通仓库，GitHub Pages 功能不会生效。比如用户名是<code>jacksparrow</code>，Repository name 这里就填<code>jacksparrow.github.io</code>，不知道用户名是哪个，可以点击页面右上角头像，看到第一行“Signed in as <code>xxx</code>”字样， <code>xxx</code>即为这里的用户名。</p><p>Description 填写仓库描述，比如 <code>jacksparrow&#39;s blog</code>等，可不填。</p><p>注意勾选 <code>Public</code> ，否则 GitHub Pages 功能不会生效。建议勾选 <code>Add a README file</code>，会自动生成一个 <code>readme.md</code>文件。</p><p>最后点击Create repository创建仓库。</p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20201229224741804.png" alt="image-20201229224741804"></p><p>配置完参数后需要配置git参数，这部分网上教程一大堆，就不详细累述了。</p><p>大概流程就是配置用户名和邮箱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 其中 username 和 username@XXX.com 是你注册 GitHub 的用户名和邮箱</span><br><span class="line">git config --global user.name &quot;username&quot;</span><br><span class="line">git config --global user.email &quot;username@XXX.com&quot;</span><br></pre></td></tr></table></figure><p>生成SSH keys和github相互认证，认证完后通过<code>ssh -T git@github.com</code>命令进行测试是否成功</p><p>测试成功后，在在博客根目录下，右键，打开Git Bash Here。</p><p>输入下面的命令，安装<code>hexo-deployer-git</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure><p>打开博客<code>根目录配置文件</code>(<code>D:\MyBlog\_config.yaml</code>)，拉到文件最后一行，修改为下面的配置（没有的配置项自行添加），保存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 其中 xxxxxx 是前面多次用到的你的GitHub用户名</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:xxxxxx/xxxxxx.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 注意最后变成d了，原来的s表示服务起在本地，现在的d表示部署在远端</span><br><span class="line">hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>这里有一些需要注意的地方，就是如果你明明更新了博客的内容，但是没有显示，可以尝试两种方法来进行刷新</p><ol><li><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>通过清除缓存再重新部署</li><li>在浏览器端<code>shift+F5</code>强制刷新，清除浏览器端缓存来看更新</li><li>当然你上传到github上的页面会有一定的延迟，所以不用很着急，隔几分钟再看看</li></ol><h2 id="PicGo-阿里云OSS图床"><a href="#PicGo-阿里云OSS图床" class="headerlink" title="PicGo+阿里云OSS图床"></a>PicGo+阿里云OSS图床</h2><p>这部分是消耗我时间最长的东西，尝试了Gitee图床和Github图床都不是很好用，所以还是选择使用金钱的力量(滑稽)。当然，阿里云OSS服务有个坑，就是你包月包年了它的标准流量包，但那个只负责储存，但是不负责下行流量，但是你自己博客的话，也不会使用多少下行流量，0.5元&#x2F;GB的价格，见仁见智吧。</p><p> <strong>如果是自己简单的写个博客或 公众号，平时可能没有特别大的访问量，所以选择默认的按量计费，如果访问量较大的，可以考虑包年包月</strong></p><p><a href="https://picgo.github.io/PicGo-Doc/zh/">PicGo下载链接</a></p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-20221228105817341.png" alt="image-20221228105817341"></p><p>具体设置如图所示，需要在阿里云里设置keyid和keysecret，<a href="https://zhuanlan.zhihu.com/p/104152479">一篇很棒的教程</a></p><p>需要注意的点：</p><ol><li>阿里云那里在创建bucket时，读写权限需要时<strong>公共读</strong>，这样才能通过链接访问到这个图片。</li><li>KeyId和KeySecret只能显示一次，所以需要<strong>妥善保管</strong>，复制粘贴到别处哦。</li></ol><p>剩下就可以愉快的上传自己的图片了。</p><p>当然据说使用Gihub+国内CDN加速也可以很丝滑的使用图床，但是我不知道怎么也弄不好，所以还是算咧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HEXO博客的本地搭建&quot;&gt;&lt;a href=&quot;#HEXO博客的本地搭建&quot; class=&quot;headerlink&quot; title=&quot;HEXO博客的本地搭建&quot;&gt;&lt;/a&gt;HEXO博客的本地搭建&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;下载node.js和Git&lt;/li&gt;
&lt;li&gt;本地安装h</summary>
      
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>React脚手架</title>
    <link href="http://example.com/2022/12/26/react%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <id>http://example.com/2022/12/26/react%E8%84%9A%E6%89%8B%E6%9E%B6/</id>
    <published>2022-12-26T10:00:00.000Z</published>
    <updated>2023-03-20T08:32:37.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、使用-create-react-app-创建-react-应用"><a href="#一、使用-create-react-app-创建-react-应用" class="headerlink" title="一、使用 create-react-app 创建 react 应用"></a>一、使用 create-react-app 创建 react 应用</h1><h2 id="1-1-react-脚手架"><a href="#1-1-react-脚手架" class="headerlink" title="1.1 react 脚手架"></a>1.1 react 脚手架</h2><ol><li>脚手架就是用来帮助快速创建一个基于 xxx 库的模板项目<ol><li>包含所有需要的配置(语法检查，jsx 编译，devServer…)</li><li>下载好了所有相关的依赖</li><li>可以直接运行一个简单效果</li></ol></li><li>react 提供了一个用于创建 react 项目的脚手架库:create-react-app</li><li>项目的整体技术架构为：react+webpack+es6+eslint</li><li>使用脚手架开发的项目的特点：模块化，组件化，工程化</li></ol><span id="more"></span><h2 id="1-2-配置"><a href="#1-2-配置" class="headerlink" title="1.2 配置"></a>1.2 配置</h2><p>比较古老的方式：<code>npm install -g create-react-app</code><br>但是这种方式可能会出现一些小 bug，比如说显示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mayankthakur@<span class="title class_">Mayanks</span>-<span class="title class_">MacBook</span>-<span class="title class_">Air</span> ~ % npm install -g create-react-app</span><br><span class="line"></span><br><span class="line">npm <span class="variable constant_">WARN</span> deprecated tar@<span class="number">2.2</span><span class="number">.2</span>: <span class="title class_">This</span> version <span class="keyword">of</span> tar is no longer supported, and will not receive security updates. <span class="title class_">Please</span> upgrade asap.</span><br><span class="line"></span><br><span class="line">changed <span class="number">67</span> packages, and audited <span class="number">68</span> packages <span class="keyword">in</span> 1s</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> packages are looking <span class="keyword">for</span> funding</span><br><span class="line">  run <span class="string">`npm fund`</span> <span class="keyword">for</span> details</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> high severity vulnerabilities</span><br><span class="line"></span><br><span class="line"><span class="title class_">To</span> address all issues, <span class="attr">run</span>:</span><br><span class="line">  npm audit fix</span><br><span class="line"></span><br><span class="line"><span class="title class_">Run</span> <span class="string">`npm audit`</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>但是这不是 error，是一个 warning。就是告诉你的 tar 版本太低咧。但是没啥事儿。我试着更新了一下 tar 的版本，但是好像没啥用。<br>之后再创建项目<code>create-react-app react-staging</code>类似于这样就行了。</p><p>或者说，可以使用新的方法：<br><code>npx create-react-app my-app</code><br><strong>这条命令会临时安装 create-react-app 包，命令完成后 create-react-app 会删掉，不会出现在 global 中。下次再执行，还是会重新临时安装。</strong></p><p>之后在安装完成后，进入已经创建好的项目目录，<code>npm start</code>启动项目。</p><p><strong>在使用包管理器时，需要注意，在一个项目中只使用一个包管理器，比如只使用 npm 或者只使用 yarn。尽量不要使用多个包管理器，否则可能会出现未知问题</strong></p><h2 id="1-3-内容"><a href="#1-3-内容" class="headerlink" title="1.3 内容"></a>1.3 内容</h2><ol><li>node_modules 存放脚手架所需的依赖</li><li>public 存放静态资源文件。包括 favicon.ico 的网页图标，index.html 为 react 提供节点。</li></ol><p>以下是 index.html 文件中自带的一些设置<br><code>&lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot;/&gt;</code>这里的这个路径<code>%PUBLIC_URL%</code>表示的是 public 这个文件夹的路径<br><code>&lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot; /&gt;</code>用于配置浏览器页签+地址栏的颜色（仅安卓手机浏览器），兼容性不好，不常用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Web site created using create-react-app&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>上面这个标签为网页提供一个描述，告诉浏览者们网页的用处<br><code>&lt;link rel=&quot;apple-touch-icon&quot; href=&quot;%PUBLIC_URL%/logo192.png&quot; /&gt;</code>这个的作用比较奇怪，就是在 ios 端，当你想要将一个网页放到主屏幕时，会显示这个图片。也就是在主屏幕上显示的，类似于 app 图标的图片。<br>可以在网页外面加壳，从而将一个网页变成一个 apk 文件。<code>&lt;link rel=&quot;manifest&quot; href=&quot;%PUBLIC_URL%/manifest.json&quot; /&gt;</code>这个 json 文件决定了网页加壳时的一些设置。<br><code>&lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;</code>若浏览器不支持 js，则显示标签内的内容<br><code>robots.txt</code>决定了爬虫的规则，是爬虫规则文件</p><ol start="3"><li>src 文件夹中：<ol><li>app.js 和 app.css 组成了一个 app 组件。因为在 public 文件夹里的 index.html 中有一个<code>&lt;div id=&#39;root&#39;&gt;&lt;/div&gt;</code>，这个就是虚拟 dom 需要渲染的节点，而 app 组件就是渲染到这个这个节点上的唯一组件。其他组件需要当作 app 的子组件。</li><li>app.test.js 用做测试 app 组件</li><li>index.js 是入口文件。这里引入了 app 组件，并在页面上进行渲染。index.css 是他的样式文件。</li><li><code>&lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;</code>这个的目的是检查 App 组件，会提醒一些写的不合理的东西</li><li>reportWebVital.js 是做页面性能检测的</li><li>setupTests.js 是做组件检测的</li></ol></li><li>主要编写的内容就是 public&#x2F;index.html 和 src&#x2F;App.js 和 src&#x2F;index.js</li></ol><h1 id="二、脚手架学习"><a href="#二、脚手架学习" class="headerlink" title="二、脚手架学习"></a>二、脚手架学习</h1><h2 id="2-1-基本内容的编写"><a href="#2-1-基本内容的编写" class="headerlink" title="2.1 基本内容的编写"></a>2.1 基本内容的编写</h2><p>首先是<code>public/index,html</code>，因为这部分只负责引入一个用于渲染的节点。所以内容比较简单。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello-React<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其次是<code>src/App.js</code>，这部分是组件的主要内容,也是组件最后汇总的地方</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建“外壳”组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="comment">// 引用，但是js后缀可以省略</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Hello</span> <span class="keyword">from</span> <span class="string">&quot;./components/Hello/Hello.js&quot;</span>;</span><br><span class="line"><span class="comment">// 省略型引用</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Welcome</span> <span class="keyword">from</span> <span class="string">&quot;./components/Welcome&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并暴露App组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Hello</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Welcome</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过引入两个子组件来完成组件的设置。子组件的引用有两种方式，一种是通过直接引用。另一种是如果文件夹中的 js&#x2F;jsx 文件命名为 index.js，则可以省略。<br>并通过暴露这个 App 组件使得能被 index.js 调用<br><code>src/index.js</code>主要负责的就是渲染组件到页面上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure><p>子组件以<code>Hello.js</code>为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./Hello.css&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">className</span>=<span class="string">&quot;title&quot;</span>&gt;</span>Hello,react!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-1-React18-的一些新特性"><a href="#2-1-1-React18-的一些新特性" class="headerlink" title="2.1.1 React18 的一些新特性"></a>2.1.1 React18 的一些新特性</h3><p><code>ReactDOM.render</code>在 React18 中被废弃了，取而代之的是<code>createRoot render</code><br>现在需要首先提取出这个节点，在这个节点上使用 createRoot 方法，之后在将其渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染</span></span><br><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"><span class="comment">// Create a root.</span></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(container);</span><br><span class="line"><span class="comment">// Initial render: Render an element to the root.</span></span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure><p>并且需要注意的是：<code>import ReactDOM from &#39;react-dom/client&#39;</code>引用改成了这种形式。</p><h2 id="2-2-样式的模块化"><a href="#2-2-样式的模块化" class="headerlink" title="2.2 样式的模块化"></a>2.2 样式的模块化</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> hello <span class="keyword">from</span> <span class="string">&quot;./Hello.module.css&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">className</span>=<span class="string">&#123;hello.title&#125;</span>&gt;</span>Hello,react!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过给 css 文件命名为<code>xxx.module.css</code>来将样式文件进行模块化。之后就能在 js 文件中进行 import 调用了。<br>在下面的样式引用时，可以通过调用<code>className=&#123;hello.title&#125;</code>这种类型来进行样式的调用。</p><h2 id="2-3-vscode-中的-React-插件"><a href="#2-3-vscode-中的-React-插件" class="headerlink" title="2.3 vscode 中的 React 插件"></a>2.3 vscode 中的 React 插件</h2><p><code>ES7+ React/Redux/React-Native snippets</code><br>提供 rcc&#x2F;rfc&#x2F;等快捷键<br><code>React Native Tools</code><br>提供 ren 等快捷键 0<br><code>React Style Helper</code></p><p>比较推荐这三个插件。-.-</p><h2 id="2-5-组件化编码流程"><a href="#2-5-组件化编码流程" class="headerlink" title="2.5 组件化编码流程"></a>2.5 组件化编码流程</h2><ol><li>拆分组件：拆分界面，抽取组件</li><li>实现静态组件：使用组件实现静态页面效果</li><li>实现动态组件<ol><li>动态显示初始化数据<ol><li>数据类型</li><li>数据名称</li><li>保存在哪个组件</li></ol></li><li>交互（从绑定事件监听开始）</li></ol></li></ol><h1 id="三、react-ajax"><a href="#三、react-ajax" class="headerlink" title="三、react ajax"></a>三、react ajax</h1><ol><li>React 本身只关注于界面，并不发送 ajax 请求的代码</li><li>前端应用需要通过 ajax 请求与后台进行交互（json 数据）</li><li>react 应用需要集成第三方 ajax 库或自己封装</li><li>不建议使用 ajax。建议使用<strong>axios</strong>，可以在浏览器端和 node 服务器端</li></ol><h2 id="3-1-axios"><a href="#3-1-axios" class="headerlink" title="3.1 axios"></a>3.1 axios</h2><p>为了使用 axios，应该使用 yarn 或者 npm 添加 axios<br><code>yarn add axios</code>或者是<code>npm install axios</code><br>ajax 引擎因为有同源策略，所以说不好使用跨域请求。<br>如果想要给其他端口发送请求，需要开启一个<strong>中间服务器</strong>，比如浏览器端口为 3000，需要请求的端口是 5000。就可以通过一个开在 3000 端口的中间服务器，而这个中间服务器是没有 ajax 引擎的。所以说不存在同源策略。首先浏览器发送请求到中间服务器，中间服务器转交到 5000 端口的后端服务器。之后再返回到 3000 的中间服务器。因为两个服务器的端口都是 3000，所以不会产生跨域请求，这时候就能把请求传回来咧。这样就完成了一次请求。</p><p>第一种方式：</p><ol><li>在<code>package.json</code>中添加<code>&quot;proxy&quot;:&quot;http://localhost:5000&quot;</code>，意思就是向 5000 端口进行代理。但是这种代理是有局限性的</li><li><code>axios.get(&#39;http://localhost:3000/students&#39;)</code>在 axios 端向 3000 端口发送请求，如果在 3000 端口没有这个文件，则会向 5000 端口进行转发</li><li>这种方式的局限性就是如果本来的端口就存在这个文件，则会首先请求本身端口的文件，而不是请求服务器端的文件。只有本身没有这个文件，才会向服务器端请求。</li></ol><p>说明：</p><ol><li>优点：配置简单，前端请求资源时可以不加任何前缀。</li><li>缺点：不能配置多个代理。</li><li>工作方式：上述方式配置代理，当请求了 3000 不存在的资源时，那么该请求会转发给 5000 （优先匹配前端资源）</li></ol><p>第二种方式：<br>在 src 文件夹中新建<code>setupProxy.js</code>,创建代理配置文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="built_in">require</span>(<span class="string">&quot;http-proxy-middleware&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">app</span>) &#123;</span><br><span class="line">app.<span class="title function_">use</span>(</span><br><span class="line"><span class="title function_">createProxyMiddleware</span>(<span class="string">&quot;/api1&quot;</span>, &#123;</span><br><span class="line"><span class="comment">//api1是需要转发的请求(所有带有/api1前缀的请求都会转发给5000)</span></span><br><span class="line"><span class="attr">target</span>: <span class="string">&quot;http://localhost:5000&quot;</span>, <span class="comment">//配置转发目标地址(能返回数据的服务器地址)</span></span><br><span class="line"><span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">//控制服务器接收到的请求头中host字段的值</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span></span><br><span class="line"><span class="comment">         changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:3000</span></span><br><span class="line"><span class="comment">         changeOrigin默认值为false，但我们一般将changeOrigin值设为true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="attr">pathRewrite</span>: &#123; <span class="string">&quot;^/api1&quot;</span>: <span class="string">&quot;&quot;</span> &#125;, <span class="comment">//去除请求前缀，保证交给后台服务器的是正常请求地址(必须配置)</span></span><br><span class="line">&#125;),</span><br><span class="line"><span class="title function_">createProxyMiddleware</span>(<span class="string">&quot;/api2&quot;</span>, &#123;</span><br><span class="line"><span class="attr">target</span>: <span class="string">&quot;http://localhost:5001&quot;</span>,</span><br><span class="line"><span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">pathRewrite</span>: &#123; <span class="string">&quot;^/api2&quot;</span>: <span class="string">&quot;&quot;</span> &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>优点：可以配置多个代理，可以灵活的控制请求是否走代理。</li><li>缺点：配置繁琐，前端请求资源时必须加前缀。</li></ol><h2 id="3-2-兄弟组件之间的数据通信"><a href="#3-2-兄弟组件之间的数据通信" class="headerlink" title="3.2 兄弟组件之间的数据通信"></a>3.2 兄弟组件之间的数据通信</h2><p>通过消息订阅——发布机制<br>通过工具库：PubSubJS 来实现<br>通过<code>yarn add pubsub-js</code>或<code>npm install pubsub-js</code>来添加这个库</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过这个表达发布机制，也就是通过其发布信息</span></span><br><span class="line"><span class="title class_">PubSub</span>.<span class="title function_">publish</span>(<span class="string">&quot;信息名&quot;</span>, &#123; <span class="attr">key</span>: value &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是订阅机制，也就是当在组件中接收到信息名，则会执行回调函数</span></span><br><span class="line"><span class="title class_">PubSub</span>.<span class="title function_">subscribe</span>(<span class="string">&quot;信息名&quot;</span>, <span class="function">(<span class="params">name, data</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><p>通过这两个就能够实现兄弟组件间的通信，比如在一个组件中进行信息的发布，之后在另一个组件中进行信息的订阅。<br>通过这样就能够简单的实现 state 的更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如说一个组件发布state的更新</span></span><br><span class="line"><span class="title class_">PubSub</span>.<span class="title function_">publish</span>(<span class="string">&#x27;data&#x27;</span>,&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个组件在组件挂载时，进行订阅并进行状态的更新</span></span><br><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">token</span> = <span class="title class_">PubSub</span>.<span class="title function_">subscribe</span>(<span class="string">&#x27;data&#x27;</span>,<span class="function">(<span class="params">_,stateObj</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(stateObj)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在被卸载时，将这个订阅取消掉</span></span><br><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">PubSub</span>.<span class="title function_">unsubscribe</span>(<span class="variable language_">this</span>.<span class="property">token</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以通过这种方式，可以进行任意组件间的通信，不光局限于父子组件或兄弟组件。</p><h2 id="3-3-fetch"><a href="#3-3-fetch" class="headerlink" title="3.3 fetch"></a>3.3 fetch</h2><p>特点：</p><ol><li>原生函数，和 xhr 是并列的。不使用 xhr 提交 ajax 请求</li><li>老版本浏览器可能不支持</li></ol><p>xhr 不符合关注分离的原则。<br>fetch 是符合 promise 的风格的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;联系服务器成功了&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>()&#125;</span><br><span class="line">).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取数据成功了&#x27;</span>,response);&#125;</span><br><span class="line">).<span class="title function_">catch</span>(</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求出错&#x27;</span>,error);</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面这个例子就是一个关注分离的例子，就是 fetch 请求可能能够连接服务器，但如果错误的调用，是不能够获取数据的。<br>要是连接服务器都失败，那么有可能是服务器离线。<br>最后通过 catch 来兜底，统一处理错误</p><p>或者可以使用<code>async</code>和<code>await</code>进行处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">xxx</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求出错&quot;</span>, error);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="四、React-路由"><a href="#四、React-路由" class="headerlink" title="四、React 路由"></a>四、React 路由</h1><h2 id="4-1-相关理解"><a href="#4-1-相关理解" class="headerlink" title="4.1 相关理解"></a>4.1 相关理解</h2><h3 id="4-1-1-SPA"><a href="#4-1-1-SPA" class="headerlink" title="4.1.1 SPA"></a>4.1.1 SPA</h3><ol><li>单页 web 应用（single page web application，SPA）</li><li>整个应用只有<strong>一个完整的页面</strong></li><li>点击页面中的链接<strong>不会刷新</strong>页面，只会做页面的<strong>局部更新</strong></li><li>数据都需要通过 ajax 请求获取，并在前端异步展现</li></ol><h3 id="4-1-2-路由-Route"><a href="#4-1-2-路由-Route" class="headerlink" title="4.1.2 路由(Route)"></a>4.1.2 路由(Route)</h3><ol><li>什么是路由？<ol><li>一个路由是一个映射关系(key:value)</li><li>key 为路径(path)，value 可能是 function 或是 component</li></ol></li><li>路由的种类：<ol><li>后端路由：<ol><li>理解：value 为 function，用来处理客户端提交的请求</li><li>注册路由：router.get(path,function(req,res))</li><li>工作过程：当 node 接收到一个请求时，根据请求路径找到匹配的路由，调用路由中的函数来处理请求，返回响应函数</li></ol></li><li>前端路由：<ol><li>浏览器端路由，value 是 component，用于展示页面内容</li><li>注册路由：<code>&lt;Route path=&#39;/test component=&#123;Test&#125;&#39;&gt;</code></li><li>工作过程：当浏览器的 path 变为&#x2F;test 时，当前路由组件就会变成 Test 组件</li></ol></li></ol></li><li>浏览器的历史记录是以栈的形式存在的，当浏览一条记录时，将这条记录压入栈中，当回退时，将当前记录出栈，则暴露了上一条记录。</li></ol><h2 id="4-2-history"><a href="#4-2-history" class="headerlink" title="4.2 history"></a>4.2 history</h2><ol><li>使用 H5 推出的 history 身上的 api 来操纵历史记录的前进和后退等</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> history = <span class="title class_">History</span>.<span class="title function_">createBrowserHistory</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">push</span>(<span class="params">path</span>) &#123;</span><br><span class="line">history.<span class="title function_">push</span>(path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">replace</span>(<span class="params">path</span>) &#123;</span><br><span class="line">history.<span class="title function_">replace</span>(path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">back</span>(<span class="params"></span>) &#123;</span><br><span class="line">history.<span class="title function_">goBack</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">forward</span>(<span class="params"></span>) &#123;</span><br><span class="line">history.<span class="title function_">goForward</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 hash 值(锚点)来操纵<code>let history = History.createHarshHistory()</code></li></ol><h2 id="4-3-react-router"><a href="#4-3-react-router" class="headerlink" title="4.3 react-router"></a>4.3 react-router</h2><ol><li>react 的一个插件库</li><li>专门用来实现一个 SPA 应用</li><li>共分为三部分，分别给 web、native、any 使用</li><li>前端使用的主要是 react-router-dom</li><li>下载：<code>npm i react-router-dom</code></li><li>引入 css 文件时要注意不要加<code>.</code>。应该使用<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;/bootstrap.css&quot;&gt;</code>或者用%形式写也行。负责会出现<strong>样式丢失</strong>的问题。</li><li>与 React Router 5.x 版本的区别：<ul><li>内置组件的变化：移除<code>&lt;Switch/&gt;</code>，新增<code>&lt;Routes/&gt;</code>……</li><li>语法变化：<code>component=&#123;About&#125;</code>变成<code>element=&#123;&lt;About/&gt;&#125;</code>……</li><li>新增 hook：useParams、useNavigate、useMatch……</li><li>官方明确表示推荐使用函数式组件</li></ul></li></ol><h3 id="4-3-1-一级路由"><a href="#4-3-1-一级路由" class="headerlink" title="4.3.1 一级路由"></a>4.3.1 一级路由</h3><p>首先下载并引入路由，在 index.js 中通过 BrowserRouter&#x2F;HashRouter 对 App 组件进行包裹，这意味着进行了路由的包裹<br>但是 HashRouter 传递的 path 为<code>localhost:3000/#/....</code>，#后面的参数都不会给服务器传递。所以最好还是用<code>BrowserRouter</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入库</span></span><br><span class="line"><span class="comment">// 从 react-dom/client 引入 ReactDOM</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&quot;react-dom/client&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BrowserRouter</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// React 18 的语法发生改变了</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>)).<span class="title function_">render</span>(</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>之后在 App.js 中进行路由链接和注册路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NavLink</span>, <span class="title class_">Routes</span>, <span class="title class_">Route</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&quot;./components/Home&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&quot;./components/About&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;list-group&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;/* 路由链接 */&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">About</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">Home</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 注册路由 */</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="title class_">Routes</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">About</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line">&lt;/<span class="title class_">Routes</span>&gt;;</span><br></pre></td></tr></table></figure><ol><li>路由链接：<ol><li>原生 html 中，靠<code>&lt;a&gt;</code>来跳转不同的页面。在 React 中靠路由链接实现切换组件<code>&lt;NavLink className=&quot;list-group-item&quot; to=&quot;/about&quot;&gt;About&lt;/NavLink&gt;</code></li><li>或者是<code>&lt;Link className=&quot;list-group-item&quot; to=&quot;/about&quot;&gt;About&lt;/Link&gt;</code>。</li><li>需要注意的是，to 后面跟的路径不能带<code>.</code></li><li>NavLink 默认会给链接添加一个 active 属性。或者可以添加一个属性<code>activeClassName = &#39;&#39;</code>从而对点击的链接添加一个独特的属性。</li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">BrowserRouter</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">About</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">BrowserRouter</span>&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>注册路由：</p><ol><li><code>&lt;Routes&gt;</code>用于对注册路由的组件进行包裹。当 url 变化时，<code>&lt;Routes&gt;</code>会查看所有子<code>&lt;Route&gt;</code>元素以找到最佳匹配并呈现组件</li><li>而<code>&lt;Route&gt;</code>组件的格式为固定的<code>&lt;Route path=&#39;/about&#39; element=&#123;&lt;About/&gt;&#125; /&gt;</code>，其中 path 前面不要加<code>.</code>。因为可能会出现格式加载的问题。element 里面是引用的组件。</li><li><code>&lt;Routes&gt;</code>和<code>&lt;Route&gt;</code>要配合使用，且必须用<code>&lt;Routes&gt;</code>包裹<code>&lt;Route&gt;</code></li><li><code>&lt;Route&gt;</code>相当于一个 if 语句，如果其路径与当前 url 匹配，则呈现对应的组件</li><li><code>&lt;Route caseSensitive&gt;</code>属性用于指定匹配时是否区分大小写（默认为 false）</li></ol></li><li><p>路由组件和一般组件的区别：</p><ol><li>接收到的 props 不同：路由组件的 props 传递了三组固定的属性（history、location、match），一般组件的 props 为传递的东西</li><li>写法不同：路由组件需要通过路由器进行渲染(<code>&lt;Route path=&#39;/home&#39; element=&#123;&lt;Home/&gt;&#125; /&gt;</code>)，一般组件是直接进行渲染(<code>&lt;Demo/&gt;</code>)</li><li>位置不同：一般组件位于 components 文件夹，路由组件位于 pages 文件夹</li></ol></li></ol><h3 id="4-3-2-封装-NavLink-组件"><a href="#4-3-2-封装-NavLink-组件" class="headerlink" title="4.3.2 封装 NavLink 组件"></a>4.3.2 封装 NavLink 组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>,&#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">NavLink</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">MyNavLink</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">activeClassName</span>=<span class="string">&#x27;xxx&#x27;</span> <span class="attr">className</span>=<span class="string">&#x27;xx&#x27;</span> &#123;<span class="attr">this.props</span>&#125;/&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样将其封装成一个一般组件，之后调用 NavLink 时就可以简单的调用咧。<code>&lt;MyNavLink to=&#39;xxx&#39; /&gt;</code></p><h3 id="4-3-3-重定向"><a href="#4-3-3-重定向" class="headerlink" title="4.3.3 重定向"></a>4.3.3 重定向</h3><p>使用<code>&lt;Navigate&gt;</code>组件可以完成重定向，其只要被渲染，就会修改路径，切换视图。<br>其可以添加 replace 属性，默认为 push。如果<code>replace=&#123;true&#125;</code>则为 replace 模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Navigate</span>&#125; <span class="keyword">from</span><span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> [sum,setSum ] = <span class="title function_">useState</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;sum ===1 ? <span class="tag">&lt;<span class="name">h4</span>&gt;</span>sum的值为&#123;sum&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span> : <span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span> = <span class="string">&#x27;/about&#x27;</span> <span class="attr">replace</span>= <span class="string">&#123;true&#125;</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setSum(2)&#125;&gt;点我将sum变为2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  )</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="4-3-4-路由表"><a href="#4-3-4-路由表" class="headerlink" title="4.3.4 路由表"></a>4.3.4 路由表</h3><p>通过 useRoutes 使用路由表<br>首先在.&#x2F;src 中建立一个 routes 文件夹用于存放路由规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&quot;../pages/About&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&quot;../pages/Home&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Navigate</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>,</span><br><span class="line"><span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">About</span> /&gt;</span></span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,</span><br><span class="line"><span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line"><span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span> /&gt;</span></span>,</span><br><span class="line">&#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>在这个路由规则文件中调用组件和其他，并将路由规则通过数组形式暴露出去。<br>之后在 App 中引用这个文件，使用 useRoutes 来调用这些规则，之后在返回时，就可以方便的调用这些组件了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">NavLink</span>,useRoutes&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">&#x27;./routes&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> element = <span class="title function_">useRoutes</span>(routes)</span><br><span class="line"><span class="keyword">return</span>&#123;</span><br><span class="line">&#123;element&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-5-嵌套路由"><a href="#4-3-5-嵌套路由" class="headerlink" title="4.3.5 嵌套路由"></a>4.3.5 嵌套路由</h3><p>嵌套路由中，需要使用<code>&lt;Outlet&gt;</code>设置子路由的路由出口，即在何处渲染子路由。<br>设置二级路由链接时，可以是 to&#x3D;”news”、to&#x3D;”.&#x2F;news”，但不能是 to&#x3D;”&#x2F;news”。<br>不使用路由表的嵌套路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;hello&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;about&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">About</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Hello</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;news&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">News</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;message&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Message</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;about&quot;</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用路由表的嵌套路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>,</span><br><span class="line"><span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">About</span> /&gt;</span></span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,</span><br><span class="line"><span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span>,</span><br><span class="line"><span class="comment">// 设置二级路由</span></span><br><span class="line"><span class="attr">children</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;news&quot;</span>,</span><br><span class="line"><span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">News</span> /&gt;</span></span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;message&quot;</span>,</span><br><span class="line"><span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Message</span> /&gt;</span></span>,</span><br><span class="line"><span class="comment">// 设置三级路由</span></span><br><span class="line"><span class="attr">children</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;detail&quot;</span>,</span><br><span class="line"><span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Detail</span> /&gt;</span></span>,</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line"><span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span> /&gt;</span></span>,</span><br><span class="line">&#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>使用时需要通过 Outlet 来决定嵌套路由的呈现位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NavLink</span>, <span class="title class_">Outlet</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Home组件内容<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">className</span>=<span class="string">&quot;nav nav-tabs&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">to</span>=<span class="string">&quot;news&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">News</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">to</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">Message</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;/* 指定路由组件的呈现位置 */&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Outlet</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-6-路由传参"><a href="#4-3-6-路由传参" class="headerlink" title="4.3.6 路由传参"></a>4.3.6 路由传参</h3><h4 id="4-3-6-1-传递-params-参数"><a href="#4-3-6-1-传递-params-参数" class="headerlink" title="4.3.6.1 传递 params 参数"></a>4.3.6.1 传递 params 参数</h4><p>注册路由时声明 params 参数，和 React Router 5 一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Hello</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;message&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Message</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;detail/:id/:name/:age&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Detail</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Link</span> to=&#123;<span class="string">`detail/<span class="subst">$&#123;item.id&#125;</span>/<span class="subst">$&#123;item.name&#125;</span>/<span class="subst">$&#123;item.age&#125;</span>`</span>&#125;&gt;&#123;item.<span class="property">name</span>&#125;&lt;/<span class="title class_">Link</span>&gt;</span><br></pre></td></tr></table></figure><p>使用 useParams() 接收 params 参数。useParams() 返回一个参数对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useParams, useMatch &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Detail</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line"><span class="keyword">const</span> &#123; id, name, age &#125; = <span class="title function_">useParams</span>();</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>id:&#123;id&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>name:&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>age:&#123;age&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是最麻烦的，需要在三个地方进行传参，如果不适用路由表，需要首先在 App 组件内传递参数。使用路由表则是在 routes&#x2F;index.js 中传参。<br>接下来需要在传递的组件中规定传递的参数。最后在接收的组件接收参数。</p><h4 id="4-3-6-2-传递-search-参数"><a href="#4-3-6-2-传递-search-参数" class="headerlink" title="4.3.6.2 传递 search 参数"></a>4.3.6.2 传递 search 参数</h4><p>传递参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Link</span> to=&#123;<span class="string">`detail?id=<span class="subst">$&#123;item.id&#125;</span>&amp;name=<span class="subst">$&#123;item.name&#125;</span>&amp;age=<span class="subst">$&#123;item.age&#125;</span>`</span>&#125;&gt;</span><br><span class="line">&#123;item.<span class="property">name</span>&#125;</span><br><span class="line">&lt;/<span class="title class_">Link</span>&gt;</span><br></pre></td></tr></table></figure><p>使用 useSearchParams() 接收参数。该方法返回一个包含两个元素的数组：search 参数和修改 search 参数的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useSearchParams &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Detail</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 数组的解构赋值</span></span><br><span class="line"><span class="keyword">const</span> [searchParams, setSearchParams] = <span class="title function_">useSearchParams</span>();</span><br><span class="line"><span class="comment">// 需要调用 get() 方法获取对应的参数值</span></span><br><span class="line"><span class="keyword">const</span> id = searchParams.<span class="title function_">get</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> name = searchParams.<span class="title function_">get</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> age = searchParams.<span class="title function_">get</span>(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">change</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">setSearchParams</span>(<span class="string">&quot;id=666&amp;name=Lily&amp;age=888&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>id:&#123;id&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>name:&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>age:&#123;age&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;change&#125;</span>&gt;</span>Change search params<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法会稍微好一点，因为他不需要修改 App 中或路由表中的内容，只需要对传递和接收的组件进行修改。</p><h4 id="4-3-6-3-传递-state-参数"><a href="#4-3-6-3-传递-state-参数" class="headerlink" title="4.3.6.3 传递 state 参数"></a>4.3.6.3 传递 state 参数</h4><p>传递 state 参数比较方便，只需要在 link 里添加一个 state 对象就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;messages.map((m) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">return (</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;m.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Link</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">to</span>=<span class="string">&quot;detail&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">state</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">id:</span> <span class="attr">m.id</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">title:</span> <span class="attr">m.title</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">content:</span> <span class="attr">m.content</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;m.title&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> showDetail(m)&#125;&gt;查看详情<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">);</span></span><br><span class="line"><span class="language-xml">&#125;)&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Outlet</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>之后在接收端，使用 useLocation() 接收参数。该方法返回路由组件的 location 对象，就是 5 版本路由组件的 location 属性，其中包含 state 参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useLocation &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Detail</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; state &#125; = <span class="title function_">useLocation</span>();</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>消息编号：&#123;state.id&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>消息标题：&#123;state.title&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>消息内容：&#123;state.content&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-7-编程式路由导航"><a href="#4-3-7-编程式路由导航" class="headerlink" title="4.3.7 编程式路由导航"></a>4.3.7 编程式路由导航</h3><p>此处使用了一个完整的例子。useNavigate() 返回一个函数，调用该函数实现编程式路由导航。函数有两种参数传递方式。</p><p>第一种方式传递两个参数：路由和相关参数。参数只能设置 replace 和 state。想要传递 params 和 search 参数直接在路由带上。</p><p>第二种方式传递数字，代表前进或后退几步。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Link</span>, <span class="title class_">Outlet</span>, useNavigate &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Message</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> navigate = <span class="title function_">useNavigate</span>();</span><br><span class="line"><span class="keyword">const</span> [messages] = <span class="title function_">useState</span>([</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="string">&quot;001&quot;</span>, <span class="attr">title</span>: <span class="string">&quot;消息1&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;锄禾日当午&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="string">&quot;002&quot;</span>, <span class="attr">title</span>: <span class="string">&quot;消息2&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;汗滴禾下土&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="string">&quot;003&quot;</span>, <span class="attr">title</span>: <span class="string">&quot;消息3&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;谁知盘中餐&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="string">&quot;004&quot;</span>, <span class="attr">title</span>: <span class="string">&quot;消息4&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;粒粒皆辛苦&quot;</span> &#125;,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showDetail</span>(<span class="params">m</span>) &#123;</span><br><span class="line"><span class="title function_">navigate</span>(<span class="string">&quot;detail&quot;</span>, &#123;</span><br><span class="line"><span class="attr">replace</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">state</span>: &#123;</span><br><span class="line"><span class="attr">id</span>: m.<span class="property">id</span>,</span><br><span class="line"><span class="attr">title</span>: m.<span class="property">title</span>,</span><br><span class="line"><span class="attr">content</span>: m.<span class="property">content</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;messages.map((m) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">return (</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;m.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Link</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">to</span>=<span class="string">&quot;detail&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">state</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">id:</span> <span class="attr">m.id</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">title:</span> <span class="attr">m.title</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">content:</span> <span class="attr">m.content</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;m.title&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> showDetail(m)&#125;&gt;查看详情<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">);</span></span><br><span class="line"><span class="language-xml">&#125;)&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Outlet</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是使用了给一般组件外带路由组件的属性。并通过绑定鼠标点击事件来给它赋予前进和后退的意义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useNavigate &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Header</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> navigate = <span class="title function_">useNavigate</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">back</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">navigate</span>(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">forward</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">navigate</span>(+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;col-xs-offset-2 col-xs-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;page-header&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>React Router Demo<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;back&#125;</span>&gt;</span>←后退<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;forward&#125;</span>&gt;</span>前进→<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-8-其他-HOOK"><a href="#4-3-8-其他-HOOK" class="headerlink" title="4.3.8 其他 HOOK"></a>4.3.8 其他 HOOK</h3><p><strong>useMatch()</strong><br>返回路由组件的 match 数据，即 5 版本中的 match 属性。</p><p>必须传入该组件对应的路由规则才能正确返回，否则返回 null。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Detail.jsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; useParams, useMatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Detail</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> match = <span class="title function_">useMatch</span>(<span class="string">&#x27;hello/message/detail/:id/:name/:age&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(match)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>id<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">params: &#123;id: &#x27;1&#x27;, name: &#x27;Bruce&#x27;, age: &#x27;33&#x27;&#125;</span></span><br><span class="line"><span class="comment">pathname: &quot;/hello/message/detail/1/Bruce/33&quot;</span></span><br><span class="line"><span class="comment">pathnameBase: &quot;/hello/message/detail/1/Bruce/33&quot;</span></span><br><span class="line"><span class="comment">pattern: &#123;path: &#x27;hello/message/detail/:id/:name/:age&#x27;, caseSensitive: false, end: true&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>useInRouterContext()</strong><br>如果组件在<code>&lt;Router&gt;</code>的上下文中呈现，则 useInRouterContext 钩子返回 true，否则返回 false。即组件有没有被包裹在<code>&lt;BrowserRouter&gt;</code>这种东西里面。这个对第三方组件库有用处。</p><p><strong>useNavigationType()</strong><br>返回当前的导航类型（用户是如何来到当前页面的）。</p><p>返回值：POP、PUSH、REPLACE。</p><p>POP 是指在浏览器中直接打开了这个路由组件（刷新页面）。</p><p><strong>useOutlet()</strong><br>用来呈现当前组件中渲染的嵌套路由。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="title function_">useOutlet</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line"><span class="comment">// 如果嵌套路由没有挂载,则返回 null</span></span><br><span class="line"><span class="comment">// 如果嵌套路由已经挂载,则展示嵌套的路由对象</span></span><br></pre></td></tr></table></figure><p><strong>useResolvedPath()</strong><br>给定一个 URL 值，解析其中的：path、search、hash 值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> res = <span class="title function_">useResolvedPath</span>(<span class="string">&#x27;/user?id=001&amp;name=Bruce#React&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hash: &#x27;#React&#x27;</span></span><br><span class="line"><span class="comment">pathname: &#x27;/user&#x27;</span></span><br><span class="line"><span class="comment">search: &#x27;?id=001&amp;name=Bruce&#x27;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="五、React-UI-组件库"><a href="#五、React-UI-组件库" class="headerlink" title="五、React UI 组件库"></a>五、React UI 组件库</h1><h2 id="5-1-material-ui"><a href="#5-1-material-ui" class="headerlink" title="5.1 material-ui"></a>5.1 material-ui</h2><p>官网：<a href="http://www.material-ui.com/">http://www.material-ui.com</a></p><h2 id="5-2-ant-design"><a href="#5-2-ant-design" class="headerlink" title="5.2 ant-design"></a>5.2 ant-design</h2><p>官网：<a href="https://ant.design/index-cn">https://ant.design/index-cn</a></p><h2 id="5-3-使用-antd"><a href="#5-3-使用-antd" class="headerlink" title="5.3 使用 antd"></a>5.3 使用 antd</h2><p>下载<code>npm i antd</code><br>感觉具体用法直接看官方文档用就完事了</p><p>要是需要暴露脚手架内容从而引用需要的 antd 样式。需要先使用 eject 将脚手架暴露，之后通过<code>react-app-rewired</code>和<code>customize-cra</code>来修改文件。<br>具体内容看官方文档吧</p><p>并且可以自定义主题</p><h1 id="六、redux"><a href="#六、redux" class="headerlink" title="六、redux"></a>六、redux</h1><h2 id="6-1-redux-理解"><a href="#6-1-redux-理解" class="headerlink" title="6.1 redux 理解"></a>6.1 redux 理解</h2><p>官方文档：<a href="https://redux.js.org/">https://redux.js.org/</a><br>中文文档：<a href="http://www.redux.org.cn/">http://www.redux.org.cn/</a></p><h3 id="6-1-1-redux-是什么"><a href="#6-1-1-redux-是什么" class="headerlink" title="6.1.1 redux 是什么"></a>6.1.1 redux 是什么</h3><ol><li>redux 是一个专门用于做<strong>状态管理</strong>的 js 库(不是 react 插件库)</li><li>可以在 react、angular、vue 等项目中，但基本使用与 react 中</li><li>作用：集中式管理 react 应用中多个组件共享的状态</li></ol><h3 id="6-1-2-什么情况下需要使用-redux"><a href="#6-1-2-什么情况下需要使用-redux" class="headerlink" title="6.1.2 什么情况下需要使用 redux"></a>6.1.2 什么情况下需要使用 redux</h3><ol><li>某个组件的状态，需要让其他组件可以随时拿到(共享)</li><li>一个组件需要改变另一个组件的状态(通信)</li><li>总体原则：能不用就不用，如果不用比较吃力才考虑使用</li></ol><h2 id="6-2-工作流程"><a href="#6-2-工作流程" class="headerlink" title="6.2 工作流程"></a>6.2 工作流程</h2><p><img src="/./../img/redux%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="redux"></p><h2 id="6-3-redux-使用"><a href="#6-3-redux-使用" class="headerlink" title="6.3 redux 使用"></a>6.3 redux 使用</h2><p>下载：<code>npm install --save redux</code><br>现在官方推荐使用 Redux Toolkit 使用 redux<br>官方文档：<a href="https://redux-toolkit.js.org/">https://redux-toolkit.js.org/</a><br>下载方式：<code>npm install @reduxjs/toolkit</code><br>或者可以使用 React 和 Redux 启动新应用程序的推荐方法是使用官方 Redux+JS 模板或 Redux+TS 模板来创建 React App，它利用了 Redux Toolkit 和 React Redux 与 React 组件的集成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Redux + Plain JS template</span><br><span class="line">npx create-react-app my-app --template redux</span><br><span class="line"></span><br><span class="line"># Redux + TypeScript template</span><br><span class="line">npx create-react-app my-app --template redux-typescript</span><br></pre></td></tr></table></figure><h1 id="七、-项目打包"><a href="#七、-项目打包" class="headerlink" title="七、 项目打包"></a>七、 项目打包</h1><p>首先执行<code>npm run build</code>，此时会生成一个 build 目录<br>可以通过 node 或者 js 放到服务器上打包<br>或者通过 serve 库来打包项目<code>npm i serve -g</code>。其的作用就是快速开启一台服务器<br>之后执行命令<code>serve build</code>来快速上线一个项目。当然这只是本地的一种简易方法，真实部署项目还是需要通过正经途径来滴。</p><h1 id="八、react-扩展内容"><a href="#八、react-扩展内容" class="headerlink" title="八、react 扩展内容"></a>八、react 扩展内容</h1><h2 id="8-1-setState-的两种方式"><a href="#8-1-setState-的两种方式" class="headerlink" title="8.1 setState 的两种方式"></a>8.1 setState 的两种方式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Count</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line">add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; count &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象式的setState</span></span><br><span class="line"><span class="comment">// this.setState(&#123;count: count + 1&#125;,()=&gt;&#123;</span></span><br><span class="line"><span class="comment">//     console.log(this.state.count);</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式的setState</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span> &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>当前求和为：&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.add&#125;</span>&gt;</span>点我加一<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>setState(stateChange,[callback])</code>————对象式的 setState<ol><li>stateChange 为状态改变对象（该对象可以体现出状态的更改）</li><li>callback 是可选的回调函数，它在状态更新完毕，界面也更新后（render 调用后）才被调用</li><li>因为 setState 是异步的，所以如果想在外部查看最新的值可能会失败，所以说如果想要查看最新的值或者进行什么操作应该写在回调函数里</li></ol></li><li><code>setState(updater,[callback])</code>————函数式的 setState<ol><li>updater 为返回 stateChange 对象的函数</li><li>updater 可以接收到 state 和 props</li><li>callback 是可选的回调函数，它在状态更新、界面更新后才被调用</li></ol></li><li>总结：<ol><li>对象式的 setState 是函数式的 setState 的简写方式（语法糖）</li><li>如果新状态不依赖于原状态&#x3D;&gt;使用对象方式</li><li>如果新状态依赖于原状态&#x3D;&gt;使用函数方式</li></ol></li></ol><h2 id="8-2-lazyLoad"><a href="#8-2-lazyLoad" class="headerlink" title="8.2 lazyLoad"></a>8.2 lazyLoad</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; lazy &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="comment">// import About from &#x27;../pages/About&#x27;</span></span><br><span class="line"><span class="comment">// import Home from &#x27;../pages/Home&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Navigate</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Home</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../pages/Home&quot;</span>));</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">About</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../pages/About&quot;</span>));</span><br></pre></td></tr></table></figure><p>通过引入 lazy 函数来实现懒加载。需要抛弃以前的引入形式，因为如果直接用 import 引入的话，就会直接加载咧。<br>所以要懒加载的话，需要通过 lazy 函数来调用加载。<br>调用懒加载的话，就需要指定一个 fallback 来指定当懒加载没有加载完毕时的<strong>等待组件或函数等</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Suspense</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NavLink</span>, useRoutes &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">&quot;./routes&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;panel-body&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;/* 注册路由 */&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">h1</span>&gt;</span>Loading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#125;&gt;&#123;element&#125;<span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>所以需要引入 Suspense 并通过其包裹注册路由的地方，给其加入 fallback 函数。<br>当然这个地方的函数可以是一个组件，也可以就是一个标签。<br>但是如果这里是一个组件的话，这个组件<strong>不能够使用懒加载</strong>，必须使用 import 进行引入</p><h2 id="8-3-Hooks"><a href="#8-3-Hooks" class="headerlink" title="8.3 Hooks"></a>8.3 Hooks</h2><ol><li>Hook 是 React 16.8 版本增加的新特性&#x2F;新语法</li><li>可以让你在函数组件中使用 state 以及其他的 React 组件</li><li>正是因为 Hook 的存在，所以说现在 React 更推荐使用函数式组件来进行编程</li></ol><h3 id="8-3-1-State-Hook"><a href="#8-3-1-State-Hook" class="headerlink" title="8.3.1 State Hook"></a>8.3.1 State Hook</h3><ol><li>State Hook 让函数组件也可以有 state 状态，并进行状态数据的读写操作</li><li>语法： <code>const[value,setValue] = React.useState(initValue)</code></li><li>useState()说明：<ol><li>参数：第一次初始化指定的值在内部作缓存</li><li>返回值：包含 2 个元素的数组，第一个为内部当前状态值，第二个为更新状态的函数</li></ol></li><li>setValue()的两种写法：<ol><li>setValue(newValue):参数为非函数值，直接指定新的状态值，内部用其覆盖原来的状态值</li><li>setValue(value &#x3D;&gt; newValue):参数为函数，接收原本的状态值，返回新的状态值，内部用其覆盖原来的状态值</li></ol></li></ol><h3 id="8-3-2-Effect-Hook"><a href="#8-3-2-Effect-Hook" class="headerlink" title="8.3.2 Effect Hook"></a>8.3.2 Effect Hook</h3><ol><li>Effect Hook 可以让你在函数组件中执行副作用操作（用于模拟类组件中的生命周期钩子）</li><li>React 中的副作用操作：<ol><li>发送 ajax 请求</li><li>设置订阅、启动定时器</li><li>手动更改真实 dom</li></ol></li><li>语法和说明：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 在此可以执行任何带副作用操作</span></span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 在组件卸载前执行</span></span><br><span class="line"><span class="comment">// 在此做一些收尾工作，比如清除定时器/取消订阅等</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;, []); <span class="comment">//如果指定的是[]，回调函数只会在第一次render()后执行</span></span><br></pre></td></tr></table></figure><ol start="4"><li>可以把 useEffect Hook 看做如下三个函数的组合：<ol><li>componentDidMount()</li><li>componentDidUpdate()</li><li>componentWillUnmount()</li></ol></li></ol><p>需要注意的是，在 react18 中，传统的卸载组件方式已经被弃用了，取而代之的是<code>unmount()</code>。<br>但是因为 react18 中，渲染方式也被重写了，所以需要注意一些地方。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 react-dom/client 引入 ReactDOM</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&quot;react-dom/client&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// React 18 的语法发生改变了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br><span class="line"></span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> root;</span><br></pre></td></tr></table></figure><p>首先需要将定义的 root 暴露出去，这样才能进行调用并卸载。<br>之后在需要进行卸载的地方，通过引入<code>index.js</code>并且调用<code>root.unmount()</code>来卸载组件</p><h3 id="8-3-3-Ref-Hook"><a href="#8-3-3-Ref-Hook" class="headerlink" title="8.3.3 Ref Hook"></a>8.3.3 Ref Hook</h3><ol><li>Ref Hook 可以在函数组件中存储&#x2F;查找组件内的标签或任意其他数据</li><li>语法：<code>const myRef = React.useRef()</code></li><li>作用：保存标签对象，功能与<code>React.createRef()</code>一样</li></ol><h3 id="8-3-4-示例"><a href="#8-3-4-示例" class="headerlink" title="8.3.4 示例"></a>8.3.4 示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> root <span class="keyword">from</span> <span class="string">&quot;./index&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myRef = <span class="title class_">React</span>.<span class="title function_">useRef</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">setCount</span>(<span class="function">(<span class="params">count</span>) =&gt;</span> count + <span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">clearInterval</span>(timer);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// setCount(count+1);</span></span><br><span class="line"><span class="title function_">setCount</span>(<span class="function">(<span class="params">count</span>) =&gt;</span> count + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">alert</span>(myRef.<span class="property">current</span>.<span class="property">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">remove</span>(<span class="params"></span>) &#123;</span><br><span class="line">root.<span class="title function_">unmount</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;myRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前求和为：&#123;count&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;add&#125;</span>&gt;</span>点我+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;remove&#125;</span>&gt;</span>点我卸载<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;show&#125;</span>&gt;</span>点我提示数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-4-Fragment"><a href="#8-4-Fragment" class="headerlink" title="8.4 Fragment"></a>8.4 Fragment</h2><p>React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Columns</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>World<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Fragments 能够正确的生成节点</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>World<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以像使用其他任意元素一样使用 &lt;&gt; &lt;&#x2F;&gt;，但它并不支持 key 或属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Columns</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>World<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Fragments 可以传递 key。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Glossary</span>(<span class="params">props</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;props.items.map((item) =&gt; (</span></span><br><span class="line"><span class="language-xml">// 没有`key`，React 会发出一个关键警告</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>&#123;item.term&#125;<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>&#123;item.description&#125;<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">))&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-5-Context"><a href="#8-5-Context" class="headerlink" title="8.5 Context"></a>8.5 Context</h2><p>一种组件间通信方式，常用于【祖组件】和【后代组件】间通信</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./index.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>();</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Provider</span>, <span class="title class_">Consumer</span> &#125; = <span class="title class_">MyContext</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">state = &#123; <span class="attr">username</span>: <span class="string">&quot;tom&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; username, age &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是A组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>我的用户名是：&#123;username&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;</span> <span class="attr">username</span>, <span class="attr">age</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">B</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是B组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>我的用户名是：<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">C</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class C extends Component &#123;</span></span><br><span class="line"><span class="comment">//     static contextType = MyContext;</span></span><br><span class="line"><span class="comment">//     render() &#123;</span></span><br><span class="line"><span class="comment">//         return (</span></span><br><span class="line"><span class="comment">//             &lt;div className=&quot;grand&quot;&gt;</span></span><br><span class="line"><span class="comment">//             &lt;h3&gt;我是C组件&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">//             &lt;h4&gt;我的用户名是：&#123;this.context&#125;&lt;/h4&gt;</span></span><br><span class="line"><span class="comment">//         &lt;/div&gt;</span></span><br><span class="line"><span class="comment">//         )</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;grand&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是C组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">我的用户名是：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Consumer</span>&gt;</span>&#123;(value) =&gt; `$&#123;value.username&#125;年龄是$&#123;value.age&#125;`&#125;<span class="tag">&lt;/<span class="name">Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><ol><li>创建 Context 容器：<code>const xxxContext = React.createContext()</code></li><li>渲染子组件时，外面包裹 XXXContext.Provider,通过 value 属性给后代组件传递数据：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Provider</span> value=&#123;&#123; username, age &#125;&#125;&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">B</span> /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Provider</span>&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>后代组件读取数据：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种：仅适用于类组件</span></span><br><span class="line"><span class="keyword">static</span> contextType = <span class="title class_">MyContext</span>; <span class="comment">//声明接收context</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">context</span> <span class="comment">//读取context中的value数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种：函数组件和类式组件都可以</span></span><br><span class="line">&lt;xxxContext.<span class="property">Consumer</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="params">value</span> =&gt;</span>&#123;   <span class="comment">//value就是context中的value数据</span></span><br><span class="line">            要显示的内容</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/xxxContext.<span class="property">Consumer</span>&gt;</span><br></pre></td></tr></table></figure></li></ol><p><strong>在实际开发中，一般不用context，因为redux可以更好的替代它</strong></p><h2 id="8-6-组件优化"><a href="#8-6-组件优化" class="headerlink" title="8.6 组件优化"></a>8.6 组件优化</h2><p>问题：</p><ul><li>只要调用<code>setState()</code>，即使没有修改状态，组件也会重新<code>render()</code></li><li>只要父组件重新渲染，即使子组件没有使用父组件的状态，也会重新<code>render()</code></li></ul><p>原因：</p><ul><li><code>shouldComponentUpdate()</code>钩子默认总是返回 true</li></ul><p>改进：</p><ul><li>只有组件的<code>state</code>或<code>props</code>的数据发生改变时才重新渲染</li></ul><p>方式：</p><ul><li>手动重写<code>shouldComponentUpdate(nextProps, nextState)</code>的逻辑，只有数据发生改变才返回<code>true</code></li><li>使用<code>PureComponent</code>，它重写了<code>shouldComponentUpdate()</code>， 只有<code>state</code>或<code>props</code>数据有变化才返回<code>true</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">PureComponent</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">PureComponent</span> &#123;</span><br><span class="line">  addStu = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 不会渲染</span></span><br><span class="line">    <span class="keyword">const</span> &#123; stus &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">    stus.<span class="title function_">unshift</span>(<span class="string">&#x27;小刘&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; stus &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新渲染</span></span><br><span class="line">    <span class="keyword">const</span> &#123; stus &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">stus</span>: [<span class="string">&#x27;小刘&#x27;</span>, ...stus] &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>它只是进行<code>state</code>和<code>props</code>数据的浅比较, 如果只是数据对象内部数据变了, 返回<code>false</code>。即对于引用数据类型，比较的是地址引用</li><li>不要直接修改<code>state</code>数据, 而是要产生新数据</li></ul><h2 id="8-7-render-props-插槽"><a href="#8-7-render-props-插槽" class="headerlink" title="8.7 render props(插槽)"></a>8.7 render props(插槽)</h2><p>React中向组件内部动态传入带内容的结构（即标签或组件）</p><ol><li>使用<code>children props</code>：通过组件标签体传入结构</li><li>使用<code>render props</code>：通过组件标签属性传入结构，可携带数据</li></ol><h3 id="8-7-1-children-props方式"><a href="#8-7-1-children-props方式" class="headerlink" title="8.7.1 children props方式"></a>8.7.1 children props方式</h3><p>组件标签体内容会存储到<code>this.props.children</code>中<br>缺点：A 组件无法向 B 组件传递数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Parent组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">A</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">B</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">A</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123; <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span> &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>A组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>B组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-7-2-render-props方式"><a href="#8-7-2-render-props方式" class="headerlink" title="8.7.2 render props方式"></a>8.7.2 render props方式</h3><ul><li><code>&lt;A render=&#123;(name) =&gt; &lt;B name=&#123;name&#125; /&gt;&#125; /&gt;</code></li><li><code>&#123;this.props.render(name)&#125;</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Parent组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">A</span> <span class="attr">render</span>=<span class="string">&#123;(name)</span> =&gt;</span> <span class="tag">&lt;<span class="name">B</span> <span class="attr">name</span>=<span class="string">&#123;name&#125;</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123; <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span> &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>A组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.props.render(name)&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>B组件,&#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="8-8-错误边界"><a href="#8-8-错误边界" class="headerlink" title="8.8 错误边界"></a>8.8 错误边界</h2><p>错误边界(Error boundary)：用来捕获后代组件错误，渲染出备用页面。<br><strong>注意：只在生产环境（项目上线）起效</strong></p><p>特点：</p><ul><li>只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误</li><li>简单理解就是只能捕获后代组件生命周期钩子里面代码的错误</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="comment">//用于标识子组件是否产生错误</span></span><br><span class="line">    <span class="attr">hasError</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当子组件出现错误，会触发调用，并携带错误信息</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// render 之前触发</span></span><br><span class="line">    <span class="comment">// 返回新的 state</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: error &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子组件产生错误时调用该钩子</span></span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">error, info</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error, info)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;此处统计错误，反馈给服务器&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Parent组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.state.hasError ? <span class="tag">&lt;<span class="name">h2</span>&gt;</span>网络不稳定，稍后再试<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> : <span class="tag">&lt;<span class="name">Child</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、使用-create-react-app-创建-react-应用&quot;&gt;&lt;a href=&quot;#一、使用-create-react-app-创建-react-应用&quot; class=&quot;headerlink&quot; title=&quot;一、使用 create-react-app 创建 react 应用&quot;&gt;&lt;/a&gt;一、使用 create-react-app 创建 react 应用&lt;/h1&gt;&lt;h2 id=&quot;1-1-react-脚手架&quot;&gt;&lt;a href=&quot;#1-1-react-脚手架&quot; class=&quot;headerlink&quot; title=&quot;1.1 react 脚手架&quot;&gt;&lt;/a&gt;1.1 react 脚手架&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;脚手架就是用来帮助快速创建一个基于 xxx 库的模板项目&lt;ol&gt;
&lt;li&gt;包含所有需要的配置(语法检查，jsx 编译，devServer…)&lt;/li&gt;
&lt;li&gt;下载好了所有相关的依赖&lt;/li&gt;
&lt;li&gt;可以直接运行一个简单效果&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;react 提供了一个用于创建 react 项目的脚手架库:create-react-app&lt;/li&gt;
&lt;li&gt;项目的整体技术架构为：react+webpack+es6+eslint&lt;/li&gt;
&lt;li&gt;使用脚手架开发的项目的特点：模块化，组件化，工程化&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>React基础</title>
    <link href="http://example.com/2022/12/26/react/"/>
    <id>http://example.com/2022/12/26/react/</id>
    <published>2022-12-26T09:00:00.000Z</published>
    <updated>2023-03-20T08:32:36.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><ol><li>发送请求获取数据</li><li>处理数据（过滤、整理格式等）</li><li><strong>操作 DOM 呈现页面</strong>（这一步是 react 的主要目的）</li></ol><p>所以说 react 是一个将数据渲染为 HTML 视图的开源 js 库</p><p>原生 js 特点：</p><ol><li>原生 js 操作 dom 繁琐，效率低</li><li>使用 js 直接操作 dom，浏览器会进行大量的重绘重排</li><li>原生 js 没有<strong>组件化</strong>编码方案，代码复用率低</li></ol><p>react 特点：</p><ol><li>采用<strong>组件化</strong>模式，<strong>声明式</strong>编码，提高开发效率及组件复用率</li><li>在 React Native 中可以使用 React 语法进行移动端开发</li><li>使用<strong>虚拟 dom</strong>和优秀的<strong>diffing 算法</strong>，尽量减少与真实 dom 的交互</li></ol><p>中文官网：<code>https://react.docschina.org</code></p><span id="more"></span><h1 id="二、入门"><a href="#二、入门" class="headerlink" title="二、入门"></a>二、入门</h1><h2 id="2-1-引入-react"><a href="#2-1-引入-react" class="headerlink" title="2.1 引入 react"></a>2.1 引入 react</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jsx组件库，用于将jsx转为js</span></span><br><span class="line">&lt;script src=<span class="string">&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="comment">// react核心库</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@16/umd/react.development.js&quot;</span> <span class="attr">crossorigin</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">// react扩展库，用于支持react操作dom</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;</span> <span class="attr">crossorigin</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="2-2-虚拟-DOM-和真实-DOM"><a href="#2-2-虚拟-DOM-和真实-DOM" class="headerlink" title="2.2 虚拟 DOM 和真实 DOM"></a>2.2 虚拟 DOM 和真实 DOM</h2><p>创建一个虚拟 DOM：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">VDOM</span> = (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello,react<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol><li><strong>虚拟 DOM 的本质是 Object 类型的对象（一般对象）</strong></li><li>虚拟 DOM 比较轻，真实 DOM 比较“重”，因为虚拟 DOM 是 React 内部在用，无需真实 DOM 上那么多的属性</li><li>虚拟 DOM 最终会被转换为真实 DOM 并渲染在页面上</li></ol><h2 id="2-3-jsx-语法"><a href="#2-3-jsx-语法" class="headerlink" title="2.3 jsx 语法"></a>2.3 jsx 语法</h2><p>全称：JavaScriptXML<br>XML 早期用于存储和传输数据</p><ol><li>定义虚拟 DOM 时，不要写引号</li><li>标签混入 js<strong>表达式</strong>时要用{}</li><li>样式的类名指定不要用 class，要用 className</li><li>内联样式，要用<code>style=&#123;&#123;key:value&#125;&#125;</code>的形式去写</li><li>只能有一个根标签</li><li>标签必须闭合</li><li>标签首字母<ol><li>若小写字母开头，则将该标签转为 html 中同名元素，若 html 中无该标签对应的同名元素，则报错</li><li>若大写字母开头，react 就去渲染对应的组件，若组件没有定义，则报错</li></ol></li><li>对于 jsx 中的每个元素，都需要产生一个<strong>唯一对应</strong>的 key</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [<span class="string">&quot;Angular&quot;</span>, <span class="string">&quot;React&quot;</span>, <span class="string">&quot;Vue&quot;</span>];</span><br><span class="line"><span class="comment">// 1.创建虚拟DOM</span></span><br><span class="line"><span class="keyword">const</span> vDom = (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>前端js框架列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;data.map((item, index) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">return <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>;</span></span><br><span class="line"><span class="language-xml">&#125;)&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 2.渲染页面</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(vDom, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure><p>要注意区分 js 语句和 js 表达式</p><ol><li>表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方<ol><li>a</li><li>a+b</li><li>demo(1)</li><li>arr.map()</li><li>function test()</li></ol></li><li>语句：控制代码语句，不会产生值<ol><li>if(){}</li><li>for(){}</li><li>switch(){case:}</li></ol></li></ol><h2 id="2-4-组件与模块"><a href="#2-4-组件与模块" class="headerlink" title="2.4 组件与模块"></a>2.4 组件与模块</h2><h3 id="2-4-1-模块"><a href="#2-4-1-模块" class="headerlink" title="2.4.1 模块"></a>2.4.1 模块</h3><ol><li>模块就是向外提供特定功能的 js 程序，一般就是一个 js 文件</li><li>为什么要拆成模块：随着业务逻辑的增加，代码越来越多且复杂</li><li>作用：复用 js，简化 js 的编写，提高 js 的运行效率</li><li>当应用的 js 都以模块化来编写的，这个应用就是一个模块化的应用</li></ol><h3 id="2-4-2-组件"><a href="#2-4-2-组件" class="headerlink" title="2.4.2 组件"></a>2.4.2 组件</h3><ol><li>用来实现局部功能效果的代码和资源的集合（html&#x2F;css&#x2F;js&#x2F;image 等等）</li><li>通过组件化，可以复用编码，简化项目编码，提高运行效率</li></ol><h2 id="2-5-jsx-奇怪的注释方法"><a href="#2-5-jsx-奇怪的注释方法" class="headerlink" title="2.5 jsx 奇怪的注释方法"></a>2.5 jsx 奇怪的注释方法</h2><p>jsx 中写注释，平时没啥事儿，都是以<code>//</code>形式的，但是如果在一个有 html 结构的地方写注释就很奇怪了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* 就必须以这种方式写注释。也就是在注释外面包一个&#123;&#125;*/ &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、React-面向组件编程"><a href="#三、React-面向组件编程" class="headerlink" title="三、React 面向组件编程"></a>三、React 面向组件编程</h1><h2 id="3-1-函数式组件"><a href="#3-1-函数式组件" class="headerlink" title="3.1 函数式组件"></a>3.1 函数式组件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Demo</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">//此处的this是undefined，因为babel编译后开启了严格模式</span></span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello,React<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 渲染组件到页面</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Demo</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>)); <span class="comment">//这里的原理就是通过大写字母开头的标签去调用组件，之后在通过/来结束这个标签</span></span><br></pre></td></tr></table></figure><h2 id="3-2-类式组件"><a href="#3-2-类式组件" class="headerlink" title="3.2 类式组件"></a>3.2 类式组件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建类式组件,react中的类必须继承于react中内置的父类React.Component</span></span><br><span class="line"><span class="comment">//render中的this是MyComponent的实例对象 &lt;=&gt; MyComponent组件实例对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello,Class<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.渲染组件到页面</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 执行了ReactDOM.render(&lt;MyComponent/&gt;...之后，发生了什么？</span></span><br><span class="line"><span class="comment"> * 1.React解析组件标签，找到了MyComponent组件</span></span><br><span class="line"><span class="comment"> * 2.发现组件是用类定义的，随后new出来该类的实例，并通过该实例调用到原型上的render方法</span></span><br><span class="line"><span class="comment"> * 3.将render返回的虚拟DOM转为真实DOM，随后呈现在页面中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>很奇怪，这里出现了个奇怪的 bug，还没法复现，属于是莫名其妙，找了好久也没找到为啥。。。</p><h2 id="3-3-组件实例的三大核心"><a href="#3-3-组件实例的三大核心" class="headerlink" title="3.3 组件实例的三大核心"></a>3.3 组件实例的三大核心</h2><p>组件实例指的是类式组件，因为函数组件里都没有 this，没法玩实例。</p><h3 id="3-3-1-state"><a href="#3-3-1-state" class="headerlink" title="3.3.1 state"></a>3.3.1 state</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weather</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line"><span class="variable language_">super</span>(props);</span><br><span class="line"><span class="comment">// 2.初始化状态</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line"><span class="attr">isHot</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">wind</span>: <span class="string">&quot;微风&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 3.读取状态</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="comment">// 这里其实是错的，因为changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用</span></span><br><span class="line"><span class="comment">// 而且类中的方法默认开启了局部的严格模式，所以changeWeather中的this是undefined</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeWeather&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">今天天气很&#123;this.state.isHot ? &quot;炎热&quot; : &quot;凉爽&quot;&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">changeWeather</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4.渲染</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Weather</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure><p>state 的是以 key 和 value 成键值存在的。和 python 中的字典类似。其主要目的就是储存一些自定义的变量值，以便以后进行调用或修改。</p><p>其中存在 this 的调用问题，因为在 class 类里会自动设置<strong>严格模式</strong>，所以说，如果在外部调用 this 会显示 undefined。<br>就算在类里<strong>直接调用</strong>，也会显示 undefined。只有通过<strong>实例调用</strong>，才能正确的调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Weather</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="comment">// 构造器只调用1次</span></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line"><span class="variable language_">super</span>(props);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">isHot</span>: <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">demo</span> = <span class="variable language_">this</span>.<span class="property">test</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// render调用1+n次，1是初始化的那次，n是状态更新的次数</span></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.demo&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">今天天气很&#123;this.state.isHot ? &quot;炎热&quot; : &quot;凉爽&quot;&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 点几次，调用几次</span></span><br><span class="line"><span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> isHot = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">isHot</span>;</span><br><span class="line"><span class="comment">// 状态必须通过setState进行改变，并且这种状态改变是合并不是替换</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">isHot</span>: !isHot &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是正确的写法，为了好理解，我改变了函数的名称。test 函数会将其自身传递到原型链上，所以说<code>this.test</code>可以通过去寻找原型链找到 test 函数，但因为其是直接调用，所以说这时候的 this 还是 undefined。但是其通过<code>bind()</code>函数，将其转换成了一个新的函数，并且赋予了其一个新的 this，所以说这个时候<code>this.test.bind()</code>变成了一个拥有类的 this 的函数，所以说这时候通过赋值语句给<code>this.demo</code>,这时候就把 this 成功的传递了。</p><p><strong>状态必须通过<code>setState()</code>进行改变，并且这种状态改变是合并不是替换</strong></p><h4 id="3-3-1-1-简写方式"><a href="#3-3-1-1-简写方式" class="headerlink" title="3.3.1.1 简写方式"></a>3.3.1.1 简写方式</h4><p>类中可以直接写赋值语句，所以可以将 state 直接写到类里进行赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Weather</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">state = &#123; <span class="attr">isHot</span>: <span class="literal">false</span>, <span class="attr">wind</span>: <span class="string">&quot;微风&quot;</span> &#125;;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 这里通过定义一个对象就能够在下面直接进行调用了</span></span><br><span class="line"><span class="keyword">const</span> &#123; isHot, wind &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeWeather&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">今天天气很&#123;isHot ? &quot;炎热&quot; : &quot;凉爽&quot;&#125;,&#123;wind&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义方法</span></span><br><span class="line"><span class="comment">// 通过赋值语句和箭头函数来实现寻找this</span></span><br><span class="line">changeWeather = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 这里也是同理</span></span><br><span class="line"><span class="keyword">const</span> isHot = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">isHot</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">isHot</span>: !isHot &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件中 render 方法中的 this 为组件实例对象<br>组建中自定义方法的 this 为 undefined，必须通过<strong>bind 方法</strong>或者<strong>箭头函数</strong>来寻找 this。</p><h3 id="3-3-2-props"><a href="#3-3-2-props" class="headerlink" title="3.3.2 props"></a>3.3.2 props</h3><h4 id="3-3-2-1-…运算符的用法"><a href="#3-3-2-1-…运算符的用法" class="headerlink" title="3.3.2.1 …运算符的用法"></a>3.3.2.1 …运算符的用法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>];</span><br><span class="line"><span class="comment">// 1. 将一个数组展开</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...arr1); <span class="comment">//1,3,5,7,9</span></span><br><span class="line"><span class="comment">// 2. 合并两个数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...arr1, ...arr2); <span class="comment">//1,3,5,7,9,2,4,6,8,10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 运用在函数中，传递一系列参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...numbers</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> numbers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">preValue, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> currentValue + preValue;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: jack, <span class="attr">age</span>: <span class="number">20</span> &#125;;</span><br><span class="line"><span class="comment">// 4. 值的复制</span></span><br><span class="line"><span class="keyword">let</span> person2 = &#123; ...person &#125;; <span class="comment">// &#123;name:jack, age:20&#125;</span></span><br><span class="line"><span class="comment">// 5. 值的复制和修改</span></span><br><span class="line"><span class="keyword">let</span> person3 = &#123; ...person, <span class="attr">name</span>: <span class="string">&quot;tom&quot;</span> &#125;; <span class="comment">// &#123;name:tom, age:20&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-2-2-props-解析"><a href="#3-3-2-2-props-解析" class="headerlink" title="3.3.2.2 props 解析"></a>3.3.2.2 props 解析</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; name, age, sex &#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>性别：&#123;age&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>年龄：&#123;sex&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对标签属性进行类型、必要性的限制</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>, <span class="comment">//限制传递类型为string，必须传递</span></span><br><span class="line"><span class="attr">sex</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="title class_">PropTypes</span>.<span class="property">number</span>,</span><br><span class="line"><span class="attr">speak</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>, <span class="comment">//限制传递类型为函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 对标签默认值进行限制</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">defaultProps</span> = &#123;</span><br><span class="line"><span class="attr">sex</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="number">222</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 可以对输入数据进行赋值类型的传递</span></span><br><span class="line"><span class="keyword">const</span> p = &#123; <span class="attr">name</span>: <span class="string">&quot;wh&quot;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">sex</span>: <span class="string">&quot;man&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 在渲染时，可以通过&#123;...p&#125;这种类型来进行值的传递</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Person</span> &#123;<span class="attr">...p</span>&#125; /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>));</span><br><span class="line"><span class="comment">// 或者说可以通过在标签中内置属性来进行数据的传递</span></span><br><span class="line"><span class="comment">// 但其实这两种处理方式的本质是相同的，都是在标签里输入数据来传递</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&quot;whh&quot;</span> <span class="attr">sex</span>=<span class="string">&quot;man&quot;</span> /&gt;</span></span>,</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test1&quot;</span>)</span><br><span class="line">); <span class="comment">//因为没传入age，所以会有一个默认age</span></span><br><span class="line"><span class="comment">// 因为age是一个数字类型，不能够使用&#x27;&#x27;进行传入，只能够通过&#123;&#125;来传入</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&quot;haha&quot;</span> <span class="attr">age</span>=<span class="string">&#123;16&#125;</span> /&gt;</span></span>,</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test2&quot;</span>)</span><br><span class="line">); <span class="comment">//因为没有sex，会传入一个默认sex。</span></span><br></pre></td></tr></table></figure><p>需要注意的是，为了添加限制性语句，也就是<code>propTypes</code>类型的语句，必须添加下面的 script 标签。因为自从 react15 以来，就把这部分内容移出去了。<br>需要单独进行调用。<br><code>&lt;script src=&quot;https://unpkg.com/prop-types@15.6/prop-types.js&quot;&gt;&lt;/script&gt;</code></p><p>需要注意的是：props 是<strong>只读</strong>的，不能<strong>直接进行修改</strong></p><h4 id="3-3-2-3-props-简写"><a href="#3-3-2-3-props-简写" class="headerlink" title="3.3.2.3 props 简写"></a>3.3.2.3 props 简写</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; name, age, sex &#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>性别：&#123;age&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>年龄：&#123;sex&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> propTypes = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>, <span class="comment">//限制传递类型为string，必须传递</span></span><br><span class="line"><span class="attr">sex</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="title class_">PropTypes</span>.<span class="property">number</span>,</span><br><span class="line"><span class="attr">speak</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>, <span class="comment">//限制传递类型为函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line"><span class="attr">sex</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="number">222</span>,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>props 的简写核心就是将<code>propTypes</code>和<code>defaultProps</code>置入类内部，通过给其添加一个 <strong>静态属性</strong> <code>static</code>从而实现</p><h4 id="3-3-2-4-构造器与-props"><a href="#3-3-2-4-构造器与-props" class="headerlink" title="3.3.2.4 构造器与 props"></a>3.3.2.4 构造器与 props</h4><p>在 react 中，<strong>一般情况下 constructor 都可以进行省略</strong>。<br>只有两种情况需要使用构造器：</p><ol><li>通过给<code>this.state</code>赋值对象来初始化内部<code>state</code>。</li><li>为事件处理函数绑定实例</li></ol><p>但是初始化内部 state 可以通过在类中直接<code>state=&#123;&#125;</code>来进行<br>而自定义事件处理函数可以通过<code>demo = () =&gt;&#123;&#125;</code>这种箭头函数的形式来实现</p><p>但是如果使用构造器，一定不能省略<code>super()</code><br>但是几乎用不到这种情况，可能会出现未定义的 bug。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="comment">// 构造器是否接收props，是否传递给super，取决于：是否希望在构造器中通过this访问props</span></span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以说，开发过程中最好别写构造器</strong></p><h4 id="3-3-2-5-函数式组件使用-props"><a href="#3-3-2-5-函数式组件使用-props" class="headerlink" title="3.3.2.5 函数式组件使用 props"></a>3.3.2.5 函数式组件使用 props</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">props</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; name, age, sex &#125; = props;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>年龄：&#123;age&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>性别：&#123;sex&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&quot;wh&quot;</span> <span class="attr">age</span>=<span class="string">&#123;18&#125;</span> <span class="attr">sex</span>=<span class="string">&quot;male&quot;</span> /&gt;</span></span>,</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>因为函数能够传递参数，所以说能够使用 props，但是不能使用 state</p><h3 id="3-3-3-refs"><a href="#3-3-3-refs" class="headerlink" title="3.3.3 refs"></a>3.3.3 refs</h3><h4 id="3-3-3-1-字符串形式的-ref"><a href="#3-3-3-1-字符串形式的-ref" class="headerlink" title="3.3.3.1 字符串形式的 ref"></a>3.3.3.1 字符串形式的 ref</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;点击按钮提示数据&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;input1&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.showData&#125;</span> <span class="attr">ref</span>=<span class="string">&quot;button&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;&quot; &quot;&#125;</span></span><br><span class="line"><span class="language-xml">点击按钮显示数据</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">placeholder</span>=<span class="string">&quot;失去焦点显示数据&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">ref</span>=<span class="string">&quot;input2&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">onBlur</span>=<span class="string">&#123;this.showData2&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 展示左侧输入框的数据</span></span><br><span class="line">showData = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// console.log(this.refs.input1);</span></span><br><span class="line"><span class="keyword">const</span> &#123; input1 &#125; = <span class="variable language_">this</span>.<span class="property">refs</span>;</span><br><span class="line"><span class="title function_">alert</span>(input1.<span class="property">value</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//展示右侧输入框的数据</span></span><br><span class="line">showData2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; input2 &#125; = <span class="variable language_">this</span>.<span class="property">refs</span>;</span><br><span class="line"><span class="title function_">alert</span>(input2.<span class="property">value</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件内的标签可以定义 ref 属性来标识自己，和 id 类似<br>ref 的形式也是以 key,value 形式来进行的。<br>key 为 ref 的名字，value 为具体的某个标签<br><code>&lt;input type=&quot;text&quot; placeholder=&#39;点击按钮提示数据&#39; ref=&#39;input1&#39;/&gt;</code></p><p><strong>string 类型的 ref 已经过时了</strong>，可能未来会被移除掉。<br>其存在一些效率上的问题。具体情况可以在 github 讨论区中看。</p><h4 id="3-3-3-2-回调形式的-ref"><a href="#3-3-3-2-回调形式的-ref" class="headerlink" title="3.3.3.2 回调形式的 ref"></a>3.3.3.2 回调形式的 ref</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;(currentNode)</span> =&gt;</span> (this.input1 = currentNode)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.showInfo&#125;</span>&gt;</span>点击提示数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showInfo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; input1 &#125; = <span class="variable language_">this</span>;</span><br><span class="line"><span class="title function_">alert</span>(input1.<span class="property">value</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过回调函数的形式也可以定义 ref。<code>&lt;input type=&quot;text&quot; ref = &#123;currentNode =&gt; this.input1 = currentNode&#125;/&gt;</code><br>但是如果 ref 回调函数是以<strong>内联函数</strong>的方式定义的，在<strong>更新过程中</strong>它会被执行两次，第一次传入参数 null，然后第二次会传入参数 DOM 元素。<br>但如果是不会更新的元素是没有影响的。因为 render 的执行次数是 1+n 次，第一次是没有影响的。只有第二次开始为更新，会产生影响。<br>内联函数类似于：<code>&lt;input ref = &#123;(c) =&gt; &#123;this.input = c; console.log(c);&#125;&#125;/&gt;</code><br><strong>通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span> = <span class="string">&#123;this.saveInput&#125;/</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">saveInput</span>(<span class="params">c</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">input1</span> = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-3-createRef"><a href="#3-3-3-3-createRef" class="headerlink" title="3.3.3.3 createRef"></a>3.3.3.3 createRef</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="comment">// React.createRef 调用后可以返回一个容器，该容器可以储存被ref所标识的节点</span></span><br><span class="line"><span class="comment">// 该容器是专人专用的</span></span><br><span class="line"><span class="comment">// 所以说每一次使用都得创建一个新的容器，好麻烦啊</span></span><br><span class="line">myRef = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">myRef2 = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;HELLO&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef2&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.showData&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">点击获取</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showData = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">myRef</span>.<span class="property">current</span>.<span class="property">value</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>React.createRef</code>每次只能存储一个节点，也就是说每一个标签想使用都需要创建一个单独的容器。</p><p><strong>ref 有一个很重要的点，就是不要过渡使用 ref</strong></p><h4 id="3-3-3-4-react-的事件处理"><a href="#3-3-3-4-react-的事件处理" class="headerlink" title="3.3.3.4 react 的事件处理"></a>3.3.3.4 react 的事件处理</h4><ol><li>通过 onXxx 属性指定事件处理函数（注意大小写）<ol><li>React 使用的是自定义(合成)事件，而不是使用的原生 DOM 事件 ————为了更好的兼容性</li><li>React 中的事件是通过事件委托方式处理的(委托给组件最外层的元素) ————为了更高效</li></ol></li><li>通过<code>event.target</code>得到发生事件的 DOM 元素对象 ———— 通过这种方式可以有效的减少 ref 的使用<ol><li>当需要处理的事件和需要添加的 ref 位于相同标签内时，可以省略 ref，通过<code>event.target</code>来在事件内寻找所需的属性</li></ol></li></ol><h2 id="3-5-收集表单数据"><a href="#3-5-收集表单数据" class="headerlink" title="3.5 收集表单数据"></a>3.5 收集表单数据</h2><h3 id="3-5-1-受控组件"><a href="#3-5-1-受控组件" class="headerlink" title="3.5.1 受控组件"></a>3.5.1 受控组件</h3><p>页面中随着输入，不断更新和维护状态，就叫做受控组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Login</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="comment">// 初始化状态</span></span><br><span class="line">state = &#123;</span><br><span class="line"><span class="attr">username</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="attr">password</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//储存用户名，将用户名维护到state中</span></span><br><span class="line">saveUsername = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">username</span>: event.<span class="property">target</span>.<span class="property">value</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 储存密码，将密码维护到state中</span></span><br><span class="line">savePassword = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">password</span>: event.<span class="property">target</span>.<span class="property">value</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 提交请求,通过维护的状态来选取</span></span><br><span class="line">handleSubmit = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">event.<span class="title function_">preventDefault</span>();</span><br><span class="line"><span class="keyword">const</span> &#123; username, password &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">`用户名为：<span class="subst">$&#123;username&#125;</span>，密码为：<span class="subst">$&#123;password&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://whcoding.cc&quot;</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">用户名：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.saveUsername&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">密码：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.savePassword&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>受控组件比非受控组件更优秀一点,因为受控组件不使用 ref,所以应该尽量使用受控组件来进行开发</p><h3 id="3-5-2-非受控组件"><a href="#3-5-2-非受控组件" class="headerlink" title="3.5.2 非受控组件"></a>3.5.2 非受控组件</h3><p>页面中所有现用现取的组件就叫做非受控组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Login</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">handleSubmit = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">event.<span class="title function_">preventDefault</span>(); <span class="comment">//阻止默认事件</span></span><br><span class="line"><span class="keyword">const</span> &#123; inputUser, inputPass &#125; = <span class="variable language_">this</span>;</span><br><span class="line"><span class="title function_">alert</span>(</span><br><span class="line"><span class="string">`您输入的用户名是：<span class="subst">$&#123;inputUser.current.value&#125;</span>，您输入的密码是：<span class="subst">$&#123;inputPass.current.value&#125;</span>`</span></span><br><span class="line">);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inputUser = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">inputPass = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://whcoding.cc&quot;</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">用户名：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;this.inputUser&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">密码：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;this.inputPass&#125;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-高阶函数、函数柯里化"><a href="#3-6-高阶函数、函数柯里化" class="headerlink" title="3.6 高阶函数、函数柯里化"></a>3.6 高阶函数、函数柯里化</h2><p>高阶函数：如果一个函数符合下面两个规范中的任何一个，那该函数就是高阶函数：</p><ol><li>若 A 函数，接收的参数时一个函数，那么 A 就可以称之为高阶函数</li><li>若 A 函数，调用的返回值依然是一个函数，那么 A 就可以称之为高阶函数</li></ol><p>常见的高阶函数有：Promise、setTimeout、数组的一些方法，比如 arr.map()等等</p><p><strong>函数的柯里化</strong>：<br>通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">saveFormData = <span class="function">(<span class="params">dataType</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;[dataType]:event.<span class="property">target</span>.<span class="property">value</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://whcoding.cc&quot;</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        用户名：</span></span><br><span class="line"><span class="language-xml">        &#123;/*onChange的回调应该是一个函数*/&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.saveFormData(</span>&#x27;<span class="attr">username</span>&#x27;)&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">密码：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">type</span>=<span class="string">&quot;password&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">name</span>=<span class="string">&quot;password&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">onChange</span>=<span class="string">&#123;this.saveFormData(</span>&#x27;<span class="attr">password</span>&#x27;)&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 saveFormData 就运用了柯里化的概念，其首先回传了一个参数叫 dataType，也正是通过这个参数来实现了不同的数据需求。<br>之后在 return 中又返回了 event，通过 event 来寻找 value。所以说是多次接收参数最后统一处理。</p><h2 id="3-7-组件的生命周期"><a href="#3-7-组件的生命周期" class="headerlink" title="3.7 组件的生命周期"></a>3.7 组件的生命周期</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Life</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">state = &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">death = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 因为组件挂载之后，定时器一直存在，如果不在卸载组件时把定时器清除掉的话，那么就会导致把组件卸载后，定时器仍然存在，从而倒置bug</span></span><br><span class="line"><span class="comment">// 清除定时器</span></span><br><span class="line"><span class="comment">// clearInterval(this.timer);</span></span><br><span class="line"><span class="comment">// 卸载组件</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">unmountComponentAtNode</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;life&quot;</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件挂载之后，只执行一次</span></span><br><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">timer</span> = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> &#123; opacity &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">opacity -= <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">if</span> (opacity &lt;= <span class="number">0</span>) opacity = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; opacity &#125;);</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件将要卸载</span></span><br><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 在这里清除定时器也行</span></span><br><span class="line"><span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timer</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// render调用的时机：初始化渲染，状态更新之后</span></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">opacity:</span> <span class="attr">this.state.opacity</span> &#125;&#125;&gt;</span>React学不会怎么办？<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.death&#125;</span>&gt;</span>不活了<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挂载(mount),就是页面进行渲染的时候，也就是把组件挂载到了页面上。<br>卸载(unmount)，就是将组件从页面上移除，就是卸载。</p><h3 id="3-7-1-组件挂载流程"><a href="#3-7-1-组件挂载流程" class="headerlink" title="3.7.1 组件挂载流程"></a>3.7.1 组件挂载流程</h3><ol><li>组件从创建到死亡它会经历一些特定的阶段</li><li>React 组件中包含一系列钩子函数(生命周期回调函数)，会在特定的时刻调用</li><li>我们在定义组件时，会在特定的生命周期回调函数中，做特定的工作</li></ol><h4 id="3-7-1-1-react-生命周期-旧"><a href="#3-7-1-1-react-生命周期-旧" class="headerlink" title="3.7.1.1 react 生命周期(旧)"></a>3.7.1.1 react 生命周期(旧)</h4><p><img src="/../img/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%97%A7.jpg" alt="生命周期"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Count</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;count=constructor&quot;</span>);</span><br><span class="line"><span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化状态</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件将要挂载的钩子</span></span><br><span class="line"><span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Count-componentWillMount&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件挂载完毕的钩子</span></span><br><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;count-componentDidMount&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件将要卸载的钩子</span></span><br><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;count-componentWillUnmount&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制state更新的钩子</span></span><br><span class="line"><span class="title function_">shouldComponentUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;count-shouldComponentUpdate&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件将要更新的钩子</span></span><br><span class="line"><span class="title function_">componentWillUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;count-componentWillUpdate&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组件完成更新的钩子</span></span><br><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;count-componentDidUpdate&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调按钮</span></span><br><span class="line">add = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; count &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: count + <span class="number">1</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">death = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">unmountComponentAtNode</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强制更新</span></span><br><span class="line">    force = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">forceUpdate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; count &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;render&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前求和为&#123;count&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.add&#125;</span>&gt;</span>点我+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.death&#125;</span>&gt;</span>点我消失<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.force&#125;</span>&gt;</span>强制更新<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，当组件加载时，顺序为<code>constructor ---&gt; componentWillMount ---&gt; render ---&gt; componentDidMount</code></p><p>当组件将要卸载时，首先通过<code>componentWillUnmount</code>，之后再进行卸载操作</p><p><code>shouldComponentUpdate</code>是关于控制状态更新的重要钩子，如果不写的话，默认会返回 true，但如果它返回了 false，则不会执行下面的操作。<br>也就是不会执行后面的<code>setState</code>、<code>render</code>等操作。组件就会就此闭合</p><p>所以说，组件的更新周期的顺序为<code>shouldComponentUpdate ---&gt; componentWillUpdate ---&gt; render --&gt; componentDidUpdate</code><br>因为第一次不会调用<code>componentWillReceiveProps</code>,只有第二次更新才会调用这个钩子，这是个坑-。-</p><p>强制更新<code>forceUpdate()</code>，可以跳过<code>shouldComponentUpdate</code>，直接从<code>componentWillUpdate</code>开始。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    state = &#123;<span class="attr">carName</span>: <span class="string">&#x27;奔驰&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    changeCar = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">carName</span>: <span class="string">&#x27;奥拓&#x27;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是A组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeCar&#125;</span>&gt;</span>换车<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;/*通过在A中引用B让其作为子组件*/ &#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">B</span> <span class="attr">carName</span>=<span class="string">&#123;this.state.carName&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="comment">// 这里有个坑，就是第一次调用的时候，不会调用这个钩子</span></span><br><span class="line">    <span class="comment">// 只有再第二次开始调用，也就是接收新的props的钩子，才会调用这个钩子</span></span><br><span class="line">    <span class="title function_">componentWillReceiveProps</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;componentWillReceiveProps&#x27;</span>,props);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是B组件，接收到的车是：&#123;this.props.carName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-7-1-2-react生命周期（新）"><a href="#3-7-1-2-react生命周期（新）" class="headerlink" title="3.7.1.2 react生命周期（新）"></a>3.7.1.2 react生命周期（新）</h4><p>React17开始更新的了新的生命周期钩子函数，对旧版的钩子函数进行了一些改动，并且加入了一些新的钩子函数。</p><p><strong>新生命周期废弃了3个旧钩子，并添加了2个新钩子</strong><br><img src="/../img/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B0.jpg" alt="file"></p><p><strong>废弃改动：</strong></p><p><code>componentWillMount</code>、<code>componentWillReceiveProps</code>、<code>componentWillUpdate</code>这三个钩子被重命名了。<br>也就是所有带will的钩子都被改动了。除了卸载的那个钩子<br>而且在18版本，必须通过<code>UNSAFE_component...</code>才能够使用了。<br>属于是提前打预防针-。-</p><p><strong>新增改动：</strong></p><p><code>getDerivedStateFromProps</code>首先是一个静态方法，其在使用前必须添加<code>static</code>。并且其需要返回一个<code>state obj</code>或者是<code>null</code><br>此方法适用于罕见的用例，<strong>即state的值在任何时候都取决于props</strong>。</p><p>派生状态会导致代码冗余，难以维护。</p><p><code>getSnapshotBeforeUpdate(prevProps, prevState)</code>其执行顺序位于<code>render</code>和<code>componentDidUpdate</code>之间。<br>其必须返回一个<code>snapshot value</code>或者是<code>null</code>。<br><code>snapshot value</code>可以是任何值，无论是number、string或者什么东西。</p><p>其在最近一次渲染输出（提交到DOM节点）之前调用。它使得组件能在发生更改之前从DOM获取一些信息（例如：滚动位置）。<br>此生命周期的任何返回值将作为参数传递给<code>componentDidUpdate()</code>。</p><p>这个钩子函数也不常见，但它可能出现在UI处理中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个例子就是不断的创建一个新闻，但是通过钩子函数去固定页面，让其保持在一个高度。</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">NewsList</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">            state = &#123;<span class="attr">newsArr</span>:[]&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取原状态</span></span><br><span class="line">                    <span class="keyword">const</span> &#123;newsArr&#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">                    <span class="comment">// 模拟一条新闻</span></span><br><span class="line">                    <span class="keyword">const</span> news = <span class="string">&#x27;新闻&#x27;</span> + (newsArr.<span class="property">length</span>+<span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 更新状态</span></span><br><span class="line">                    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">newsArr</span>: [news,...newsArr]&#125;);</span><br><span class="line">                &#125;, <span class="number">1000</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="comment">// 这里返回的是变化前的值</span></span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">refs</span>.<span class="property">list</span>.<span class="property">scrollHeight</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState,height</span>) &#123;</span><br><span class="line">                <span class="comment">// 这里的右边前面的数是变化后的值，其和变化前的值的固定差值为一个新闻的高度。</span></span><br><span class="line">                <span class="comment">// 所以可以通过不断的加去保证其固定高度。</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">refs</span>.<span class="property">list</span>.<span class="property">scrollTop</span> += <span class="variable language_">this</span>.<span class="property">refs</span>.<span class="property">list</span>.<span class="property">scrollHeight</span> - height;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (</span><br><span class="line">                    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;list&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        &#123;</span></span><br><span class="line"><span class="language-xml">                            this.state.newsArr.map((n,index) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">                                return <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;news&#x27;</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;n&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>;</span></span><br><span class="line"><span class="language-xml">                            &#125;)</span></span><br><span class="line"><span class="language-xml">                        &#125;</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-2-总结"><a href="#3-7-2-总结" class="headerlink" title="3.7.2 总结"></a>3.7.2 总结</h3><ol><li>初始化阶段： 由ReactDOM.render()触发 ——————初次渲染<ol><li>constructor()</li><li>getDerivedStateFromProps</li><li>render()</li><li>componentDidMount()</li></ol></li><li>更新阶段：由组件内部this.setState()或父组件重新render触发<ol><li>getDerivedStateFromProps</li><li>shouldComponentUpdate()</li><li>render()</li><li>getSnapshotBeforeUpdate</li><li>componentDidUpdate()</li></ol></li><li>卸载组件：由ReactDOM.unmountComponentAtNode()触发<ol><li>componentWillUnmount()</li></ol></li><li><strong>重要的钩子：</strong><ol><li>render：初始化渲染或更新渲染调用</li><li>componentDidMount()：开启监听，发送ajax请求</li><li>componentWillUnmount()：做一些收尾工作，如：清理定时器</li></ol></li><li><strong>即将废弃的钩子：</strong><ol><li>componentWillMount</li><li>componentWillReceiveProps</li><li>componentWillUpdate</li><li>这三个钩子未来可能会被弃用，现在使用也得加上<strong>UNSAFE_前缀</strong>才能使用</li></ol></li></ol><h2 id="3-8-DOM的diffing算法"><a href="#3-8-DOM的diffing算法" class="headerlink" title="3.8 DOM的diffing算法"></a>3.8 DOM的diffing算法</h2><h3 id="3-8-1-Diffing算法"><a href="#3-8-1-Diffing算法" class="headerlink" title="3.8.1 Diffing算法"></a>3.8.1 Diffing算法</h3><p>最小力度是标签。也就是在每次更新虚拟DOM时，不会更新没有改变的标签，只会更新发生变化标签。<br>标签里面套标签的话，如果里面的标签没有变化，是不会动的。</p><h3 id="3-8-2-key的作用"><a href="#3-8-2-key的作用" class="headerlink" title="3.8.2 key的作用"></a>3.8.2 key的作用</h3><p>问：1.React中的key有什么作用？（key的内部原理是什么？）<br>    2.为什么遍历列表时，key最好不要用index？</p><p>答：</p><ol><li>虚拟DOM中key的作用：<ol><li>简单的说：key是虚拟DOM对象的标识，在更新显示时key起着极其重要的作用</li><li>详细的说：当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】，随后React进行【新虚拟DOM】和【旧虚拟DOM】的diff比较，规则如下：<ol><li>就虚拟DOM中找到了与新虚拟DOM相同的key：<ol><li>若虚拟DOM中内容没变，直接使用之前的真实DOM</li><li>若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM</li></ol></li><li>旧虚拟DOM中未找到与新虚拟DOM相同的key：<ol><li>根据数据创建新的真实DOM，随后渲染到页面</li></ol></li></ol></li></ol></li><li>使用index作为key，可能会引发的问题：<ol><li>若对数据进行：逆序添加、逆序删除等破坏性操作：会产生没有必要的真实DOM更新 &#x3D;&#x3D;&gt;界面效果没问题，但是效率低</li><li>如果结构中还包含输入类的DOM：会产生错误DOM更新 &#x3D;&#x3D;&gt;界面有问题</li><li>如果不存在对数据的逆序添加，逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。</li></ol></li><li>开发中如何选择key：<ol><li>最好使用每条数据的唯一标识作为key，比如：ID,手机号、身份证号、学号等唯一值</li><li>如果确定只是简单的展示数据，用index也是可以的。</li></ol></li></ol><p>如果使用index作为key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">初始数据：</span><br><span class="line">&#123;id:0,name:&#x27;ww&#x27;,age:18&#125;,</span><br><span class="line">&#123;id:1,name:&#x27;xx&#x27;,age:19&#125;,</span><br><span class="line"></span><br><span class="line">初始的虚拟DOM:</span><br><span class="line">&lt;li key=0&gt;ww---18&lt;/li&gt;</span><br><span class="line">&lt;li key=1&gt;xx---19&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">更新了一个新数据：</span><br><span class="line">&#123;id:2,name:&#x27;zz&#x27;,age:20&#125;,</span><br><span class="line">&#123;id:0,name:&#x27;ww&#x27;,age:18&#125;,</span><br><span class="line">&#123;id:1,name:&#x27;xx&#x27;,age:19&#125;,</span><br><span class="line"></span><br><span class="line">更新后的虚拟DOM：</span><br><span class="line">&lt;li key=0&gt;zz---20&lt;/li&gt;</span><br><span class="line">&lt;li key=1&gt;ww---18&lt;/li&gt;</span><br><span class="line">&lt;li key=2&gt;xx---19&lt;/li&gt;</span><br></pre></td></tr></table></figure><p>本来是只需要更新一条数据，但是因为index的问题，导致必须三个数据都转换。使得效率降低咧。<br>如果数据量很大，那么就会导致问题很严重。<strong>严重降低效率</strong><br><strong>所以说，应该使用id（数据的唯一标识）来当做索引值</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;发送请求获取数据&lt;/li&gt;
&lt;li&gt;处理数据（过滤、整理格式等）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作 DOM 呈现页面&lt;/strong&gt;（这一步是 react 的主要目的）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以说 react 是一个将数据渲染为 HTML 视图的开源 js 库&lt;/p&gt;
&lt;p&gt;原生 js 特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原生 js 操作 dom 繁琐，效率低&lt;/li&gt;
&lt;li&gt;使用 js 直接操作 dom，浏览器会进行大量的重绘重排&lt;/li&gt;
&lt;li&gt;原生 js 没有&lt;strong&gt;组件化&lt;/strong&gt;编码方案，代码复用率低&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;react 特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;采用&lt;strong&gt;组件化&lt;/strong&gt;模式，&lt;strong&gt;声明式&lt;/strong&gt;编码，提高开发效率及组件复用率&lt;/li&gt;
&lt;li&gt;在 React Native 中可以使用 React 语法进行移动端开发&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;虚拟 dom&lt;/strong&gt;和优秀的&lt;strong&gt;diffing 算法&lt;/strong&gt;，尽量减少与真实 dom 的交互&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;中文官网：&lt;code&gt;https://react.docschina.org&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Learning to Score Figure Skating Sport Videos</title>
    <link href="http://example.com/2022/12/26/Learning%20to%20Score%20Figure%20Skating%20Sport%20Videos/"/>
    <id>http://example.com/2022/12/26/Learning%20to%20Score%20Figure%20Skating%20Sport%20Videos/</id>
    <published>2022-12-26T07:38:48.000Z</published>
    <updated>2023-03-20T08:32:35.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Learning-to-Score-Figure-Skating-Sport-Videos"><a href="#Learning-to-Score-Figure-Skating-Sport-Videos" class="headerlink" title="Learning to Score Figure Skating Sport Videos"></a>Learning to Score Figure Skating Sport Videos</h1><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>Fis-V滑冰数据集，这个数据集包括500个花滑视频，平均长度为2分50秒。每个视频由9个不同的裁判员的两个分数进行注释，即总元素分数(TES)和总项目成分分数(PCS)。</p><p>每个视频只拍摄一名滑冰运动员的<strong>整个表演</strong>;对滑冰者不相关的部分(如热身，表演后向观众鞠躬)被修剪掉。因此，每个视频的长度约为2分50秒。我们总共收集了来自20多个国家的149名专业花滑运动员的500个视频。</p><p>我们还收集了9个不同国际裁判在比赛中给出的分数。</p><p><strong>我们的花滑视频只有一个球员，整个视频只是跟踪和定位球员在她的整个表现</strong></p><p>我们用选手和比赛仔细地注释了每个视频，并标注了两个分数，分别是Total Element Score (TES)和Total Program Component Score (PCS)。这些分数是由花样滑冰比赛的评分方案给出的。具体来说，这些分数衡量的是选手在整个比赛中每个阶段的表现。<strong>TES得分用于判断所有技术动作的难度和执行力</strong>;<strong>PCS的目的是评估滑冰运动员对音乐的表现和诠释</strong>。TES和PCS都是由9位不同的裁判给出的，他们都是花滑比赛的专家。</p><p>请注意，同一名滑冰运动员在不同的比赛中可能会因其表现而获得截然不同的分数。最后，我们收集了500个关于女子单打短节目的视频，每个视频都有最真实的评分。我们将数据集随机分为400个训练视频和100个测试视频。</p><span id="more"></span><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>Self-Attentive LSTM、Multi-scale Convolutional Skip LSTM，这两个组件能够在每个视频中学习本地（local）和全局（global）的序列信息。</p><p>我们的模型可以分为两个互补的子网络，即自注意LSTM (S-LSTM)和多尺度卷积跳过LSTM (M-LSTM)。S-LSTM采用一种简单的自注意策略来选择直接用于回归任务的重要剪辑特征。</p><p>S-LSTM主要学习表示局部信息。M-LSTM在多尺度上对局部和全局序列信息进行建模。</p><p>这两个子网络都可以直接用作预测模型，或者集成到一个单独的框架中用于最终的回归任务。我们的模型是在两个花样滑冰数据集上进行评估的，即MIT-skate和我们自己的fi - v视频数据集。实验结果验证了模型的有效性。</p><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><ol><li>提出的自注意LSTM可以通过自注意策略有效地学习对局部序列信息建模。</li><li>我们提出了一种多尺度卷积跳跃LSTM模型，用于多尺度的局部和全局信息学习，同时通过跳过一些视频特征来节省计算成本。</li><li>我们贡献了一个高质量的花样滑冰视频数据集 fis - v数据集。这个数据集是现有MIT-skate数据集的3倍多。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Learning-to-Score-Figure-Skating-Sport-Videos&quot;&gt;&lt;a href=&quot;#Learning-to-Score-Figure-Skating-Sport-Videos&quot; class=&quot;headerlink&quot; title=&quot;Learning to Score Figure Skating Sport Videos&quot;&gt;&lt;/a&gt;Learning to Score Figure Skating Sport Videos&lt;/h1&gt;&lt;h2 id=&quot;数据集&quot;&gt;&lt;a href=&quot;#数据集&quot; class=&quot;headerlink&quot; title=&quot;数据集&quot;&gt;&lt;/a&gt;数据集&lt;/h2&gt;&lt;p&gt;Fis-V滑冰数据集，这个数据集包括500个花滑视频，平均长度为2分50秒。每个视频由9个不同的裁判员的两个分数进行注释，即总元素分数(TES)和总项目成分分数(PCS)。&lt;/p&gt;
&lt;p&gt;每个视频只拍摄一名滑冰运动员的&lt;strong&gt;整个表演&lt;/strong&gt;;对滑冰者不相关的部分(如热身，表演后向观众鞠躬)被修剪掉。因此，每个视频的长度约为2分50秒。我们总共收集了来自20多个国家的149名专业花滑运动员的500个视频。&lt;/p&gt;
&lt;p&gt;我们还收集了9个不同国际裁判在比赛中给出的分数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们的花滑视频只有一个球员，整个视频只是跟踪和定位球员在她的整个表现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们用选手和比赛仔细地注释了每个视频，并标注了两个分数，分别是Total Element Score (TES)和Total Program Component Score (PCS)。这些分数是由花样滑冰比赛的评分方案给出的。具体来说，这些分数衡量的是选手在整个比赛中每个阶段的表现。&lt;strong&gt;TES得分用于判断所有技术动作的难度和执行力&lt;/strong&gt;;&lt;strong&gt;PCS的目的是评估滑冰运动员对音乐的表现和诠释&lt;/strong&gt;。TES和PCS都是由9位不同的裁判给出的，他们都是花滑比赛的专家。&lt;/p&gt;
&lt;p&gt;请注意，同一名滑冰运动员在不同的比赛中可能会因其表现而获得截然不同的分数。最后，我们收集了500个关于女子单打短节目的视频，每个视频都有最真实的评分。我们将数据集随机分为400个训练视频和100个测试视频。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机视觉" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
  </entry>
  
  <entry>
    <title>FineDiving: A Fine-grained Dataset for Procedure-aware Action Quality Assessment</title>
    <link href="http://example.com/2022/09/26/finediving-a-fine-grained-dataset-for-procedure-aware-action-quality-assessment/"/>
    <id>http://example.com/2022/09/26/finediving-a-fine-grained-dataset-for-procedure-aware-action-quality-assessment/</id>
    <published>2022-09-26T07:38:48.000Z</published>
    <updated>2023-03-20T08:32:34.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FineDiving-A-Fine-grained-Dataset-for-Procedure-aware-Action-Quality-Assessment"><a href="#FineDiving-A-Fine-grained-Dataset-for-Procedure-aware-Action-Quality-Assessment" class="headerlink" title="FineDiving: A Fine-grained Dataset for Procedure-aware Action Quality Assessment"></a>FineDiving: A Fine-grained Dataset for Procedure-aware Action Quality Assessment</h1><p>用于过程感知动作质量评估的细粒度数据集</p><p>其通过将动作分段，比如这个跳水动作，将其分为四部分，首先是跳水前的准备动作，然后是旋转动作，转体动作，最后是入水动作。这就将一个完整的跳水过程划分成不同的片段来进行处理和评估。</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>现在的动作质量评估大多依赖于整个视频的深度特征来进行预测评分，这样可靠性较差</p><p>通过动作的高级语义和内部时间结构进行精准预测</p><p>所以提出了一个跳水数据集和一个用于动作质量评估的过程感知方法—&gt;基于一个时间分割注意力模块</p><p>这个也就是将一个完整的复杂动作进行分割，分割成具有不同语义和时间对应关系的连续步骤</p><p><strong>代码地址：</strong> <a href="https://github.com/xujinglin/FineDiving">https://github.com/xujinglin/FineDiving</a></p><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Action Quality Assessment (AQA) –&gt; 动作质量评估</p><p>现有的方法大多都是基于视频整体的深度特征，这对于在相似背景下发生微小差异的行动来说是很困难的。</p><p>跳水这个项目，所有的视频套路都一样，分为三个阶段，起飞，飞行，进入，细微的差别主要体现在翻跟头和转体的数量、飞行姿势和执行质量上。</p><p>但是这个咋能用在花滑里呢，跳水摄像机位置是固定的，从侧面好看，但是花滑摄像机位置都不固定，感觉比较困难。</p><p>他们通过了动作过程的细粒度注释，建立了这个细粒度数据集。来进行评分。</p><h3 id="数据集构成"><a href="#数据集构成" class="headerlink" title="数据集构成"></a>数据集构成</h3><p>[<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/FineDiving.jpg">]</p><ol><li><p>两级语义结构</p><ol><li>所有视频被标注了两个层次的语义标签，即动作类型和子动作类型，子动作类型再通过组合产生了一个动作类型</li></ol></li><li><p>两级时间结构</p><ol><li>每个视频中动作的时间边界被注释，通过经过定义的动作词汇被分解为连续的步骤</li></ol></li><li><p>官方动作评分</p></li></ol><h3 id="时间分割注意力模块-TSA"><a href="#时间分割注意力模块-TSA" class="headerlink" title="时间分割注意力模块(TSA)"></a>时间分割注意力模块(TSA)</h3><p>TSA首先将动作解析为具有语义和时间对应关系的连续步骤，用于过程感知交叉注意学习。查询操作的连续步骤作为查询，示例操作的步骤作为键和值。</p><p>然后TSA将成对查询步骤和范例步骤输入转换器，通过交叉注意学习获得过程感知嵌入。最后，TSA对过程感知嵌入进行细粒度对比回归，量化查询与范例之间的分步质量差异，并预测动作评分。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>[<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/dataset.png">]</p><p>数据集包括两级语义结构，第一级是动作的名字，第二级是子动作，是一个具体的小组件。子操作类型的每个组合都可以产生一个操作类型，不同的操作类型可以共享相同的子操作类型。绿色的分支表示不同种类的起飞。紫色、黄色和红色的分支分别代表飞行中三个位置的翻跟头(即直翻、屈翻和卷翻)，每个分支包含不同的翻跟头。橙色的分支表示在翻跟头的过程中穿插着不同的扭转。浅蓝色表示下水。(彩色效果最佳。)</p><p>[<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/Dataset-gross.jpg">] 感觉他这个数据集就是把一个完整的动作分开，分成小动作，然后再用关键帧去找这几个小动作，再把这些小动作分开打分</p><p>与以往的方法不同，我们的方法理解了行动程序，并排除了查询和范例之间的程序感知注意，从而实现更透明的行动评估。</p><h2 id="数据集详情"><a href="#数据集详情" class="headerlink" title="数据集详情"></a>数据集详情</h2><p>数据集标签定位了完整动作实例的时间边界，在注释过程中，丢弃了所有不完整的操作实例，过滤缓慢的回放。步骤级标签是动作过程中连续步骤的起始帧。</p><p>注释分成了两个阶段。</p><ol><li>粗粒度阶段：为每个动作实例标注动作类型及时间边界，附上正式的分数。</li><li>细粒度阶段：为动作过程中的每个步骤标记子动作类型，记录每个步骤的起始帧</li></ol><p>将一个完整的视频，先分开，分成一个一个的整体动作。再将每一个整体动作，分成一个一个的小步骤，因为这些步骤是连续的，所以只需要知道起始帧就行了。</p><p>总共包含3000个视频样本，涵盖52种动作类型，29个子动作类型，23种难度等级类型 [<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/hard.png">] [<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/table.png">]</p><h2 id="动作评估模块"><a href="#动作评估模块" class="headerlink" title="动作评估模块"></a>动作评估模块</h2><p>给出一个两两查询和示例实例，我们使用<strong>I3D提取时空视觉特征</strong>，并提出了一个<strong>时间分割注意力模块</strong>，通过连续完成的过程分割、过程感知交叉注意学习和细粒度对比回归来评估动作质量。</p><p>时间分割注意模块由步骤转换标签和动作评分标签监督，引导模型关注与查询步骤一致的样本区域，并量化其差异以预测可靠的动作评分。</p><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/model.png"></p><p>感觉这个就是将一个输入和用例所对应，提取出视觉特征，然后通过这个TSA模块，来预测动作质量分数。</p><h3 id="TSA"><a href="#TSA" class="headerlink" title="TSA"></a>TSA</h3><p>TSA有三个组成部分，即过程分割、过程感知交叉注意学习和细粒度对比回归。</p><ol><li><p><strong>动作过程分割</strong>将成对的查询动作实例和参考动作实例解析为语义和时间对齐的连续步骤。</p><ol><li><p>分割模块S包括“down-up”和“linear”两部分。</p><ol><li><p>其中“down-up”模块由四个“down-m-up-n”子块组成，m和n分别表示空间轴和时间轴上指定的输出维度。</p></li><li><p>每个子块包括两个连续的卷积层和一个池化层。</p></li><li><p>通过时间轴上的卷积层增加了特征的长度</p></li><li><p>通过空间轴上的最大池化层降低了维数。</p></li><li><p>所以说将视觉特征变得更长且低维，更加方便进行分割。</p></li></ol></li><li><p>“linear”负责生成L个概率分布。</p><ol><li>最后其实就是将分割问题转换成分类问题。</li><li>通过预测每一帧是否是第k步过渡的概率</li><li>再通过计算<strong>二元交叉熵损失</strong>来优化S，找到概率最大的过渡帧。</li></ol></li></ol></li></ol><p><img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/mubiaohanshu.png"></p><p>使左侧值最小来使分布更接近。越接近则表示越对齐。</p><ol start="2"><li><p><strong>过程感知交叉注意</strong>通过学习发现成对 query step 和 exemplar step 之间的时空对应关系，并在这两个步骤中生成新特征。成对的步骤相互补充，以引导模型关注 exemplar step 和 query step 中的一致区域，其中，exemplar step 保留了特征图的空间信息。</p><ol><li>过程分割之后，会有L个过渡预测，从而得到L+1个连续的步骤。</li><li>每个动作过程具有语义对应和时间对应。</li><li>这部分通过transformer来完成，MCA和MLP组成，MLP包含两层非线性GELU。</li></ol></li><li><p><strong>细粒度对比回归</strong>通过学习成对步骤的相对分数来量化查询动作实例和示例动作实例之间的一些列步骤偏差，以指导模型来评估动作质量。</p><ol><li>通过计算基础真值和预测值之间的均方误差来优化细粒度对比回归组件。</li></ol></li></ol><p>[<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/yx.png">]</p><h4 id="exemplar选取策略"><a href="#exemplar选取策略" class="headerlink" title="exemplar选取策略"></a>exemplar选取策略</h4><p>关于 TSA 中exemplar的选择策略。根据 action type 从训练集中选择exemplar。在训练阶段，对于每个训练样本（query），从具有相同 action type 的其他训练样本中随机选择一个作为 exemplar。在推理阶段，采用多样本投票策略：从具有相同 action type 的训练样本中随机选择 M 个样本作为 M 个 exemplars。</p><h2 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h2><p>[<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/pinggu.png">]</p><ol><li>13D模型通过Kinetics数据集预训练，作为F，初始学习率为10^-4^,T的初始学习率为10^-3^。</li><li>Adam优化器，权重衰减为0</li><li>每个视频提取96帧，分为9个片段，然后输入13D。每个片段包含16个连续帧。stride为10帧。</li><li>75%训练，25%测试。</li><li>b1块中的（m,n）分别等于(1024,12),(512,24),(256,48),(128,96)</li><li>b2块是一个三层MLP</li><li>M为10，L为2</li><li>每一步的帧数固定为5帧，输入MCA。3layers &amp; 8heads</li><li>每一步包含的帧数过多可能会引入一些噪声信息。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;FineDiving-A-Fine-grained-Dataset-for-Procedure-aware-Action-Quality-Assessment&quot;&gt;&lt;a href=&quot;#FineDiving-A-Fine-grained-Dataset-for-Procedure-aware-Action-Quality-Assessment&quot; class=&quot;headerlink&quot; title=&quot;FineDiving: A Fine-grained Dataset for Procedure-aware Action Quality Assessment&quot;&gt;&lt;/a&gt;FineDiving: A Fine-grained Dataset for Procedure-aware Action Quality Assessment&lt;/h1&gt;&lt;p&gt;用于过程感知动作质量评估的细粒度数据集&lt;/p&gt;
&lt;p&gt;其通过将动作分段，比如这个跳水动作，将其分为四部分，首先是跳水前的准备动作，然后是旋转动作，转体动作，最后是入水动作。这就将一个完整的跳水过程划分成不同的片段来进行处理和评估。&lt;/p&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;现在的动作质量评估大多依赖于整个视频的深度特征来进行预测评分，这样可靠性较差&lt;/p&gt;
&lt;p&gt;通过动作的高级语义和内部时间结构进行精准预测&lt;/p&gt;
&lt;p&gt;所以提出了一个跳水数据集和一个用于动作质量评估的过程感知方法—&amp;gt;基于一个时间分割注意力模块&lt;/p&gt;
&lt;p&gt;这个也就是将一个完整的复杂动作进行分割，分割成具有不同语义和时间对应关系的连续步骤&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码地址：&lt;/strong&gt; &lt;a href=&quot;https://github.com/xujinglin/FineDiving&quot;&gt;https://github.com/xujinglin/FineDiving&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机视觉" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
  </entry>
  
  <entry>
    <title>typescript基础</title>
    <link href="http://example.com/2022/08/17/typescript%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/08/17/typescript%E5%9F%BA%E7%A1%80/</id>
    <published>2022-08-17T01:12:36.000Z</published>
    <updated>2023-03-20T08:32:38.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><ol><li>以JavaScript为基础构建的语言</li><li>其是一个JavaScript的超集</li><li>TypeScript拓展了JavaScript，并添加了类型</li><li>TS不能被JS解析器直接执行，需要将ts编译为js进行执行</li><li>JavaScript是弱类型语言, 很多错误只有在运行时才会被发现。而TypeScript提供了一套静态检测机制, 可以帮助我们在编译时就发现错误</li></ol><span id="more"></span><h2 id="1-1-安装和使用"><a href="#1-1-安装和使用" class="headerlink" title="1.1 安装和使用"></a>1.1 安装和使用</h2><p>首先需要node.js 之后使用npm来下载ts</p><ol><li>首先将npm配置为淘宝镜像地址<code>npm config set registry https://registry.npm.taobao.org</code></li><li>下载typescript<code>npm i -g typescript</code></li><li>下载ts-node<code>npm i -g ts-node</code></li><li>通过<code>tsc --init</code>创建一个tsconfig.json文件</li><li>创建一个示例<code>xxx.ts</code>文件</li><li>然后就能通过<code>ts-node xxx.ts</code>来运行示例了</li><li>或者可以通过<code>tsc xxx.ts</code>来将ts编译成js</li></ol><h2 id="1-2-入门网站"><a href="#1-2-入门网站" class="headerlink" title="1.2 入门网站"></a>1.2 入门网站</h2><p>官方网站：<a href="https://www.typescriptlang.org/zh/">https://www.typescriptlang.org/zh/</a> 一个很不错的入门教程：<a href="https://juejin.cn/post/7018805943710253086?share_token=c4029c41-9cc7-4e39-9e2d-c57b6617d2d8">https://juejin.cn/post/7018805943710253086?share_token&#x3D;c4029c41-9cc7-4e39-9e2d-c57b6617d2d8</a></p><h1 id="二、基础"><a href="#二、基础" class="headerlink" title="二、基础"></a>二、基础</h1><p><strong>typescript是强类型语言</strong></p><h2 id="2-1-类型"><a href="#2-1-类型" class="headerlink" title="2.1 类型"></a>2.1 类型</h2><ol><li><p>ts中需要对声明的变量进行类型的赋予</p></li><li><p>声明变量可以直接进行赋值</p></li><li><p>如果变量的声明和赋值是同时进行的，ts可以自动对变量进行类型检测</p></li><li><p>js中的函数是不考虑参数的类型和个数的</p></li><li><p>在ts中可以通过限制类型来控制传入参数的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以先对变量进行类型的赋予，之后这个变量的类型便固定了，如果赋予其不同类型的值则会报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>:<span class="built_in">string</span>;</span><br><span class="line">a = <span class="number">123</span>;</span><br><span class="line">b = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="comment">// 如果不进行类型赋予，会以其第一个赋予的值作为其类型</span></span><br><span class="line"><span class="comment">// 这里就将c赋予了Boolean值类型</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="literal">false</span>;</span><br><span class="line">c = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 使用js中的函数形式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">aa,bb</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> aa + bb;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="attr">aa</span>:<span class="number">123</span>,<span class="attr">bb</span>:<span class="string">&#x27;hello&#x27;</span>); <span class="comment">//这里返回的就是123hello。变成了字符串拼串</span></span><br><span class="line"><span class="comment">// ts</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">aaa:<span class="built_in">number</span>,bbb:<span class="built_in">number</span></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> aaa + bbb; <span class="comment">//这里就限制了两个传入参数都必须是数字类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入除数字类型和多传入参数都会报错</span></span><br><span class="line"><span class="title function_">sum</span>(<span class="attr">aaa</span>:<span class="number">123</span>, <span class="attr">bbb</span>:<span class="string">&#x27;hello&#x27;</span>,<span class="number">345</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-1-1-注意点"><a href="#2-1-1-注意点" class="headerlink" title="2.1.1 注意点"></a>2.1.1 注意点</h3><p><strong>js中的八种类型值</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> = <span class="string">&quot;jimmy&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span> = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">bool</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="built_in">object</span> = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">big</span>: <span class="built_in">bigint</span> = <span class="number">100n</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">sym</span>: <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>(<span class="string">&quot;me&quot;</span>); </span><br></pre></td></tr></table></figure><p>默认情况下<code>null</code>和<code>undefined</code>是<strong>所有类型</strong>的子类型。 就是说你可以把<code>null</code>和<code>undefined</code>赋值给其他类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// null和undefined赋值给string</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">str</span>:<span class="built_in">string</span> = <span class="string">&quot;666&quot;</span>;</span><br><span class="line">str = <span class="literal">null</span></span><br><span class="line">str= <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined赋值给number</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>:<span class="built_in">number</span> = <span class="number">666</span>;</span><br><span class="line">num = <span class="literal">null</span></span><br><span class="line">num= <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>如果你在<code>tsconfig.json</code>指定了<code>&quot;strictNullChecks&quot;:true</code>，<code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和它们各自的类型。</p><p>虽然<code>number</code>和<code>bigint</code>都表示数字，但是这两个类型不兼容。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">big</span>: <span class="built_in">bigint</span> =  <span class="number">100n</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line">big = num;</span><br><span class="line">num = big;</span><br></pre></td></tr></table></figure><p>会抛出一个类型不兼容的 ts(2322) 错误。</p><h3 id="2-1-2-ts中的新类型"><a href="#2-1-2-ts中的新类型" class="headerlink" title="2.1.2 ts中的新类型"></a>2.1.2 ts中的新类型</h3><ol><li><p>可以直接使用字面量进行类型声明</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a : <span class="number">10</span>;</span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">11</span>; <span class="comment">//报错，不能将类型11分配给类型10</span></span><br><span class="line"><span class="comment">// 这样就限定了某一个变量的值</span></span><br></pre></td></tr></table></figure></li><li><p>但是可以使用来连接多个类型(联合类型)</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b : <span class="string">&#x27;male&#x27;</span>  <span class="string">&#x27;female&#x27;</span>;</span><br><span class="line">b = <span class="string">&#x27;male&#x27;</span>;</span><br><span class="line">b = <span class="string">&#x27;female&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> c : <span class="built_in">boolean</span>  <span class="built_in">string</span>;</span><br><span class="line">c = <span class="literal">true</span>;</span><br><span class="line">c = <span class="string">&#x27;hello&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这样就可以为一个变量进行多个赋值的选择。或者多种类型的选择</p></li><li><p>any 表示任意的类型，一个变量设置类型为any后相当于对该变量关闭ts的类型检测</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">d</span>:<span class="built_in">any</span>;</span><br><span class="line">d = <span class="number">10</span>;</span><br><span class="line">d = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">d = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 声明变量如果不指定类型，则会自动判断变量的类型为any（隐式的any）</span></span><br><span class="line"><span class="keyword">let</span> d;</span><br></pre></td></tr></table></figure><p><strong>在实际应用中尽量别用any</strong></p></li><li><p>unknown 表示未知类型的值</p><ol><li>unknown实际上就是一个类型安全的any</li><li>因为any类型的变量可以复制给任意变量，从而导致可能存在的各种问题</li><li>但是unknown类型的变量，不能直接赋值给其他变量</li></ol></li><li><p>类型断言：可以用来告诉解析器变量的实际类型</p><ol><li><p>变量 as 类型</p></li><li><p>&lt;类型&gt;变量</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> e : <span class="built_in">unknown</span>;</span><br><span class="line"><span class="keyword">let</span> s : <span class="built_in">string</span>;</span><br><span class="line">e = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">s = e; <span class="comment">//这样会报错，因为unknown不能直接赋值给其他变量</span></span><br><span class="line"><span class="comment">// 下面是类型断言，两种方式都可以</span></span><br><span class="line">s = e <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line">s = &lt;<span class="built_in">string</span>&gt;e;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>void用来表示空，以函数为例，就表示没有返回值的函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>): <span class="built_in">void</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>never表示永远不会返回结果</p><ol><li><p>在 TypeScript 中，可以利用 never 类型的特性来实现全面性检查</p></li><li><p>使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = <span class="built_in">string</span>  <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">controlFlowAnalysisWithNever</span>(<span class="params">foo: Foo</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> foo === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line"><span class="comment">// 这里 foo 被收窄为 string 类型</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> foo === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line"><span class="comment">// 这里 foo 被收窄为 number 类型</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// foo 在这里是 never</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">check</span>: <span class="built_in">never</span> = foo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>array类型。表示一个数组。数组有两种表示形式：</p><ol><li><p>string[]</p></li><li><p>Array&lt;&gt;</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面这两种表示形式是一样的</span></span><br><span class="line"><span class="keyword">let</span> g = <span class="built_in">number</span>[];</span><br><span class="line"><span class="keyword">let</span> g : <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line">g=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:(<span class="built_in">number</span>  <span class="built_in">string</span>)[];</span><br><span class="line"><span class="comment">// 表示定义了一个名称叫做arr的数组, </span></span><br><span class="line"><span class="comment">// 这个数组中将来既可以存储数值类型的数据, 也可以存储字符串类型的数据</span></span><br><span class="line">arr3 = [<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="comment">// interface是接口,后面会讲到</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Arrobj</span>&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line"><span class="attr">age</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr3</span>:<span class="title class_">Arrobj</span>[]=[&#123;<span class="attr">name</span>:<span class="string">&#x27;jimmy&#x27;</span>,<span class="attr">age</span>:<span class="number">22</span>&#125;]</span><br></pre></td></tr></table></figure></li></ol></li><li><p>元祖：元祖就是固定长度的数组</p><ol><li><p>元组最重要的特性是可以限制数组元素的个数和类型，它特别适合用来实现多值返回。</p></li><li><p>元组类型只能表示一个已知元素数量和类型的数组，长度已指定，越界访问会提示错误。如果一个数组中可能有多种类型，数量和类型都不确定，那就直接any[]</p></li><li><p>元祖支持解构赋值</p></li><li><p>元祖也支持？表示可选元素</p></li><li><p>可以通过…X来表示一个长度不固定的数组，也就是拼接数组</p></li><li><p>可以通过readonly前缀来设置只读元祖<code>const point: readonly [number, number] = [10, 20];</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这就是一个元祖形式，其类型必须匹配，并且长度为2</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">h</span>:[<span class="built_in">string</span>,<span class="built_in">number</span>];</span><br><span class="line">h = [<span class="string">&#x27;hello&#x27;</span>,<span class="number">123</span>]</span><br></pre></td></tr></table></figure><p>对于解构赋值的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">employee</span>: [<span class="built_in">number</span>, <span class="built_in">string</span>] = [<span class="number">1</span>, <span class="string">&quot;Semlinker&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> [id, username] = employee;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`id: <span class="subst">$&#123;id&#125;</span>`</span>); <span class="comment">//id:1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`username: <span class="subst">$&#123;username&#125;</span>`</span>); <span class="comment">//username:Semlinker</span></span><br><span class="line"><span class="comment">// 解构数组元素的个数不能超过元祖中元素的个数，否则会出错</span></span><br><span class="line"><span class="keyword">let</span> [id, username, age] = employee; <span class="comment">//error</span></span><br></pre></td></tr></table></figure><p>对于拼接的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">RestTupleType</span> = [<span class="built_in">number</span>, ...<span class="built_in">string</span>[]];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">restTuple</span>: <span class="title class_">RestTupleType</span> = [<span class="number">666</span>, <span class="string">&quot;Semlinker&quot;</span>, <span class="string">&quot;Kakuqo&quot;</span>, <span class="string">&quot;Lolo&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(restTuple[<span class="number">0</span>]);   <span class="comment">//666</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(restTuple[<span class="number">1</span>]);   <span class="comment">//Semlinker</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>enum 枚举,通过</p></li></ol><pre><code><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Gender</span>&#123;</span><br><span class="line"><span class="title class_">Male</span> = <span class="number">0</span>,</span><br><span class="line"><span class="title class_">Female</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">i</span>: &#123;<span class="attr">name</span>:<span class="built_in">string</span>, <span class="attr">gender</span>:<span class="title class_">Gender</span>&#125;;</span><br><span class="line">i = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;wh&#x27;</span>,</span><br><span class="line"><span class="attr">gender</span>:<span class="title class_">Gender</span>.<span class="property">Male</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ol start="11"><li>object表示一个js对象</li></ol><pre><code><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">object</span>;</span><br><span class="line">a = &#123;&#125;;</span><br></pre></td></tr></table></figure>&#123;&#125;用来指定对象中可以包含哪些属性 语法：&#123;属性名：属性值&#125; **在属性名后面加上?，表示属性是可选的**</code></pre><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">b</span>:&#123;<span class="attr">name</span>:<span class="built_in">string</span>, age?:<span class="built_in">number</span>&#125;;</span><br><span class="line"><span class="comment">// 因为age后面加了？，所以age这个属性可加可不加</span></span><br><span class="line">b = &#123;<span class="attr">name</span>:<span class="string">&#x27;wh&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [propName:string]:any 表示任意类型的属性</span></span><br><span class="line"><span class="comment">// 表示只要是名字为字符串类型的变量，都可以存在</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>:&#123;<span class="attr">name</span>:<span class="built_in">string</span>, [<span class="attr">propName</span>:<span class="built_in">string</span>]:<span class="built_in">any</span>&#125;;</span><br><span class="line">c = &#123;<span class="attr">name</span>:<span class="string">&#x27;xxx&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">gender</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><ol start="12"><li>设置函数结构的类型声明： 语法：（形参：类型,形参：类型）&#x3D;&gt; 返回值</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">d</span>: <span class="function">(<span class="params">a:<span class="built_in">number</span> , b:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line">d = <span class="keyword">function</span> (<span class="params">a,b</span>):<span class="built_in">number</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-ts的编译"><a href="#2-2-ts的编译" class="headerlink" title="2.2 ts的编译"></a>2.2 ts的编译</h2><ol><li>基础编译：<code>tsc xxx.ts</code></li><li>监视变化的编译：<code>tsc xxx.ts -w</code> 但是这两种方式都不太方便-.-</li></ol><p>所以一般使用的方法都是：<code>tsc --init</code>生成一个tsconfig.json文件 然后<code>tsc</code>进行编译。<code>tsc -w</code>进行所有文件的监视</p><h2 id="2-3-用webpack打包ts代码"><a href="#2-3-用webpack打包ts代码" class="headerlink" title="2.3 用webpack打包ts代码"></a>2.3 用webpack打包ts代码</h2><ol><li><p>对项目进行初始化 <code>npm init -y</code></p></li><li><p>下载依赖包<code>npm i -D webpack webpack-cli ts-loader</code></p><ul><li>-D代表的是在生产环境中安装的包，这些包只在开发环境中使用，用来进行代码打包等操作，不需要上传到服务环境中</li></ul></li><li><p>使用<code>tsc --init</code>生成tsconfig.json文件</p></li><li><p>创建webpack.config.json文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入包</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// webpack中的所有配置都应该写在module.exports中</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="comment">// 指定入口文件</span></span><br><span class="line"><span class="attr">entry</span>: <span class="string">&#x27;./src/index.ts&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定打包文件所在目录</span></span><br><span class="line"><span class="attr">output</span>:&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定打包文件的目录</span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打包后文件的文件</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置开发环境(development)或者是生产环境(production)，webpack4.0新增</span></span><br><span class="line"><span class="attr">mode</span>:<span class="string">&#x27;development&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定webpack打包时要使用的模块</span></span><br><span class="line"><span class="attr">module</span>:&#123;</span><br><span class="line">    <span class="comment">// 指定要加载的规则</span></span><br><span class="line">    <span class="attr">rules</span>:</span><br><span class="line">          [</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">// test指定的是规则生效的文件</span></span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">            <span class="comment">// 要使用的loader</span></span><br><span class="line">            <span class="attr">use</span>: <span class="string">&#x27;ts-loader&#x27;</span>,</span><br><span class="line">            <span class="comment">// 要排除的文件</span></span><br><span class="line">           <span class="attr">exclude</span>:<span class="regexp">/node-modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在package.json文件中加入build</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ts_webpack&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack --mode development&quot;</span>  <span class="comment">//add this</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;keywords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;ts-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^9.3.1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;webpack&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.74.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;webpack-cli&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.10.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>运行<code>npm run build</code>进行编译 上面的这些步骤只是能够将ts文件编译成js文件，但是不能够满足项目上线的需求。 所以还需要一些别的操作：</p></li><li><p><code>npm i -D html-webpack-plugin</code>-–用于生成一个HTML模板并进行引用</p></li><li><p><code>npm i -D webpack-dev-server</code> —用于能够实时调试代码，实时更新</p></li><li><p><code>npm i -D clean-webpack-plugin</code> —用来清除旧代码，保证一直是最新的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入包</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入html插件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HTMLWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CleanWebpackPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="comment">// webpack中的所有配置都应该写在module.exports中</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="comment">// 指定入口文件</span></span><br><span class="line"><span class="attr">entry</span>: <span class="string">&#x27;./src/index.ts&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定打包文件所在目录</span></span><br><span class="line"><span class="attr">output</span>:&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定打包文件的目录</span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打包后文件的文件</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置开发环境或者是生产环境，webpack4.0新增</span></span><br><span class="line"><span class="attr">mode</span>:<span class="string">&#x27;development&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定webpack打包时要使用的模块</span></span><br><span class="line"><span class="attr">module</span>:&#123;</span><br><span class="line">    <span class="comment">// 指定要加载的规则</span></span><br><span class="line">    <span class="attr">rules</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// test指定的是规则生效的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">        <span class="comment">// 要使用的loader</span></span><br><span class="line">        <span class="attr">use</span>: <span class="string">&#x27;ts-loader&#x27;</span>,</span><br><span class="line">        <span class="comment">// 要排除的文件</span></span><br><span class="line">        <span class="attr">exclude</span>:<span class="regexp">/node-modules/</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置webpack插件</span></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">  <span class="comment">// 清除旧代码</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>(),</span><br><span class="line">    <span class="comment">// 生成html文件</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HTMLWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 使用模板html文件</span></span><br><span class="line">        <span class="attr">template</span>:<span class="string">&quot;./src/index.html&quot;</span></span><br><span class="line">    &#125;),</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来设置引用模块</span></span><br><span class="line"><span class="attr">resolve</span>:&#123;</span><br><span class="line">    <span class="attr">extensions</span>:[<span class="string">&#x27;.ts&#x27;</span>,<span class="string">&#x27;.js&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在package.json中加入一些新内容：</p></li></ol><pre><code><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 表示是生产环境的webpack</span></span><br><span class="line"><span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack --mode development&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 能够通过npm start启动服务，并进行实时修改同步</span></span><br><span class="line"><span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack serve --open chrome.exe&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></code></pre><ol start="11"><li><p>为了更好的兼容性，还需要一些别的插件<code>npm i -D @babel/core @babel/preset-env babel-loader core-js</code></p></li><li><p>在webpack.config.js中的module中再添加一些东西</p></li></ol><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定webpack打包时要使用的模块</span></span><br><span class="line"><span class="attr">module</span>:&#123;</span><br><span class="line">    <span class="comment">// 指定要加载的规则</span></span><br><span class="line">    <span class="attr">rules</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// test指定的是规则生效的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">        <span class="comment">// 要使用的loader</span></span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">            <span class="comment">// 配置babel</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 指定加载器</span></span><br><span class="line">                <span class="attr">loader</span>:<span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">                <span class="comment">// 设置babel</span></span><br><span class="line">                <span class="attr">options</span>:&#123;</span><br><span class="line">                    <span class="comment">// 设置预定义的环境</span></span><br><span class="line">                    <span class="attr">presets</span>:[</span><br><span class="line">                        [</span><br><span class="line">                            <span class="comment">// 指定环境的插件</span></span><br><span class="line">                            <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">// 要兼容的目标浏览器</span></span><br><span class="line">                                <span class="attr">targets</span>:&#123;</span><br><span class="line">                                    <span class="string">&quot;chrome&quot;</span>:<span class="string">&#x27;58&#x27;</span>,</span><br><span class="line">                                    <span class="string">&quot;ie&quot;</span>:<span class="string">&#x27;11&#x27;</span></span><br><span class="line">                                &#125;,</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 指定corejs的版本</span></span><br><span class="line">                                <span class="string">&quot;corejs&quot;</span>:<span class="string">&quot;3&quot;</span>,</span><br><span class="line">                                <span class="comment">// 使用corejs的方式&quot;usage&quot;表示按需加载</span></span><br><span class="line">                                <span class="string">&quot;useBuiltIns&quot;</span>:<span class="string">&quot;usage&quot;</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&#x27;ts-loader&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// 要排除的文件</span></span><br><span class="line">        <span class="attr">exclude</span>:<span class="regexp">/node-modules/</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></code></pre><ol start="13"><li>如果为了兼容老ie，虽然现在基本没有咧。需要添加不转换箭头函数</li></ol><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定打包文件所在目录</span></span><br><span class="line"><span class="attr">output</span>:&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定打包文件的目录</span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打包后文件的文件</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉webpack不要转换箭头函数</span></span><br><span class="line">    <span class="attr">environment</span>:&#123;</span><br><span class="line">        <span class="attr">arrowFunction</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></code></pre><h2 id="2-4-类、构造函数和this"><a href="#2-4-类、构造函数和this" class="headerlink" title="2.4 类、构造函数和this"></a>2.4 类、构造函数和this</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// constructor被称为构造函数</span></span><br><span class="line">  <span class="comment">// 构造函数会在对象创建时调用</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span>, age:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">    <span class="comment">// 在实例方法中，this就表示当前的实例</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">bark</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-继承和抽象类"><a href="#2-5-继承和抽象类" class="headerlink" title="2.5 继承和抽象类"></a>2.5 继承和抽象类</h2><ul><li><p>Animal是父类，Dog是子类</p></li><li><p>使用继承后，子类将会拥有父类所有的方法和属性</p></li><li><p>通过继承可以将多个类中共有的代码写在一个父类中</p></li><li><p>在子类中添加了和父类相同的方法，则子类方法会覆盖掉父类方法</p></li><li><p>抽象类的作用就是专门用来被继承</p></li><li><p>抽象类中可以添加抽象方法</p></li><li><p>抽象类不能用来创建对象</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以abstract开头的类就是抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line"><span class="attr">age</span>:<span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span>, age:<span class="built_in">number</span></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayHello</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;动物在叫~&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法只能定义在抽象类中，子类必须对抽象方法进行重写</span></span><br><span class="line"><span class="comment">// 抽象方法没有方法体</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="title function_">say</span>():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// 如果子类写了构造函数，必须写super调用父类</span></span><br><span class="line"><span class="comment">// 和react什么都一样</span></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span>, age:<span class="built_in">number</span></span>)&#123;</span><br><span class="line"><span class="variable language_">super</span>(name);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayHello</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">// 在类的方法中，super就表示当前类的父类</span></span><br><span class="line"><span class="variable language_">super</span>.<span class="title function_">sayHello</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">run</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>在跑...`</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line"><span class="title function_">sayHello</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;喵喵喵&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺财&quot;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog);</span><br><span class="line">dog.<span class="title function_">run</span>();</span><br></pre></td></tr></table></figure></li></ul><h1 id="三、接口"><a href="#三、接口" class="headerlink" title="三、接口"></a>三、接口</h1><ul><li>接口用来定义一个类结构,用来定义一个类中应该包含哪些属性和方法</li><li>同时接口也可以当成类型声明去使用</li><li>接口可以在定义类的时候去限制类的结构<ul><li><strong>接口中的所有的属性不能有实际的值</strong></li><li>接口只定义对象的结构，而不考虑实际值</li><li>在接口中所有的方法都是抽象方法</li><li>接口一般首字母大写</li><li>定义的变量比接口多&#x2F;少一些属性是不允许的</li><li><strong>赋值的时候，变量的形状必须和接口的形状保持一致</strong></li></ul></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInter</span>&#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">  age?:<span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// 通过索引签名的形式可以使接口中有其他的任意属性</span></span><br><span class="line">  [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">  <span class="title function_">sayHello</span>():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义类时，可以使类去实现一个接口，也就是使类满足接口的要求</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">MyInter</span>&#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span>, age:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口可以定义多次，会被自动合并为单个接口。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123; <span class="attr">y</span>: <span class="built_in">number</span>; &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">point</span>: <span class="title class_">Point</span> = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><h2 id="3-1-可选只读属性"><a href="#3-1-可选只读属性" class="headerlink" title="3.1 可选只读属性"></a>3.1 可选只读属性</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只读属性用于限制只能在对象刚刚创建的时候修改其值。此外 TypeScript 还提供了<code>ReadonlyArray&lt;T&gt;</code>类型，它与 <code>Array&lt;T&gt;</code>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">ro</span>: <span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line">ro.<span class="title function_">push</span>(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line">ro.<span class="property">length</span> = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><h2 id="3-2-几种绕开额外属性检查的方法"><a href="#3-2-几种绕开额外属性检查的方法" class="headerlink" title="3.2 几种绕开额外属性检查的方法"></a>3.2 几种绕开额外属性检查的方法</h2><h3 id="3-2-1-鸭式辩型法"><a href="#3-2-1-鸭式辩型法" class="headerlink" title="3.2.1 鸭式辩型法"></a>3.2.1 鸭式辩型法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">LabeledValue</span> &#123;</span><br><span class="line">  <span class="attr">label</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printLabel</span>(<span class="params">labeledObj: LabeledValue</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(labeledObj.<span class="property">label</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myObj = &#123; <span class="attr">size</span>: <span class="number">10</span>, <span class="attr">label</span>: <span class="string">&quot;Size 10 Object&quot;</span> &#125;;</span><br><span class="line"><span class="title function_">printLabel</span>(myObj); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">LabeledValue</span> &#123;</span><br><span class="line">  <span class="attr">label</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printLabel</span>(<span class="params">labeledObj: LabeledValue</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(labeledObj.<span class="property">label</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printLabel</span>(&#123; <span class="attr">size</span>: <span class="number">10</span>, <span class="attr">label</span>: <span class="string">&quot;Size 10 Object&quot;</span> &#125;); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>上面代码，在参数里写对象就相当于是直接给<code>labeledObj</code>赋值，这个对象有严格的类型定义，所以不能多参或少参。而当你在外面将该对象用另一个变量<code>myObj</code>接收，<code>myObj</code>不会经过额外属性检查，但会根据类型推论为<code>let myObj: &#123; size: number; label: string &#125; = &#123; size: 10, label: &quot;Size 10 Object&quot; &#125;;</code>，然后将这个<code>myObj</code>再赋值给<code>labeledObj</code>，此时根据类型的兼容性，两种类型对象，参照鸭式辨型法，因为都具有<code>label</code>属性，所以被认定为两个相同，故而可以用此法来绕开多余的类型检查。</p><h3 id="3-2-2-类型断言"><a href="#3-2-2-类型断言" class="headerlink" title="3.2.2 类型断言"></a>3.2.2 类型断言</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>; </span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>; </span><br><span class="line">  money?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p</span>: <span class="title class_">Props</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;兔神&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">money</span>: -<span class="number">100000</span>,</span><br><span class="line">  <span class="attr">girl</span>: <span class="literal">false</span></span><br><span class="line">&#125; <span class="keyword">as</span> <span class="title class_">Props</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><h3 id="3-2-3-索引签名"><a href="#3-2-3-索引签名" class="headerlink" title="3.2.3 索引签名"></a>3.2.3 索引签名</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>; </span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>; </span><br><span class="line">  money?: <span class="built_in">number</span>;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p</span>: <span class="title class_">Props</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;兔神&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">money</span>: -<span class="number">100000</span>,</span><br><span class="line">  <span class="attr">girl</span>: <span class="literal">false</span></span><br><span class="line">&#125;; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><h2 id="3-3-接口和类型别名"><a href="#3-3-接口和类型别名" class="headerlink" title="3.3 接口和类型别名"></a>3.3 接口和类型别名</h2><p>接口和类型别名在大多数情况下效果是等价的，但是实际还是有区别的。 首先从定义的角度：</p><ul><li><p>接口的作用就是为类型命名和为代码或第三方代码定义数据类型</p></li><li><p>type（类型别名）会给一个类型起个新名字。起别名不会新建一个类型，只是创建了一个新名字来引用某个类型。 从语法角度讲： Interface:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SetPoint</span> &#123;</span><br><span class="line">(<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Type:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line"><span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SetPoint</span> = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure></li></ul><p>与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primitive</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// object</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialPointX</span> = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialPointY</span> = &#123; <span class="attr">y</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// union</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialPoint</span> = <span class="title class_">PartialPointX</span>  <span class="title class_">PartialPointY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tuple</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Data</span> = [<span class="built_in">number</span>, <span class="built_in">string</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// dom</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">type</span> B = <span class="keyword">typeof</span> div;</span><br></pre></td></tr></table></figure><p><strong>接口可以定义多次,类型别名不可以</strong></p><ul><li>接口和类型别名的扩展方式不同，但并不互斥。接口可以扩展类型别名，同理，类型别名也可以扩展接口。</li><li>接口的扩展就是继承，通过<code>extends</code>来实现。类型别名的扩展就是交叉类型，通过<code>&amp;</code>来实现。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PointX</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> <span class="keyword">extends</span> <span class="title class_">PointX</span> &#123;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PointX</span> = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = <span class="title class_">PointX</span> &amp; &#123;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、属性的封装"><a href="#四、属性的封装" class="headerlink" title="四、属性的封装"></a>四、属性的封装</h1><p>通过在属性前添加属性的修饰符</p><ul><li><p>public: 修饰的属性可以在任意位置访问（修改）默认值</p></li><li><p>private:私有属性，私有属性只能在类内部进行访问（修改）</p></li><li><p>通过在类中添加方法使得私有属性可以被外部访问</p></li><li><p>protected:受保护的属性，只能在当前类和当前类的子类中访问</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="attr">_name</span>: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="attr">_age</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">get</span> <span class="title function_">age</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_age</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="title function_">age</span>(<span class="params">value: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_age</span> = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> per = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;tom&#x27;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per);   <span class="comment">//tom 18</span></span><br><span class="line">per.<span class="property">name</span> = <span class="string">&#x27;jack&#x27;</span>;</span><br><span class="line">per.<span class="property">age</span> = -<span class="number">18</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per);  <span class="comment">// jack 18</span></span><br></pre></td></tr></table></figure><p>可以直接将属性定义在构造函数中：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> name:<span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">          <span class="keyword">private</span> age:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">          <span class="keyword">protected</span> gender:<span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">          <span class="keyword">public</span> flag:<span class="built_in">boolean</span></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="五、泛型"><a href="#五、泛型" class="headerlink" title="五、泛型"></a>五、泛型</h1><ul><li><p>在定义函数或是类时，如果遇到类型不明确就可以使用泛型</p></li><li><p>泛型可以同时指定多个</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> fn&lt;T&gt;(<span class="attr">a</span>: T): T&#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>&#x2F;&#x2F; 可以直接调用具有泛型的函数 let result &#x3D; fn(a:10); &#x2F;&#x2F;不指定泛型，TS可以自动对类型进行推断 let result2 &#x3D; fn<string>(a: ‘hello’); &#x2F;&#x2F;指定泛型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">在泛型中T代表Type，在定义泛型时通常用作第一个类型变量名称。但实际上T可以用任何有效名称代替。除了T之外，以下是常见泛型变量代表的意思：</span><br><span class="line">- K（Key）：表示对象中的键类型；</span><br><span class="line">- V（Value）：表示对象中的值类型；</span><br><span class="line">- E（Element）：表示元素类型。</span><br><span class="line"></span><br><span class="line">使用extends关键字让T继承接口的类型从而实现类型约束。简单来说就是你定义一个类型，然后让 T 实现这个接口即可</span><br><span class="line">```ts</span><br><span class="line">interface Sizeable &#123;</span><br><span class="line">  size: number;</span><br><span class="line">&#125;</span><br><span class="line">function trace&lt;T extends Sizeable&gt;(arg: T): T &#123;</span><br><span class="line">  console.log(arg.size);</span><br><span class="line">  return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-1-typeof"><a href="#5-1-typeof" class="headerlink" title="5.1 typeof"></a>5.1 typeof</h2><p><strong>typeof 的主要用途是在类型上下文中获取变量或者属性的类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">sem</span>: <span class="title class_">Person</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;semlinker&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Sem</span> = <span class="keyword">typeof</span> sem; <span class="comment">// type Sem = Person</span></span><br></pre></td></tr></table></figure><p>typeof 操作符除了可以获取对象的结构类型之外，它也可以用来获取函数对象的类型，比如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toArray</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Func</span> = <span class="keyword">typeof</span> toArray; <span class="comment">// -&gt; (x: number) =&gt; number[]</span></span><br></pre></td></tr></table></figure><h2 id="5-2-keyof"><a href="#5-2-keyof" class="headerlink" title="5.2 keyof"></a>5.2 keyof</h2><p>keyof可以用于获取某种类型的所有键，其返回类型是联合类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">K1</span> = keyof <span class="title class_">Person</span>; <span class="comment">// &quot;name&quot;  &quot;age&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">K2</span> = keyof <span class="title class_">Person</span>[]; <span class="comment">// &quot;length&quot;  &quot;toString&quot;  &quot;pop&quot;  &quot;push&quot;  &quot;concat&quot;  &quot;join&quot; </span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">K3</span> = keyof &#123; [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="title class_">Person</span> &#125;;  <span class="comment">// string  number</span></span><br></pre></td></tr></table></figure><h1 id="六、tsconfig-json文件"><a href="#六、tsconfig-json文件" class="headerlink" title="六、tsconfig.json文件"></a>六、tsconfig.json文件</h1><ul><li>files - 设置要编译的文件的名称；</li><li>include - 设置需要进行编译的文件，支持路径模式匹配；</li><li>exclude - 设置无需进行编译的文件，支持路径模式匹配；</li><li>compilerOptions - 设置与编译流程相关的选项。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 基本选项 */</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es5&quot;</span><span class="punctuation">,</span>                       <span class="comment">// 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES6&#x27;/&#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;commonjs&quot;</span><span class="punctuation">,</span>                  <span class="comment">// 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span>                             <span class="comment">// 指定要包含在编译中的库文件</span></span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                       <span class="comment">// 允许编译 javascript 文件</span></span><br><span class="line">    <span class="attr">&quot;checkJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                       <span class="comment">// 报告 javascript 文件中的错误</span></span><br><span class="line">    <span class="attr">&quot;jsx&quot;</span><span class="punctuation">:</span> <span class="string">&quot;preserve&quot;</span><span class="punctuation">,</span>                     <span class="comment">// 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;</span></span><br><span class="line">    <span class="attr">&quot;declaration&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                   <span class="comment">// 生成相应的 &#x27;.d.ts&#x27; 文件</span></span><br><span class="line">    <span class="attr">&quot;sourceMap&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                     <span class="comment">// 生成相应的 &#x27;.map&#x27; 文件</span></span><br><span class="line">    <span class="attr">&quot;outFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span>                       <span class="comment">// 将输出文件合并为一个文件</span></span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span>                        <span class="comment">// 指定输出目录</span></span><br><span class="line">    <span class="attr">&quot;rootDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span>                       <span class="comment">// 用来控制输出目录结构 --outDir.</span></span><br><span class="line">    <span class="attr">&quot;removeComments&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                <span class="comment">// 删除编译后的所有的注释</span></span><br><span class="line">    <span class="attr">&quot;noEmit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                        <span class="comment">// 不生成输出文件</span></span><br><span class="line">    <span class="attr">&quot;importHelpers&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                 <span class="comment">// 从 tslib 导入辅助工具函数</span></span><br><span class="line">    <span class="attr">&quot;isolatedModules&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>               <span class="comment">// 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 严格的类型检查选项 */</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                        <span class="comment">// 启用所有严格类型检查选项</span></span><br><span class="line">    <span class="attr">&quot;noImplicitAny&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                 <span class="comment">// 在表达式和声明上有隐含的 any类型时报错</span></span><br><span class="line">    <span class="attr">&quot;strictNullChecks&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>              <span class="comment">// 启用严格的 null 检查</span></span><br><span class="line">    <span class="attr">&quot;noImplicitThis&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                <span class="comment">// 当 this 表达式值为 any 类型的时候，生成一个错误</span></span><br><span class="line">    <span class="attr">&quot;alwaysStrict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                  <span class="comment">// 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 额外的检查 */</span></span><br><span class="line">    <span class="attr">&quot;noUnusedLocals&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                <span class="comment">// 有未使用的变量时，抛出错误</span></span><br><span class="line">    <span class="attr">&quot;noUnusedParameters&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>            <span class="comment">// 有未使用的参数时，抛出错误</span></span><br><span class="line">    <span class="attr">&quot;noImplicitReturns&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>             <span class="comment">// 并不是所有函数里的代码都有返回值时，抛出错误</span></span><br><span class="line">    <span class="attr">&quot;noFallthroughCasesInSwitch&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>    <span class="comment">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 模块解析选项 */</span></span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node&quot;</span><span class="punctuation">,</span>            <span class="comment">// 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span>                       <span class="comment">// 用于解析非相对模块名称的基目录</span></span><br><span class="line">    <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span>                           <span class="comment">// 模块名到基于 baseUrl 的路径映射的列表</span></span><br><span class="line">    <span class="attr">&quot;rootDirs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span>                        <span class="comment">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span></span><br><span class="line">    <span class="attr">&quot;typeRoots&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span>                       <span class="comment">// 包含类型声明的文件列表</span></span><br><span class="line">    <span class="attr">&quot;types&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span>                           <span class="comment">// 需要包含的类型声明文件名列表</span></span><br><span class="line">    <span class="attr">&quot;allowSyntheticDefaultImports&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>  <span class="comment">// 允许从没有设置默认导出的模块中默认导入。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="attr">&quot;sourceRoot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span>                    <span class="comment">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span></span><br><span class="line">    <span class="attr">&quot;mapRoot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span>                       <span class="comment">// 指定调试器应该找到映射文件而不是生成文件的位置</span></span><br><span class="line">    <span class="attr">&quot;inlineSourceMap&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>               <span class="comment">// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span></span><br><span class="line">    <span class="attr">&quot;inlineSources&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                 <span class="comment">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 其他选项 */</span></span><br><span class="line">    <span class="attr">&quot;experimentalDecorators&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>        <span class="comment">// 启用装饰器</span></span><br><span class="line">    <span class="attr">&quot;emitDecoratorMetadata&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span>          <span class="comment">// 为装饰器提供元数据的支持</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;以JavaScript为基础构建的语言&lt;/li&gt;
&lt;li&gt;其是一个JavaScript的超集&lt;/li&gt;
&lt;li&gt;TypeScript拓展了JavaScript，并添加了类型&lt;/li&gt;
&lt;li&gt;TS不能被JS解析器直接执行，需要将ts编译为js进行执行&lt;/li&gt;
&lt;li&gt;JavaScript是弱类型语言, 很多错误只有在运行时才会被发现。而TypeScript提供了一套静态检测机制, 可以帮助我们在编译时就发现错误&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>git时忽略node_modules的方法</title>
    <link href="http://example.com/2022/08/16/git%E6%97%B6%E5%BF%BD%E7%95%A5node-modules%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2022/08/16/git%E6%97%B6%E5%BF%BD%E7%95%A5node-modules%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2022-08-16T01:57:35.000Z</published>
    <updated>2023-03-20T08:32:34.453Z</updated>
    
    <content type="html"><![CDATA[<p>一开始使用git时，我发现node_modules是自动忽略的，但是后来突然开始上传node_modules了。所以查阅了一下资料，发现是缺了<code>.gitgnore</code>文件。 所以在git时想忽略<code>node_modules</code>文件夹，需要在项目目录下，新建<code>.gitgnore</code>文件。 <img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-1660615037295.png" alt="file"> 然后在文件内输入<code>node_modules/</code>就可以了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一开始使用git时，我发现node_modules是自动忽略的，但是后来突然开始上传node_modules了。所以查阅了一下资料，发现是缺了&lt;code&gt;.gitgnore&lt;/code&gt;文件。 所以在git时想忽略&lt;code&gt;node_modules&lt;/code&gt;文件夹，需</summary>
      
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>getter和setter方法</title>
    <link href="http://example.com/2022/07/21/getter%E5%92%8Csetter%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2022/07/21/getter%E5%92%8Csetter%E6%96%B9%E6%B3%95/</id>
    <published>2022-07-21T09:44:36.000Z</published>
    <updated>2023-03-20T08:32:34.407Z</updated>
    
    <content type="html"><![CDATA[<p>有两种类型的对象属性。 第一种是<strong>数据属性</strong>。我们已经知道如何使用它们了。到目前为止，我们使用过的所有属性都是<strong>数据属性</strong>。 第二种类型的属性是新东西。它是<strong>访问器属性</strong>（accessor property）。它们本质上是用于获取和设置值的函数，但从外部代码来看就像常规属性。</p><p>访问器属性由 “getter” 和 “setter” 方法表示。在对象字面量中，它们用<code>get</code>和<code>set</code>表示：</p><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">propName</span>() &#123;</span><br><span class="line">    <span class="comment">// 当读取 obj.propName 时，getter 起作用</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">propName</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 当执行 obj.propName = value 操作时，setter 起作用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当读取<code>obj.propName</code>时，<code>getter</code>起作用，当<code>obj.propName</code>被赋值时，<code>setter</code>起作用。 例如，我们有一个具有 name 和 surname 属性的对象 user：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">surname</span>: <span class="string">&quot;Smith&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在我们想添加一个<code>fullName</code>属性，该属性值应该为<code>&quot;John Smith&quot;</code>。当然，我们不想复制粘贴已有的信息，因此我们可以使用访问器来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">surname</span>: <span class="string">&quot;Smith&quot;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.surname&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">fullName</span>); <span class="comment">// John Smith</span></span><br></pre></td></tr></table></figure><p>从外表看，访问器属性看起来就像一个普通属性。这就是访问器属性的设计思想。我们不以函数的方式<strong>调用</strong><code>user.fullName</code>，我们正常<strong>读取</strong>它：<code>getter</code>在幕后运行。</p><p>截至目前，<code>fullName</code>只有一个<code>getter</code>。如果我们尝试赋值操作<code>user.fullName=</code>，将会出现错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`...`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">user.<span class="property">fullName</span> = <span class="string">&quot;Test&quot;</span>; <span class="comment">// Error（属性只有一个 getter）</span></span><br></pre></td></tr></table></figure><p>让我们通过为<code>user.fullName</code>添加一个<code>setter</code>来修复它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">surname</span>: <span class="string">&quot;Smith&quot;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.surname&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">fullName</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    [<span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">this</span>.<span class="property">surname</span>] = value.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// set fullName 将以给定值执行</span></span><br><span class="line">user.<span class="property">fullName</span> = <span class="string">&quot;Alice Cooper&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">name</span>); <span class="comment">// Alice</span></span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">surname</span>); <span class="comment">// Cooper</span></span><br></pre></td></tr></table></figure><p><strong>所以说，如果只给一个属性设置get而不设置set，则这个属性是只读的，不可被修改。</strong></p><p>可以通过使用<code>defineProperty</code>创建一个<code>fullName</code>访问器，我们可以使用<code>get</code>和<code>set</code>来传递描述符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">surname</span>: <span class="string">&quot;Smith&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(user, <span class="string">&#x27;fullName&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.surname&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    [<span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">this</span>.<span class="property">surname</span>] = value.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">fullName</span>); <span class="comment">// John Smith</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> user) <span class="title function_">alert</span>(key); <span class="comment">// name, surname</span></span><br></pre></td></tr></table></figure><p>请注意，一个属性要么是访问器（具有 get&#x2F;set 方法），要么是数据属性（具有 value），但不能两者都是。 如果我们试图在同一个描述符中同时提供 get 和 value，则会出现错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error: Invalid property descriptor.</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(&#123;&#125;, <span class="string">&#x27;prop&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">value</span>: <span class="number">2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有两种类型的对象属性。 第一种是&lt;strong&gt;数据属性&lt;/strong&gt;。我们已经知道如何使用它们了。到目前为止，我们使用过的所有属性都是&lt;strong&gt;数据属性&lt;/strong&gt;。 第二种类型的属性是新东西。它是&lt;strong&gt;访问器属性&lt;/strong&gt;（accessor property）。它们本质上是用于获取和设置值的函数，但从外部代码来看就像常规属性。&lt;/p&gt;
&lt;p&gt;访问器属性由 “getter” 和 “setter” 方法表示。在对象字面量中，它们用&lt;code&gt;get&lt;/code&gt;和&lt;code&gt;set&lt;/code&gt;表示：&lt;/p&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>新版vscode中无法使用tab+！生成html模板的解决方法</title>
    <link href="http://example.com/2022/07/21/%E6%96%B0%E7%89%88vscode%E4%B8%AD%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8tab%EF%BC%81%E7%94%9F%E6%88%90html%E6%A8%A1%E6%9D%BF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2022/07/21/%E6%96%B0%E7%89%88vscode%E4%B8%AD%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8tab%EF%BC%81%E7%94%9F%E6%88%90html%E6%A8%A1%E6%9D%BF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2022-07-21T09:37:51.000Z</published>
    <updated>2023-03-20T08:32:39.288Z</updated>
    
    <content type="html"><![CDATA[<p>自从前几天更新了 vscode 后发现无法再使用 tab+！生成标准 html 模板了。 后来查阅资料发现，他是把默认生成符改了。 新版 vscode 可以通过输入<code>html:5</code>来生成模板。如下图所示： <img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-1658395859477.png" alt="file"></p><p>当然还可以使用一些别的方法来生成原先的模板，并且可以自定义一些自己的模板。</p><ol><li><p>首先点击左下角设置，之后点击配置用户代码片段。 <img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-1658395968863.png" alt="file"></p></li><li><p>进入后搜索<code>html.json</code>，并点击进入 <img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-1658396012948.png" alt="file"></p></li><li><p>在改文件内添加模板： <img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/image-1658396080005.png" alt="file"> 具体如下： html5 标准模板：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;html:5&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;!&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;&lt;!DOCTYPE html&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;html&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;head&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;meta charset=\&quot;UTF-8\&quot;&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;meta name=\&quot;viewport\&quot; content=\&quot;width=device-width, initial-scale=1.0\&quot;&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;meta http-equiv=\&quot;X-UA-Compatible\&quot; content=\&quot;ie=edge\&quot;&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;title&gt;&lt;/title&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;/head&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;body&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;/body&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;/html&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HTML5&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我自己使用的 react 模板：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;react&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;!!&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;&lt;!DOCTYPE html&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;html&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;head&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;meta charset=\&quot;UTF-8\&quot;&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;meta name=\&quot;viewport\&quot; content=\&quot;width=device-width, initial-scale=1.0\&quot;&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;meta http-equiv=\&quot;X-UA-Compatible\&quot; content=\&quot;ie=edge\&quot;&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;title&gt;&lt;/title&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;/head&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;body&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;div&gt;&lt;/div&gt;\n\t&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;script src=\&quot;https://unpkg.com/babel-standalone@6/babel.min.js\&quot;&gt;&lt;/script&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;script src=\&quot;https://unpkg.com/react@16/umd/react.development.js\&quot; crossorigin&gt;&lt;/script&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;script src=\&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js\&quot; crossorigin&gt;&lt;/script&gt;\n\t&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;script type=\&quot;text/babel\&quot;&gt;\n\t\t&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;\t&lt;/script&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;/body&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;&lt;/html&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>其中 prefix 表示快捷键 <code>\t</code>表示前面空出一个 tab <code>\n</code>表示换行，也就是下面会空一行</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自从前几天更新了 vscode 后发现无法再使用 tab+！生成标准 html 模板了。 后来查阅资料发现，他是把默认生成符改了。 新版 vscode 可以通过输入&lt;code&gt;html:5&lt;/code&gt;来生成模板。如下图所示： &lt;img src=&quot;https://blogw</summary>
      
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>js中的class</title>
    <link href="http://example.com/2022/07/21/js%E4%B8%AD%E7%9A%84class/"/>
    <id>http://example.com/2022/07/21/js%E4%B8%AD%E7%9A%84class/</id>
    <published>2022-07-21T09:16:30.000Z</published>
    <updated>2023-03-20T08:32:34.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、class语法"><a href="#一、class语法" class="headerlink" title="一、class语法"></a>一、class语法</h1><h2 id="1-1-class基本语法"><a href="#1-1-class基本语法" class="headerlink" title="1.1 class基本语法"></a>1.1 class基本语法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="comment">// class 方法</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">  <span class="title function_">method1</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">  <span class="title function_">method2</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">  <span class="title function_">method3</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用<code>new MyClass()</code>来创建具有上述列出的所有方法的新对象。</p><p>new 会自动调用<code>constructor()</code>方法，因此我们可以在<code>constructor()</code>中初始化对象。</p><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 构造器方法</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">user.<span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure><p>当<code>new User(&quot;John&quot;)</code>被调用：</p><ol><li>一个新对象被创建。</li><li><code>constructor</code>使用给定的参数运行，并将其赋值给<code>this.name</code>。</li></ol><p>……然后我们就可以调用对象方法了，例如<code>user.sayHi</code>。</p><p>注意： <strong>类的方法之间没有逗号</strong> 对于新手开发人员来说，常见的陷阱是在类的方法之间放置逗号，这会导致语法错误。 不要把这里的符号与对象字面量相混淆。在类中，不需要逗号。</p><h2 id="1-2-什么是class"><a href="#1-2-什么是class" class="headerlink" title="1.2 什么是class"></a>1.2 什么是class</h2><p><strong>在JavaScript中，类是一种函数。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123; <span class="variable language_">this</span>.<span class="property">name</span> = name; &#125;</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// class 是一个函数</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="title class_">User</span>); <span class="comment">// function</span></span><br><span class="line"><span class="comment">// ...或者，更确切地说，是 constructor 方法</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">User</span> === <span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 方法在 User.prototype 中，例如：</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span>); <span class="comment">// sayHi 方法的代码</span></span><br><span class="line"><span class="comment">// 在原型中实际上有两个方法</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>)); <span class="comment">// constructor, sayHi</span></span><br></pre></td></tr></table></figure><p>所以说创建一个类时，其中的方法会被储存在原型中，所以在调用对象时可以访问类中的方法。 而构造器的作用就是来指定这个类的作用，也就是类这个函数的代码。</p><h2 id="1-3-类不是单纯的语法糖"><a href="#1-3-类不是单纯的语法糖" class="headerlink" title="1.3 类不是单纯的语法糖"></a>1.3 类不是单纯的语法糖</h2><ol><li><p>首先，通过 class 创建的函数具有特殊的内部属性标记<code>[[IsClassConstructor]]: true</code>。因此，它与手动创建并不完全相同。 编程语言会在许多地方检查该属性。例如，与普通函数不同，必须使用 new 来调用它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="title class_">User</span>); <span class="comment">// function</span></span><br><span class="line"><span class="title class_">User</span>(); <span class="comment">// Error: Class constructor User cannot be invoked without &#x27;new&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>类方法不可枚举。 类定义将 “prototype” 中的所有方法的<code>enumerable</code>标志设置为<code>false</code>。这很好，因为如果我们对一个对象调用<code>for..in</code>方法，我们通常不希望<code>class</code>方法出现。</p></li><li><p>类总是使用<code>use strict</code>。 在类构造中的所有代码都将自动进入严格模式。</p></li></ol><p><strong>就像函数一样，类可以在另外一个表达式中被定义，被传递，被返回，被赋值等。</strong></p><h2 id="1-4-类字段"><a href="#1-4-类字段" class="headerlink" title="1.4 类字段"></a>1.4 类字段</h2><p><strong>“类字段”是一种允许添加任何属性的语法。</strong> 类字段重要的不同之处在于，它们会在每个独立对象中被设好，而不是设在<code>User.prototype</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">name</span>); <span class="comment">// John</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>我们也可以在赋值时使用更复杂的表达式和函数调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  name = <span class="title function_">prompt</span>(<span class="string">&quot;Name, please?&quot;</span>, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">name</span>); <span class="comment">// John</span></span><br></pre></td></tr></table></figure><p>类字段<code>click = () =&gt; &#123;...&#125;</code>是基于每一个对象被创建的，在这里对于每一个<code>Button</code>对象都有一个独立的方法，在内部都有一个指向此对象的<code>this</code>。我们可以把 <code>button.click</code>传递到任何地方，而且<code>this</code>的值总是正确的。 在浏览器环境中，它对于进行事件监听尤为有用。</p><h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  prop = value; <span class="comment">// 属性</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">...</span>) &#123; <span class="comment">// 构造器</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">method</span>(<span class="params">...</span>) &#123;&#125; <span class="comment">// method</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">something</span>(<span class="params">...</span>) &#123;&#125; <span class="comment">// getter 方法</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">something</span>(<span class="params">...</span>) &#123;&#125; <span class="comment">// setter 方法</span></span><br><span class="line"></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;&#125; <span class="comment">// 有计算名称（computed name）的方法（此处为 symbol）</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>技术上来说，<code>MyClass</code>是一个函数（我们提供作为<code>constructor</code>的那个），而<code>methods</code>、<code>getters</code>和<code>settors</code>都被写入了<code>MyClass.prototype</code>。</p><h1 id="二、类的继承"><a href="#二、类的继承" class="headerlink" title="二、类的继承"></a>二、类的继承</h1><p><code>class Child extends Parent</code>是类的继承的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">speed</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">run</span>(<span class="params">speed</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">speed</span> = speed;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> runs with speed <span class="subst">$&#123;<span class="variable language_">this</span>.speed&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">stop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">speed</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> stands still.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类rabbit继承了父类animal的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rabbit</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">hide</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> hides!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> <span class="title class_">Rabbit</span>(<span class="string">&quot;White Rabbit&quot;</span>);</span><br><span class="line"></span><br><span class="line">rabbit.<span class="title function_">run</span>(<span class="number">5</span>); <span class="comment">// White Rabbit runs with speed 5.</span></span><br><span class="line">rabbit.<span class="title function_">hide</span>(); <span class="comment">// White Rabbit hides!</span></span><br></pre></td></tr></table></figure><h2 id="2-1-重写方法"><a href="#2-1-重写方法" class="headerlink" title="2.1 重写方法"></a>2.1 重写方法</h2><p>通常，我们不希望完全替换父类的方法，而是希望在父类方法的基础上进行调整或扩展其功能。我们在我们的方法中做一些事儿，但是在它之前或之后或在过程中会调用父类方法。 Class 为此提供了<code>&quot;super&quot;</code>关键字。</p><ul><li>执行<code>super.method(...)</code>来调用一个父类方法。</li><li>执行<code>super(...)</code>来调用一个父类<code>constructor</code>（只能在我们的<code>constructor</code>中）。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">speed</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">run</span>(<span class="params">speed</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">speed</span> = speed;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> runs with speed <span class="subst">$&#123;<span class="variable language_">this</span>.speed&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">stop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">speed</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> stands still.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rabbit</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">hide</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> hides!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">stop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">stop</span>(); <span class="comment">// 调用父类的 stop</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">hide</span>(); <span class="comment">// 然后 hide</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> <span class="title class_">Rabbit</span>(<span class="string">&quot;White Rabbit&quot;</span>);</span><br><span class="line">rabbit.<span class="title function_">run</span>(<span class="number">5</span>); <span class="comment">// White Rabbit runs with speed 5.</span></span><br><span class="line">rabbit.<span class="title function_">stop</span>(); <span class="comment">// White Rabbit stands still. White Rabbit hides!</span></span><br></pre></td></tr></table></figure><p>现在,<code>Rabbit</code>在执行过程中调用父类的<code>super.stop()</code>方法，所以<code>Rabbit</code>也具有了<code>stop</code>方法。</p><p><strong>箭头函数没有<code>super</code>，如果被访问，它会从外部函数获取。</strong></p><h2 id="2-2-重写constructor"><a href="#2-2-重写constructor" class="headerlink" title="2.2 重写constructor"></a>2.2 重写constructor</h2><p>如果一个类扩展了另一个类并且没有<code>constructor</code>，那么将生成下面这样的“空”<code>constructor</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rabbit</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="comment">// 为没有自己的 constructor 的扩展类生成的</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承类的<code>constructor</code>必须调用<code>super(...)</code>，并且一定要在使用<code>this</code>之前调用。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">speed</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rabbit</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, earLength</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">earLength</span> = earLength;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在可以了</span></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> <span class="title class_">Rabbit</span>(<span class="string">&quot;White Rabbit&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="title function_">alert</span>(rabbit.<span class="property">name</span>); <span class="comment">// White Rabbit</span></span><br><span class="line"><span class="title function_">alert</span>(rabbit.<span class="property">earLength</span>); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h1 id="三、静态属性和静态方法"><a href="#三、静态属性和静态方法" class="headerlink" title="三、静态属性和静态方法"></a>三、静态属性和静态方法</h1><p>我们可以把一个方法作为一个整体赋值给类。这样的方法被称为<strong>静态的（static）</strong>。 在一个类的声明中，它们以<code>static</code>关键字开头，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">staticMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span> === <span class="title class_">User</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">User</span>.<span class="title function_">staticMethod</span>(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>通常，<strong>静态方法用于实现属于整个类，但不属于该类任何特定对象的函数</strong>。 例如，我们有对象<code>Article</code>，并且需要一个方法来比较它们。 通常的解决方案就是添加<code>Article.compare</code>静态方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">title, date</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">title</span> = title;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">date</span> = date;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">compare</span>(<span class="params">articleA, articleB</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> articleA.<span class="property">date</span> - articleB.<span class="property">date</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">let</span> articles = [</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Article</span>(<span class="string">&quot;HTML&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">1</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Article</span>(<span class="string">&quot;CSS&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2019</span>, <span class="number">0</span>, <span class="number">1</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Article</span>(<span class="string">&quot;JavaScript&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">1</span>))</span><br><span class="line">];</span><br><span class="line">articles.<span class="title function_">sort</span>(<span class="title class_">Article</span>.<span class="property">compare</span>);</span><br><span class="line"><span class="title function_">alert</span>( articles[<span class="number">0</span>].<span class="property">title</span> ); <span class="comment">// CSS</span></span><br></pre></td></tr></table></figure><p><strong>静态方法不适用于单个对象</strong>。静态方法可以在类上调用，而不是在单个对象上。</p><p>静态的属性也是可能的，它们看起来就像常规的类属性，但前面加有 static：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> publisher = <span class="string">&quot;Levi Ding&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( <span class="title class_">Article</span>.<span class="property">publisher</span> ); <span class="comment">// Levi Ding</span></span><br></pre></td></tr></table></figure><p>这等同于直接给 Article 赋值： <code>Article.publisher = &quot;Levi Ding&quot;;</code></p><p><strong>静态属性和方法是可被继承的。</strong></p><p><strong>静态属性被用于当我们想要存储类级别的数据时，而不是绑定到实例。</strong></p><h1 id="四、私有的和受保护的属性和方法"><a href="#四、私有的和受保护的属性和方法" class="headerlink" title="四、私有的和受保护的属性和方法"></a>四、私有的和受保护的属性和方法</h1><h2 id="4-1-内部接口喝外部接口"><a href="#4-1-内部接口喝外部接口" class="headerlink" title="4.1 内部接口喝外部接口"></a>4.1 内部接口喝外部接口</h2><p>在面向对象的编程中，属性和方法分为两组：</p><ul><li><strong>内部接口</strong> —— 可以通过该类的其他方法访问，但不能从外部访问的方法和属性。</li><li><strong>外部接口</strong> —— 也可以从类的外部访问的方法和属性。</li></ul><p>在 JavaScript 中，有两种类型的对象字段（属性和方法）：</p><ul><li>公共的：可从任何地方访问。它们构成了外部接口。到目前为止，我们只使用了公共的属性和方法。</li><li>私有的：只能从类的内部访问。这些用于内部接口。 在许多其他编程语言中，还存在“受保护”的字段：只能从类的内部和基于其扩展的类的内部访问（例如私有的，但可以从继承的类进行访问）。它们对于内部接口也很有用。从某种意义上讲，它们比私有的属性和方法更为广泛，因为我们通常希望继承类来访问它们。 受保护的字段不是在语言级别的 Javascript 中实现的，但实际上它们非常方便，因为它们是在 Javascript 中模拟的类定义语法。</li></ul><h2 id="4-2-受保护的属性"><a href="#4-2-受保护的属性" class="headerlink" title="4.2 受保护的属性"></a>4.2 受保护的属性</h2><p><strong>受保护的属性通常以下划线 _ 作为前缀。</strong> 这不是在语言级别强制实施的，但是程序员之间有一个众所周知的约定，即不应该从外部访问此类型的属性和方法。 此处以创建一个咖啡机为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeMachine</span> &#123;</span><br><span class="line">  _waterAmount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">waterAmount</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      value = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_waterAmount</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">waterAmount</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_waterAmount</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">power</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_power</span> = power;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建咖啡机</span></span><br><span class="line"><span class="keyword">let</span> coffeeMachine = <span class="keyword">new</span> <span class="title class_">CoffeeMachine</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 加水</span></span><br><span class="line">coffeeMachine.<span class="property">waterAmount</span> = -<span class="number">10</span>; <span class="comment">// _waterAmount 将变为 0，而不是 -10</span></span><br></pre></td></tr></table></figure><p>现在访问已受到控制，因此将水量的值设置为小于零的数变得不可能。</p><h2 id="4-3-只读的属性"><a href="#4-3-只读的属性" class="headerlink" title="4.3 只读的属性"></a>4.3 只读的属性</h2><p>对于<code>power</code>属性，让我们将它设为只读。有时候一个属性必须只能被在创建时进行设置，之后不再被修改。 咖啡机就是这种情况：功率永远不会改变。 要做到这一点，我们只需要设置 getter，而不设置 setter：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeMachine</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">power</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_power</span> = power;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">power</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_power</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建咖啡机</span></span><br><span class="line"><span class="keyword">let</span> coffeeMachine = <span class="keyword">new</span> <span class="title class_">CoffeeMachine</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">`Power is: <span class="subst">$&#123;coffeeMachine.power&#125;</span>W`</span>); <span class="comment">// 功率是：100W</span></span><br><span class="line">coffeeMachine.<span class="property">power</span> = <span class="number">25</span>; <span class="comment">// Error（没有 setter）</span></span><br></pre></td></tr></table></figure><p>这里我们使用了 getter&#x2F;setter 语法。 但大多数时候首选 get…&#x2F;set… 函数，像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeMachine</span> &#123;</span><br><span class="line">  _waterAmount = <span class="number">0</span>;</span><br><span class="line">  <span class="title function_">setWaterAmount</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) value = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_waterAmount</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getWaterAmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_waterAmount</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">CoffeeMachine</span>().<span class="title function_">setWaterAmount</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>这看起来有点长，但函数更灵活。它们可以接受多个参数（即使我们现在还不需要）。 另一方面，get&#x2F;set 语法更短，所以最终没有严格的规定，而是由你自己来决定。</p><p><strong>受保护的字段是可以被继承的</strong></p><h2 id="4-4-私有的属性"><a href="#4-4-私有的属性" class="headerlink" title="4.4 私有的属性"></a>4.4 私有的属性</h2><p>私有属性和方法应该以 # 开头。它们只在类的内部可被访问。 在语言级别，# 是该字段为私有的特殊标志。我们无法从外部或从继承的类中访问它。 私有字段与公共字段不会发生冲突。我们可以同时拥有私有的<code>#waterAmount</code>和公共的<code>waterAmount</code>字段。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeMachine</span> &#123;</span><br><span class="line"></span><br><span class="line">  #waterAmount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">waterAmount</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#waterAmount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">waterAmount</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) value = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.#waterAmount = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> machine = <span class="keyword">new</span> <span class="title class_">CoffeeMachine</span>();</span><br><span class="line"></span><br><span class="line">machine.<span class="property">waterAmount</span> = <span class="number">100</span>;</span><br><span class="line"><span class="title function_">alert</span>(machine.#waterAmount); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>目前，各个浏览器对私有字段的支持不是很好，但可以用 polyfill 解决。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、class语法&quot;&gt;&lt;a href=&quot;#一、class语法&quot; class=&quot;headerlink&quot; title=&quot;一、class语法&quot;&gt;&lt;/a&gt;一、class语法&lt;/h1&gt;&lt;h2 id=&quot;1-1-class基本语法&quot;&gt;&lt;a href=&quot;#1-1-class基本语法&quot; class=&quot;headerlink&quot; title=&quot;1.1 class基本语法&quot;&gt;&lt;/a&gt;1.1 class基本语法&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;MyClass&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// class 方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;title function_&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &amp;#123; ... &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;title function_&quot;&gt;method1&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &amp;#123; ... &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;title function_&quot;&gt;method2&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &amp;#123; ... &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;title function_&quot;&gt;method3&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &amp;#123; ... &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;然后使用&lt;code&gt;new MyClass()&lt;/code&gt;来创建具有上述列出的所有方法的新对象。&lt;/p&gt;
&lt;p&gt;new 会自动调用&lt;code&gt;constructor()&lt;/code&gt;方法，因此我们可以在&lt;code&gt;constructor()&lt;/code&gt;中初始化对象。&lt;/p&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>axios详解</title>
    <link href="http://example.com/2022/07/13/axios%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/07/13/axios%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-07-13T10:04:15.000Z</published>
    <updated>2023-03-20T08:32:32.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、配置和下载"><a href="#一、配置和下载" class="headerlink" title="一、配置和下载"></a>一、配置和下载</h1><h2 id="1-1-json-server"><a href="#1-1-json-server" class="headerlink" title="1.1 json-server"></a>1.1 json-server</h2><p>首先是 json-server 的下载和安装</p><ol><li>在命令行中输入<code>npm install -g json-server</code></li><li>在需要使用的文件夹下创建文件 db.json</li><li>在 db.json 中置入内容</li></ol><span id="more"></span><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;posts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;json-server&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;typicode&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;comments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;profile&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;typicode&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>开启 json-server 服务：<code>json-server --watch db.json</code></li></ol><p>json-server 主要是提供一个虚假的服务器，从而实现数据通信。在本文中主要起演示作用</p><h2 id="1-2-axios"><a href="#1-2-axios" class="headerlink" title="1.2 axios"></a>1.2 axios</h2><p>从下面方式中选择一项进行安装或使用</p><ol><li>通过 npm 安装：<code>npm install axios</code></li><li>通过 bower 安装：<code>bower install axios</code></li><li>通过 yarn 安装：<code>yarn add axios</code></li><li>通过 pnpm 安装：<code>pnpm add axios</code></li><li>直接使用 script 调用 api：<code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</code></li><li>可以通过国内网站<code>https://www.bootcdn.cn/</code>来调用国内 api 从而加快访问速度：<code>&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/1.0.0-alpha.1/axios.js&quot;&gt;&lt;/script&gt;</code></li></ol><p>在项目中使用 axios 一般使用上面几种方式来进行，但是在日常练习中，可以直接调用 api</p><h1 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h1><h2 id="2-1-基本使用"><a href="#2-1-基本使用" class="headerlink" title="2.1 基本使用"></a>2.1 基本使用</h2><p>基本请求共包含四个，分别是 GET&#x2F;POST&#x2F;PUT&#x2F;DELETE 在 json-server 服务中 GET 表示查看内容，POST 表示新增内容，PUT 表示修改内容，DELETE 表示删除内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送请求，获得内容</span></span><br><span class="line">btn[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="comment">// 发送方法</span></span><br><span class="line">        <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">        <span class="comment">// 发送链接</span></span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000/posts/2&quot;</span>,</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 添加新内容</span></span><br><span class="line">btn[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="comment">// 发送方法</span></span><br><span class="line">        <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        <span class="comment">// 发送链接</span></span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000/posts&quot;</span>,</span><br><span class="line">        <span class="comment">// 设置请求体</span></span><br><span class="line">        <span class="attr">data</span>: &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">            <span class="attr">author</span>: <span class="string">&quot;wh&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以 PUT 和 POST 为例，主要需要设置发送的<strong>请求方法</strong>，和<strong>请求的连接</strong>，如果需要的话，还需要设置<strong>请求体</strong></p><h2 id="2-2-axios-的其他使用"><a href="#2-2-axios-的其他使用" class="headerlink" title="2.2 axios 的其他使用"></a>2.2 axios 的其他使用</h2><p>axios 和 ajax 比较类似，可以直接使用现成的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">request</span>(config)</span><br><span class="line">axios.<span class="title function_">get</span>(url[, config])</span><br><span class="line">axios.<span class="title function_">delete</span>(url[, config])</span><br><span class="line">axios.<span class="title function_">head</span>(url[, config])</span><br><span class="line">axios.<span class="title function_">options</span>(url[, config])</span><br><span class="line">axios.<span class="title function_">post</span>(url[, data[, config]])</span><br><span class="line">axios.<span class="title function_">put</span>(url[, data[, config]])</span><br><span class="line">axios.<span class="title function_">patch</span>(url[, data[, config]])</span><br></pre></td></tr></table></figure><p>具体的使用举例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">btn[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    axios</span><br><span class="line">        .<span class="title function_">request</span>(&#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">            <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000/comments&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//发送post请求</span></span><br><span class="line">btn[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    axios</span><br><span class="line">        .<span class="title function_">post</span>(<span class="string">&quot;http://localhost:3000/comments&quot;</span>, &#123;</span><br><span class="line">            <span class="attr">body</span>: <span class="string">&quot;hahahaha&quot;</span>,</span><br><span class="line">            <span class="attr">postId</span>: <span class="number">2</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-3-axios-的响应"><a href="#2-3-axios-的响应" class="headerlink" title="2.3 axios 的响应"></a>2.3 axios 的响应</h2><p>config：配置对象，包括 url，请求方式等内容 data：响应体的内容 headers：响应头的信息 request：原生的 ajax 请求对象 status：响应状态码 statusText：响应状态</p><h2 id="2-4-axios-配置对象详细说明"><a href="#2-4-axios-配置对象详细说明" class="headerlink" title="2.4 axios 配置对象详细说明"></a>2.4 axios 配置对象详细说明</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 请求地址，可以将前面的省略从而和baseURL结合</span></span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求方法</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// axios会将baseURL和url相结合，所以说如果要调用统一域名下的不同url，这样就会很方便</span></span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://some-domain.com/api/&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对请求数据进行一个处理，处理完成后再发送给服务器</span></span><br><span class="line">  <span class="comment">// 只能对四种基本方法进行操作</span></span><br><span class="line">  <span class="attr">transformRequest</span>: [<span class="keyword">function</span> (<span class="params">data, headers</span>) &#123;</span><br><span class="line">    <span class="comment">// Do whatever you want to transform the data</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对返回的结果进行处理</span></span><br><span class="line">  <span class="attr">transformResponse</span>: [<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// Do whatever you want to transform the data</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 传递数据头</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;<span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span>&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个的主要目的是当发送url时，有时候需要在url后面加一些字符串数据，但是直接加不方便，就可以通过这个方法，它会自动将其中的键和值插入到url最后面</span></span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对请求的参数进行一个序列化，根据接口不同而不同</span></span><br><span class="line">  <span class="attr">paramsSerializer</span>: &#123;</span><br><span class="line">    <span class="attr">indexes</span>: <span class="literal">null</span> <span class="comment">// array indexes format (null - no brackets, false - empty brackets, true - brackets with indexes)</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求体设置，共分为两种，分别是字符串格式和对象形式</span></span><br><span class="line">  <span class="comment">// 对象形式axios会将其转换为json格式，字符串格式会直接进行传递</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">data</span>: <span class="string">&#x27;Country=Brasil&amp;City=Belo Horizonte&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 超时时间，单位为ms</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>, <span class="comment">// default is `0` (no timeout)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//跨域请求时对cookie是否携带，false为不携带</span></span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">false</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//发送ajax请求或者是http请求</span></span><br><span class="line">  <span class="attr">adapter</span>: <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置用户名和密码</span></span><br><span class="line">  <span class="attr">auth</span>: &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;janedoe&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;s00pers3cret&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对响应体格式做一个要求</span></span><br><span class="line">  <span class="attr">responseType</span>: <span class="string">&#x27;json&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 响应体编码</span></span><br><span class="line">  <span class="attr">responseEncoding</span>: <span class="string">&#x27;utf8&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跨域请求cookie设置</span></span><br><span class="line">  <span class="attr">xsrfCookieName</span>: <span class="string">&#x27;XSRF-TOKEN&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跨域请求头信息设置，这两个主要是做保护作用，发送唯一标识，对名字做表好似</span></span><br><span class="line">  <span class="attr">xsrfHeaderName</span>: <span class="string">&#x27;X-XSRF-TOKEN&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上传回调</span></span><br><span class="line">  <span class="attr">onUploadProgress</span>: <span class="keyword">function</span> (<span class="params">progressEvent</span>) &#123;</span><br><span class="line">    <span class="comment">// Do whatever you want with the native progress event</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下载回调</span></span><br><span class="line">  <span class="attr">onDownloadProgress</span>: <span class="keyword">function</span> (<span class="params">progressEvent</span>) &#123;</span><br><span class="line">    <span class="comment">// Do whatever you want with the native progress event</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置响应体最大长度，单位为字节</span></span><br><span class="line">  <span class="attr">maxContentLength</span>: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置请求最大长度</span></span><br><span class="line">  <span class="attr">maxBodyLength</span>: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对响应结果做一个设置，也就是认定什么情况下它才属于成功的，属于默认规则</span></span><br><span class="line">  <span class="attr">validateStatus</span>: <span class="keyword">function</span> (<span class="params">status</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// default</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最大跳转次数，一般只能用在node.js</span></span><br><span class="line">  <span class="attr">maxRedirects</span>: <span class="number">21</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跳转前的操作</span></span><br><span class="line">  <span class="attr">beforeRedirect</span>: <span class="function">(<span class="params">options, &#123; headers &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">hostname</span> === <span class="string">&quot;example.com&quot;</span>) &#123;</span><br><span class="line">      options.<span class="property">auth</span> = <span class="string">&quot;user:password&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置socket文件位置，</span></span><br><span class="line">  <span class="attr">socketPath</span>: <span class="literal">null</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// http状态</span></span><br><span class="line">  <span class="attr">httpAgent</span>: <span class="keyword">new</span> http.<span class="title class_">Agent</span>(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">  <span class="attr">httpsAgent</span>: <span class="keyword">new</span> https.<span class="title class_">Agent</span>(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 代理，通过代理可以进行爬虫或者投票这些，就是通过代理池去操作</span></span><br><span class="line">  <span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="attr">protocol</span>: <span class="string">&#x27;https&#x27;</span>,</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">9000</span>,</span><br><span class="line">    <span class="attr">auth</span>: &#123;</span><br><span class="line">      <span class="attr">username</span>: <span class="string">&#x27;mikeymike&#x27;</span>,</span><br><span class="line">      <span class="attr">password</span>: <span class="string">&#x27;rapunz3l&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对ajax请求进行一个取消的操作</span></span><br><span class="line">  <span class="attr">cancelToken</span>: <span class="keyword">new</span> <span class="title class_">CancelToken</span>(<span class="keyword">function</span> (<span class="params">cancel</span>) &#123;</span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// an alternative way to cancel Axios requests using AbortController</span></span><br><span class="line">  <span class="attr">signal</span>: <span class="keyword">new</span> <span class="title class_">AbortController</span>().<span class="property">signal</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `decompress` indicates whether or not the response body should be decompressed</span></span><br><span class="line">  <span class="comment">// automatically. If set to `true` will also remove the &#x27;content-encoding&#x27; header</span></span><br><span class="line">  <span class="comment">// from the responses objects of all decompressed responses</span></span><br><span class="line">  <span class="comment">// - Node only (XHR cannot turn off decompression)</span></span><br><span class="line">  <span class="attr">decompress</span>: <span class="literal">true</span> <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `insecureHTTPParser` boolean.</span></span><br><span class="line">  <span class="comment">// Indicates where to use an insecure HTTP parser that accepts invalid HTTP headers.</span></span><br><span class="line">  <span class="comment">// This may allow interoperability with non-conformant HTTP implementations.</span></span><br><span class="line">  <span class="comment">// Using the insecure parser should be avoided.</span></span><br><span class="line">  <span class="comment">// see options https://nodejs.org/dist/latest-v12.x/docs/api/http.html#http_http_request_url_options_callback</span></span><br><span class="line">  <span class="comment">// see also https://nodejs.org/en/blog/vulnerability/february-2020-security-releases/#strict-http-header-parsing-none</span></span><br><span class="line">  <span class="attr">insecureHTTPParser</span>: <span class="literal">undefined</span> <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// transitional options for backward compatibility that may be removed in the newer versions</span></span><br><span class="line">  <span class="attr">transitional</span>: &#123;</span><br><span class="line">    <span class="comment">// silent JSON parsing mode</span></span><br><span class="line">    <span class="comment">// `true`  - ignore JSON parsing errors and set response.data to null if parsing failed (old behaviour)</span></span><br><span class="line">    <span class="comment">// `false` - throw SyntaxError if JSON parsing failed (Note: responseType must be set to &#x27;json&#x27;)</span></span><br><span class="line">    <span class="attr">silentJSONParsing</span>: <span class="literal">true</span>, <span class="comment">// default value for the current Axios version</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// try to parse the response string as JSON even if `responseType` is not &#x27;json&#x27;</span></span><br><span class="line">    <span class="attr">forcedJSONParsing</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// throw ETIMEDOUT error instead of generic ECONNABORTED on request timeouts</span></span><br><span class="line">    <span class="attr">clarifyTimeoutError</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="comment">// The FormData class to be used to automatically serialize the payload into a FormData object</span></span><br><span class="line">    <span class="title class_">FormData</span>: <span class="variable language_">window</span>?.<span class="property">FormData</span>  <span class="variable language_">global</span>?.<span class="property">FormData</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">formSerializer</span>: &#123;</span><br><span class="line">      <span class="attr">visitor</span>: <span class="function">(<span class="params">value, key, path, helpers</span>)=&gt;</span> &#123;&#125;; <span class="comment">// custom visitor funaction to serrialize form values</span></span><br><span class="line">      <span class="attr">dots</span>: boolean; <span class="comment">// use dots instead of brackets format</span></span><br><span class="line">      <span class="attr">metaTokens</span>: boolean; <span class="comment">// keep special endings like &#123;&#125; in parameter key</span></span><br><span class="line">      <span class="attr">indexes</span>: boolean; <span class="comment">// array indexes format null - no brackets, false - empty brackets, true - brackets with indexes</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-axios-的默认配置"><a href="#2-5-axios-的默认配置" class="headerlink" title="2.5 axios 的默认配置"></a>2.5 axios 的默认配置</h2><p>通过<code>axios.defaults.xxx</code>即可进行配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">defaults</span>.<span class="property">method</span> = <span class="string">&quot;GET&quot;</span>;</span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&quot;http://localhost:3000&quot;</span>;</span><br><span class="line"></span><br><span class="line">btn[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    axios</span><br><span class="line">        .<span class="title function_">request</span>(&#123;</span><br><span class="line">            <span class="attr">url</span>: <span class="string">&quot;/comments&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-6-axios-创建实例对象"><a href="#2-6-axios-创建实例对象" class="headerlink" title="2.6 axios 创建实例对象"></a>2.6 axios 创建实例对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> joke = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&quot;http://route.showapi.com&quot;</span>,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">2000</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">joke.<span class="title function_">get</span>(<span class="string">&quot;/341-2&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="三、拦截器"><a href="#三、拦截器" class="headerlink" title="三、拦截器"></a>三、拦截器</h1><p>包括请求拦截器和响应拦截器 拦截器的主要作用就是在发送或接收的过程中对数据进行处理 比如说请求拦截器就是将数据发送到服务器的过程中进行处理，如果符合要求就进行传送，不符合要求则放弃传送 响应拦截器可以对数据进行处理等操作 等于就是<strong>一道道关卡</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置请求拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求拦截器 成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求拦截器 失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置响应拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;响应拦截器 成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;响应拦截器 失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>通过请求拦截器和响应拦截器可以对请求和返回的数据进行修改</p><h1 id="四、取消-axios-请求"><a href="#四、取消-axios-请求" class="headerlink" title="四、取消 axios 请求"></a>四、取消 axios 请求</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 声明全局变量</span></span><br><span class="line"><span class="keyword">let</span> cancel = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">btn[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cancel !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="title function_">cancel</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000/posts&quot;</span>,</span><br><span class="line">        <span class="comment">// 1.添加配置对象的属性</span></span><br><span class="line">        <span class="attr">cancelToken</span>: <span class="keyword">new</span> axios.<span class="title class_">CancelToken</span>(<span class="keyword">function</span> (<span class="params">c</span>) &#123;</span><br><span class="line">            <span class="comment">// 3.将c的值赋值给cancel</span></span><br><span class="line">            cancel = c;</span><br><span class="line">        &#125;),</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">        cancel = <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">btn[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">cancel</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>取消请求主要是通过<code>cancelToken</code>来进行，通过对一个变量来赋值，在需要调用取消的时候，直接使用<code>cancel()</code>方法来取消请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cancelToken</span>: <span class="keyword">new</span> axios.<span class="title class_">CancelToken</span>(<span class="keyword">function</span> (<span class="params">c</span>) &#123;</span><br><span class="line">            <span class="comment">// 3.将c的值赋值给cancel</span></span><br><span class="line">            cancel = c;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、配置和下载&quot;&gt;&lt;a href=&quot;#一、配置和下载&quot; class=&quot;headerlink&quot; title=&quot;一、配置和下载&quot;&gt;&lt;/a&gt;一、配置和下载&lt;/h1&gt;&lt;h2 id=&quot;1-1-json-server&quot;&gt;&lt;a href=&quot;#1-1-json-server&quot; class=&quot;headerlink&quot; title=&quot;1.1 json-server&quot;&gt;&lt;/a&gt;1.1 json-server&lt;/h2&gt;&lt;p&gt;首先是 json-server 的下载和安装&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在命令行中输入&lt;code&gt;npm install -g json-server&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在需要使用的文件夹下创建文件 db.json&lt;/li&gt;
&lt;li&gt;在 db.json 中置入内容&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>promise详解</title>
    <link href="http://example.com/2022/07/12/promise%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/07/12/promise%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-07-12T04:47:50.000Z</published>
    <updated>2023-03-20T08:32:36.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>promise 是 js 中进行异步编程的<strong>新解决方案</strong> 旧方案是使用单纯的回调函数</p><p>promise 可以使回调函数的方式更加灵活 promise：启动异步任务 &#x3D;&gt; 返回 promise 对象 &#x3D;&gt; 给 promise 对象绑定回调函数（甚至可以在异步任务结束后指定&#x2F;多个）</p><p><strong>promise 支持链式调用，可以解决回调地狱问题</strong></p><span id="more"></span><ol><li>什么是回调地狱？ 回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行的条件</li><li>回调地狱的缺点？ 不便于阅读，不便于异常处理</li><li>解决方案： promise 链式调用</li></ol><h1 id="二、promise-使用"><a href="#二、promise-使用" class="headerlink" title="二、promise 使用"></a>二、promise 使用</h1><h2 id="2-1-promise-基本使用"><a href="#2-1-promise-基本使用" class="headerlink" title="2.1 promise 基本使用"></a>2.1 promise 基本使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise 形式实现</span></span><br><span class="line"><span class="comment">// resolve 和reject都是函数类型的数据</span></span><br><span class="line"><span class="comment">// resolve代表解决时实现的函数</span></span><br><span class="line"><span class="comment">// reject代表拒绝时实现的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// promise 可以传递参数</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> n = <span class="title function_">rand</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">30</span>) &#123;</span><br><span class="line"><span class="title function_">resolve</span>(n); <span class="comment">//将promise对象的状态设置为成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="title function_">reject</span>(n); <span class="comment">//将promise对象的状态设置为失败</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// then函数，前面是resolve的解决方案，后面是reject的解决方案</span></span><br><span class="line">p.<span class="title function_">then</span>(</span><br><span class="line"><span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;congratulation&quot;</span> + value);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;try again&quot;</span> + reason);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>promise 基本部分由两部分组成，第一部分为定义部分： <code>const p = new Promise((resolve, reject) =&gt;&#123;&#125;);</code> 其中包括 resolve 和 reject 两部分，这两部分表示的都是函数。 resolve 表示的是设置为成功时执行的函数； reject 表示的是设置为失败时执行的函数。</p><p>其中 resolve 和 reject 都能够传递参数。</p><p>第二部分为执行部分，也就是定义 resolve 函数和 reject 函数分别代表着什么含义。 第一部分传递的参数传递到第二部分可以分别进行定义，正如上面的 n 传递到 resolve 中代表的是 value；传递到 reject 中代表的是 reason。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="title function_">then</span>(</span><br><span class="line"><span class="function">(<span class="params">value</span>) =&gt;</span> &#123;&#125;, <span class="comment">//第一个回调函数代表的是resolve函数</span></span><br><span class="line"><span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;&#125; <span class="comment">//第二个回调函数代表的是reject函数</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="2-2-promise-的状态改变"><a href="#2-2-promise-的状态改变" class="headerlink" title="2.2 promise 的状态改变"></a>2.2 promise 的状态改变</h2><p>promise 中的属性（promiseState）：</p><ul><li>pending 未决定的</li><li>resolved&#x2F;fullfilled 成功</li><li>rejected 失败 这个状态一个 promise 对象只能改变一次，并且只能够是<code>pending --&gt; resolved</code>，或者是<code>pending --&gt; rejected</code>。 无论变为成功还是失败，都会有一个结果数据 成功的结果数据一般称为 value，失败的结果数据一般称为 reason</li></ul><p>promise 中的另一个属性（promiseResult）保存着异步任务成功或失败的结果</p><p>也就是 resolve 或者是 reject 的值</p><h2 id="2-3-promise-的工作流程"><a href="#2-3-promise-的工作流程" class="headerlink" title="2.3 promise 的工作流程"></a>2.3 promise 的工作流程</h2><p>[<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/01.jpg">]</p><h2 id="2-4-promise-的-API"><a href="#2-4-promise-的-API" class="headerlink" title="2.4 promise 的 API"></a>2.4 promise 的 API</h2><p>promise 的构造函数：promise(executor){}</p><ul><li>executor 函数：执行器<code>(resolve, reject)=&gt;&#123;&#125;</code></li><li>resolve 函数：内部定义成功时调用的函数 value &#x3D;&gt;{}</li><li>reject 函数：内部定义失败时调用的函数 reason &#x3D;&gt;{}</li><li>executor 会在 promise 内部立即<strong>同步调用</strong>，<strong>异步操作</strong>在<strong>执行器</strong>中执行</li></ul><p><code>promise.then(onResolve,onReject)=&gt;&#123;&#125;</code>表示可以指定成功和失败的回调函数 <code>promise.catch(onReject)=&gt;&#123;&#125;</code>其只能表示失败的回调函数</p><p><code>promise.resolve()</code>中如果传入的参数为 非 Promise 类型的对象，则返回的结果为成功 promise 对象 如果传入的参数为 Promise 对象，则参数的结果决定了 resolve 的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(xxx);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1); <span class="comment">//输出的值为xxx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">reject</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2); <span class="comment">//输出的值为error，类型为rejected</span></span><br><span class="line"><span class="comment">// 但是如果promise对象里是resolve(&#x27;ok&#x27;),那么输出的值就是ok，类型为resolved</span></span><br></pre></td></tr></table></figure><p><code>promise.reject()</code>用于传出 reason 信息，也就是不管里面是什么，<strong>输出类型都是 rejected</strong>。</p><p><code>promise.all([])</code>中包含 n 个 promise 的数组，其会返回一个新的 promise，只有所有的 promise 都成功才成功，只要有一个失败了就直接失败</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;oh yeah&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;err&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]); <span class="comment">//result状态为resolved，值为p1,p2,p3的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3, p4]); <span class="comment">//result状态为rejected，值为p4的值，因为他是err</span></span><br></pre></td></tr></table></figure><p><code>promise.race()</code>其也是包含 n 个 promise 的数组，其会返回一个新的 promise。这一堆 promise 数组里谁先改变状态，谁就先输出。 <strong>所以说这是一个赛跑问题，跑的最快的先出来</strong></p><h2 id="2-5-promise-的关键问题"><a href="#2-5-promise-的关键问题" class="headerlink" title="2.5 promise 的关键问题"></a>2.5 promise 的关键问题</h2><h3 id="2-5-1-改变-promise-对象状态的方式"><a href="#2-5-1-改变-promise-对象状态的方式" class="headerlink" title="2.5.1 改变 promise 对象状态的方式"></a>2.5.1 改变 promise 对象状态的方式</h3><ol><li>resolve 函数，<code>resolve(&#39;ok&#39;);</code> pending &#x3D;&gt; resolved</li><li>reject 函数：<code>reject(&#39;error&#39;);</code> pending &#x3D;&gt; rejected</li><li>抛出错误：<code>throw &#39;error&#39;;</code> pending &#x3D;&gt; rejected</li></ol><h3 id="2-5-2-promise-指定多个回调"><a href="#2-5-2-promise-指定多个回调" class="headerlink" title="2.5.2 promise 指定多个回调"></a>2.5.2 promise 指定多个回调</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">alert</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个回调都会进行</span></span><br></pre></td></tr></table></figure><p>为一个 promise 指定多个回调时，当 promise 改变为对应状态是都会调用</p><h3 id="2-5-3-改变-promise-状态和指定回调函数谁先谁后"><a href="#2-5-3-改变-promise-状态和指定回调函数谁先谁后" class="headerlink" title="2.5.3 改变 promise 状态和指定回调函数谁先谁后"></a>2.5.3 改变 promise 状态和指定回调函数谁先谁后</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(</span><br><span class="line"><span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当执行器函数中是一个同步任务时，先改变 resolve 的状态，再执行 then 中的函数 或者执行器函数中有一个延迟时间，但是 then 中延迟时间更长，则也会先改变 resolve 的状态，再执行函数</p><p>当执行器函数中是一个异步任务时，也就是需要等待一段时间的时候，先执行 then 中的函数，再改变状态</p><h3 id="2-5-4-promise-then-中返回的新的-promise-的结果状态由什么决定"><a href="#2-5-4-promise-then-中返回的新的-promise-的结果状态由什么决定" class="headerlink" title="2.5.4 promise.then()中返回的新的 promise 的结果状态由什么决定"></a>2.5.4 promise.then()中返回的新的 promise 的结果状态由什么决定</h3><p><strong>由 then()指定的回调函数执行的结果决定</strong></p><p>如果抛出异常，新 promise 变为 rejected，reason 为抛出的异常 如果返回的是非 promise 的任意值，新 promise 变为 resolved，value 为返回的值 如果返回的是另一个新 promise，此 promise 的结果就会变成新 promise 的结果</p><h3 id="2-5-5-promise-串联多个操作任务"><a href="#2-5-5-promise-串联多个操作任务" class="headerlink" title="2.5.5 promise 串联多个操作任务"></a>2.5.5 promise 串联多个操作任务</h3><p>通过 then 方法可以链式调用多个任务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">//输出success，因为这个里面的没有返回值结果，所以说这个undefined的返回值传到下一个里面输出的就是undefined</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">//输出undefined</span></span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-5-6-promise-异常穿透"><a href="#2-5-6-promise-异常穿透" class="headerlink" title="2.5.6 promise 异常穿透"></a>2.5.6 promise 异常穿透</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;error!&quot;</span>; <span class="comment">//比如说我们这里抛出了一个异常，但是会在最后进行处理</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">233</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">344</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">warn</span>(reason); <span class="comment">//也就是这里来进行异常处理，这就叫做异常穿透</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当使用 promise 的 then 链式调用时，可以在最后指定失败的回调。 前面任何操作出了异常，都会传到最后失败的回调中处理</p><h3 id="2-5-7-中断-promise-链"><a href="#2-5-7-中断-promise-链" class="headerlink" title="2.5.7 中断 promise 链"></a>2.5.7 中断 promise 链</h3><p>在回调函数中返回一个 pending 状态的 promise 对象，就能够中断链式调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);  <span class="comment">//这里是空的。返回pending，所以最后只显示111，后面就被忽略了。</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">233</span>);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h1 id="三、自定义-promise（手写）"><a href="#三、自定义-promise（手写）" class="headerlink" title="三、自定义 promise（手写）"></a>三、自定义 promise（手写）</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line"><span class="comment">// 定时器部分是为了实现回调函数的异步执行。</span></span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line"><span class="comment">// 添加属性</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">PromiseState</span> = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">PromiseResult</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">callbacks</span> = [];</span><br><span class="line"><span class="comment">// 保存实例对象的this值</span></span><br><span class="line"><span class="keyword">const</span> self = <span class="variable language_">this</span>; <span class="comment">//self _this that</span></span><br><span class="line"><span class="comment">// 因为下面function里的this指向的是window对象。</span></span><br><span class="line"><span class="comment">// 所以说需要将这里的this的值保存一下，在下面进行调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">data</span>) &#123;</span><br><span class="line"><span class="comment">// 判断状态</span></span><br><span class="line"><span class="keyword">if</span> (self.<span class="property">PromiseState</span> !== <span class="string">&quot;pending&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 1.修改对象的状态(PromiseState)</span></span><br><span class="line">self.<span class="property">PromiseState</span> = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line"><span class="comment">// 2.设置对象结果值(PromiseResult)</span></span><br><span class="line">self.<span class="property">PromiseResult</span> = data;</span><br><span class="line"><span class="comment">// 调用成功的回调函数</span></span><br><span class="line"><span class="comment">// 这里针对的是单次回调</span></span><br><span class="line"><span class="comment">// if(self.callback.onResolved)&#123;</span></span><br><span class="line"><span class="comment">//     self.callback.onResolved(data);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当多个回调时，需要用for循环遍历</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">item.<span class="title function_">onResolved</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// reject函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">data</span>) &#123;</span><br><span class="line"><span class="comment">// 判断状态</span></span><br><span class="line"><span class="keyword">if</span> (self.<span class="property">PromiseState</span> !== <span class="string">&quot;pending&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 1.修改对象的状态(PromiseState)</span></span><br><span class="line">self.<span class="property">PromiseState</span> = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line"><span class="comment">// 2.设置对象结果值(PromiseResult)</span></span><br><span class="line">self.<span class="property">PromiseResult</span> = data;</span><br><span class="line"><span class="comment">// 调用成功的回调函数</span></span><br><span class="line"><span class="comment">// if(self.callback.onRejected)&#123;</span></span><br><span class="line"><span class="comment">//     self.callback.onRejected(data);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">item.<span class="title function_">onRejected</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 同步调用执行器函数</span></span><br><span class="line"><span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"><span class="title function_">reject</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// then方法封装</span></span><br><span class="line"><span class="title function_">then</span>(<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line"><span class="comment">// 判断回调函数参数</span></span><br><span class="line"><span class="comment">// 这部分主要是解决链式传递出现的问题</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">onRejected = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> reason;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> onResolved !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">onResolved = <span class="function">(<span class="params">value</span>) =&gt;</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为了能够解决回调为promise对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 封装函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callback</span>(<span class="params">type</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 获取回调函数的执行结果</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">type</span>(self.<span class="property">PromiseResult</span>);</span><br><span class="line"><span class="comment">//判断</span></span><br><span class="line"><span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">result.<span class="title function_">then</span>(</span><br><span class="line"><span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(v);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">reject</span>(r);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"><span class="title function_">reject</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">callback</span>(onResolved);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">callback</span>(onRejected);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断pending状态</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line"><span class="comment">// 保存回调函数</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line"><span class="comment">// onResolved: onResolved,</span></span><br><span class="line"><span class="comment">// onRejected: onRejected</span></span><br><span class="line"><span class="attr">onResolved</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">callback</span>(onResolved);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">onRejected</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">callback</span>(onRejected);</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加resolve方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line"><span class="comment">// 返回promise对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">value.<span class="title function_">then</span>(</span><br><span class="line"><span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(v);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">reject</span>(r);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 状态设置为成功</span></span><br><span class="line"><span class="title function_">resolve</span>(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加reject方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">reject</span>(reason);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加all方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">all</span>(<span class="params">promises</span>) &#123;</span><br><span class="line"><span class="comment">// 返回结果为promise对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 声明一个计数变量</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 存放成功结果的数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">promises[i].<span class="title function_">then</span>(</span><br><span class="line"><span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 得知对象的状态是成功</span></span><br><span class="line"><span class="comment">// 当每个promise对象都成功再调用resolve</span></span><br><span class="line">count++;</span><br><span class="line"><span class="comment">// 将当前promise对象成功的结果存放到数组中</span></span><br><span class="line">arr[i] = v;</span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="keyword">if</span> (count === promises.<span class="property">length</span>) &#123;</span><br><span class="line"><span class="title function_">resolve</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">reject</span>(r);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加race方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">race</span>(<span class="params">promises</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">promises[i].<span class="title function_">then</span>(</span><br><span class="line"><span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(v);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">reject</span>(r);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、async-amp-await"><a href="#四、async-amp-await" class="headerlink" title="四、async&amp;await"></a>四、async&amp;await</h1><h2 id="4-1-async"><a href="#4-1-async" class="headerlink" title="4.1 async"></a>4.1 async</h2><ol><li>函数返回值为 promise 对象</li><li>promise 对象的结果由 async 函数执行的返回值决定</li></ol><p>和 then 方法的规则一致</p><ol><li>如果返回的是一个非 promise 类型的数据。返回 fulfilled+值</li><li>如果返回的是一个 promise 类型的数据，根据 promise 类型决定</li><li>如果抛出异常，返回 rejected+reason</li></ol><h2 id="4-2-await"><a href="#4-2-await" class="headerlink" title="4.2 await"></a>4.2 await</h2><ol><li>await 右侧的表达式一般为 promise 对象，但也可以是其他的值</li><li>如果表达式是 promise 对象，await 返回的是 promise 成功的值</li><li>如果表达式是其他的值，直接将此值作为 await 的返回值</li></ol><p><strong>注意事项</strong></p><ol><li>await 必须写在 async 函数中，但 async 函数中可以没有 await</li><li>如果 await 的 promise 失败了，就会抛出异常，需要通过 try…catch 捕获处理</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// resolve(&#x27;ok&#x27;);</span></span><br><span class="line"><span class="title function_">reject</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右侧为promise的情况</span></span><br><span class="line"><span class="comment">// let res = await p;</span></span><br><span class="line"><span class="comment">// 右侧为数据的情况</span></span><br><span class="line"><span class="comment">// let res2 = await 20;</span></span><br><span class="line"><span class="comment">// 如果promise是失败的情况</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">let</span> res3 = <span class="keyword">await</span> p;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>();</span><br></pre></td></tr></table></figure><h2 id="4-3-async-和-await-结合"><a href="#4-3-async-和-await-结合" class="headerlink" title="4.3 async 和 await 结合"></a>4.3 async 和 await 结合</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;发送ajax请求&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button id=&quot;btn&quot;&gt;点击获取段子&lt;/button&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // axios</span><br><span class="line">        function sendAjax(url)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let btn = document.querySelector(&#x27;btn&#x27;);</span><br><span class="line"></span><br><span class="line">        btn.addEventListener(&#x27;click&#x27;,async function()&#123;</span><br><span class="line">            let joke = await sendAjax(&#x27;https://api.apiopen.top/getJoke&#x27;);</span><br><span class="line">            console.log(joke);</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;p&gt;promise 是 js 中进行异步编程的&lt;strong&gt;新解决方案&lt;/strong&gt; 旧方案是使用单纯的回调函数&lt;/p&gt;
&lt;p&gt;promise 可以使回调函数的方式更加灵活 promise：启动异步任务 &amp;#x3D;&amp;gt; 返回 promise 对象 &amp;#x3D;&amp;gt; 给 promise 对象绑定回调函数（甚至可以在异步任务结束后指定&amp;#x2F;多个）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;promise 支持链式调用，可以解决回调地狱问题&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>AJAX详解</title>
    <link href="http://example.com/2022/07/07/Ajax%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/07/07/Ajax%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-07-07T01:49:01.000Z</published>
    <updated>2023-03-20T08:32:32.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-1-AJAX简介"><a href="#1-1-AJAX简介" class="headerlink" title="1.1 AJAX简介"></a>1.1 AJAX简介</h2><p>Ajax(Asynchronous JavaScript And XML)，就是异步的JS和XML</p><p>通过Ajax可以在浏览器中向服务器发送异步请求</p><p><strong>其最大的优势就是可以不刷新网页从而获取数据</strong></p><p>Ajax不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式</p><span id="more"></span><h2 id="1-2-XML简介"><a href="#1-2-XML简介" class="headerlink" title="1.2 XML简介"></a>1.2 XML简介</h2><p>XML是一种可扩展的标记语言</p><p>XML被设计用来传输和存储数据</p><p>XML和HTML类似，不同的是，html中都是预定义标签，而xml中没有预定义标签，都是自定义标签。</p><p><strong>但是现在已经被JSON取代了</strong></p><h2 id="1-3-AJAX特点"><a href="#1-3-AJAX特点" class="headerlink" title="1.3 AJAX特点"></a>1.3 AJAX特点</h2><h3 id="1-3-1-AJAX的优点"><a href="#1-3-1-AJAX的优点" class="headerlink" title="1.3.1 AJAX的优点"></a>1.3.1 AJAX的优点</h3><ol><li>可以无需刷新页面而与服务端进行通信</li><li>允许你根据用户事件来更新部分页面问题</li></ol><h3 id="1-3-2-AJAX的缺点"><a href="#1-3-2-AJAX的缺点" class="headerlink" title="1.3.2 AJAX的缺点"></a>1.3.2 AJAX的缺点</h3><ol><li>没有浏览历史，不能回退</li><li>存在跨域问题（同源）</li><li>SEO不友好，也就是搜索引擎优化，因为AJAX不能够被爬虫，网页源代码中找不到它，它是从服务器端的请求来的</li></ol><h2 id="1-4-http协议"><a href="#1-4-http协议" class="headerlink" title="1.4 http协议"></a>1.4 http协议</h2><p>http（hypertext transport protocol），超文本传输协议，协议详细规定了浏览器和万维网服务器之间的互相通信规则</p><h3 id="1-4-1-请求报文"><a href="#1-4-1-请求报文" class="headerlink" title="1.4.1 请求报文"></a>1.4.1 请求报文</h3><p>重点是格式与参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">行      POST /s?ie=ytf-8    HTTP/1.1</span><br><span class="line">头      Host: guigu.com</span><br><span class="line">        Cookie: name=guigu</span><br><span class="line">        Content-Type: application/x-www-form-urlencoded</span><br><span class="line">        User-Agent: chrome 83</span><br><span class="line">空行</span><br><span class="line">体      username=admin&amp;password=admin</span><br></pre></td></tr></table></figure><h3 id="1-4-2-响应报文"><a href="#1-4-2-响应报文" class="headerlink" title="1.4.2 响应报文"></a>1.4.2 响应报文</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">行      HTTP/1.1 200 OK</span><br><span class="line">头      Content-Type:text/html;charset=utff-8</span><br><span class="line">        Content-length:2048</span><br><span class="line">        Content-encoding:gzip</span><br><span class="line">空行</span><br><span class="line">体      html结构</span><br></pre></td></tr></table></figure><h3 id="1-4-3-查看请求报文和响应报文"><a href="#1-4-3-查看请求报文和响应报文" class="headerlink" title="1.4.3 查看请求报文和响应报文"></a>1.4.3 查看请求报文和响应报文</h3><p>f12 –&gt; network –&gt; Headers Request Headers：请求头 Response Headers:响应头 Query String Parameters:查询字符串参数，对参数进行可视化，具体的可视化区域是utf-8区域的参数，也就是<strong>请求行的内容</strong></p><p>f12 –&gt; network –&gt; Response:看具体的响应体</p><p>对于post请求，会通过Form Data来将用户名和密码传送给服务器</p><h3 id="1-4-4-get-x2F-post"><a href="#1-4-4-get-x2F-post" class="headerlink" title="1.4.4 get&#x2F;post"></a>1.4.4 get&#x2F;post</h3><p>GET一般用于获取&#x2F;查询资源信息，而POST一般用于更新资源信息.</p><h4 id="1-4-4-1-GET"><a href="#1-4-4-1-GET" class="headerlink" title="1.4.4.1 GET"></a>1.4.4.1 GET</h4><p>当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是GET方式。 GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。</p><p>使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号(“?”)代表URL的结尾与请求参数的开始，传递参数长度受限制。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例如，/index.jsp?id=100&amp;op=bind,这样通过GET方式传递的参数直接表示在地址中</span><br><span class="line"></span><br><span class="line">以用google搜索domety为例，Request报文如下：</span><br><span class="line"></span><br><span class="line">GET /search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq= HTTP/1.1</span><br><span class="line">Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint,</span><br><span class="line">application/msword, application/x-silverlight, application/x-shockwave-flash, */*</span><br><span class="line">Referer: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.google.cn/&quot;</span>&gt;</span>http://www.google.cn/<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">Accept-Language: zh-cn</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)</span><br><span class="line">Host: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.google.cn&quot;</span>&gt;</span>www.google.cn<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-FxlRugatx63JLv7CWMD6UB_O_r</span><br></pre></td></tr></table></figure><p>可以看到，GET方式的请求一般不包含”请求内容”部分，请求数据以地址的形式表现在请求行。地址链接如下： <code>&lt;a href=&quot;http://www.google.cn/search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq=&quot;&gt;http://www.google.cn/search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq=&lt;/a&gt;</code></p><p>地址中”?”之后的部分就是<strong>通过GET发送的请求数据</strong>，在地址栏中可以看到，各个数据之间用”&amp;”符号隔开。 <strong>很显然，这种方式不适合传送私密数据。</strong> 另外，由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别1024个字符，所以如果需要传送大量数据的时候，也不适合使用GET方式。</p><h4 id="1-4-4-2-POST"><a href="#1-4-4-2-POST" class="headerlink" title="1.4.4.2 POST"></a>1.4.4.2 POST</h4><p>对于上面提到的不适合使用GET方式的情况，可以考虑使用POST方式，因为使用POST方法可以允许客户端给服务器提供信息较多。POST方法将请求参数封装在HTTP请求数据中，以名称&#x2F;值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。还以上面的搜索domety为例，如果使用POST方式的话，格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /search HTTP/1.1 </span><br><span class="line">Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, </span><br><span class="line">application/msword, application/x-silverlight, application/x-shockwave-flash, */* </span><br><span class="line">Referer: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.google.cn/&quot;</span>&gt;</span>http://www.google.cn/<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line">Accept-Language: zh-cn </span><br><span class="line">Accept-Encoding: gzip, deflate </span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld) </span><br><span class="line">Host: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.google.cn&quot;</span>&gt;</span>www.google.cn<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line">Connection: Keep-Alive </span><br><span class="line">Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-FxlRugatx63JLv7CWMD6UB_O_r</span><br><span class="line"></span><br><span class="line">hl=zh-CN&amp;source=hp&amp;q=domety</span><br></pre></td></tr></table></figure><p>可以看到，POST方式请求行中不包含数据字符串，这些数据保存在”请求内容”部分，各数据之间也是使用”&amp;”符号隔开。 POST方式大多用于页面的表单中。因为POST也能完成GET的功能，因此多数人在设计表单的时候一律都使用POST方式，其实这是一个误区。 GET方式也有自己的特点和优势，我们应该根据不同的情况来选择是使用GET还是使用POST。</p><h4 id="1-4-4-3-HEAD"><a href="#1-4-4-3-HEAD" class="headerlink" title="1.4.4.3 HEAD"></a>1.4.4.3 HEAD</h4><p>HEAD就像GET，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。</p><h4 id="1-4-4-4-get和post的区别"><a href="#1-4-4-4-get和post的区别" class="headerlink" title="1.4.4.4 get和post的区别"></a>1.4.4.4 get和post的区别</h4><p>我们看看GET和POST的区别</p><ol><li><p>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name&#x3D;test1&amp;id&#x3D;123456. POST方法是把提交的数据放在HTTP包的Body中.</p></li><li><p>GET提交的数据大小有限制(因为浏览器对URL的长度有限制)，而POST方法提交的数据没有限制.</p></li><li><p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p></li><li><p>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p></li></ol><p><strong>HTTP请求数据</strong> [<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/request.jpg">] <strong>HTTP响应数据</strong> [<img src="https://blogwh.oss-cn-beijing.aliyuncs.com/img/response.png">]</p><h1 id="二-AJAX的使用"><a href="#二-AJAX的使用" class="headerlink" title="二 AJAX的使用"></a>二 AJAX的使用</h1><h2 id="2-1-get请求"><a href="#2-1-get请求" class="headerlink" title="2.1 get请求"></a>2.1 get请求</h2><ol><li><p>创建对象<br>这里用xhr的原因就是使用ajax一般都要通过xhr来，所以说xhr代表的就是ajax<br><code>const xhr = new XMLHttpRequest();</code></p></li><li><p>初始化，设置请求方法和url<br><code>xhr.open(&quot;GET&quot;, &quot;http://127.0.0.1:8000/server&quot;);</code><br>请求方法包括GET&#x2F;POST&#x2F;DELETE等<br>对于url的设置是以?分割，用&amp;表示不同参数。 <code>xhr.open(&quot;GET&quot;, &quot;http://127.0.0.1:8000/server?a=100&amp;b=200&amp;c=300&quot;);</code></p></li><li><p>发送 <code>xhr.send();</code> 4.事件绑定 处理服务端返回的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// on表示当。。。时候</span></span><br><span class="line"><span class="comment">// readystate是xhr对象中的属性。表示状态0,1,2,3,4</span></span><br><span class="line"><span class="comment">// 0表示被初始化，1代表open方法加装完毕</span></span><br><span class="line"><span class="comment">// 2代表send方法加装完毕，3表示服务端返回的部分结果，4表示服务端返回的所有结果</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 判断(服务端返回了所有的结果)</span></span><br><span class="line">    <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="comment">// 判断响应状态码 200、404、403、401、500等</span></span><br><span class="line">        <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt;= <span class="number">300</span>)&#123;</span><br><span class="line">            <span class="comment">// 处理结果 行 头 空行 体</span></span><br><span class="line">            <span class="comment">// 响应</span></span><br><span class="line">            <span class="comment">// console.log(xhr.status);//状态码</span></span><br><span class="line">            <span class="comment">// console.log(xhr.statusText);//状态字符串</span></span><br><span class="line">            <span class="comment">// console.log(xhr.getAllResponseHeaders());//所有响应头</span></span><br><span class="line">            <span class="comment">// console.log(xhr.response);//响应体</span></span><br><span class="line">            result.<span class="property">innerHTML</span> = xhr.<span class="property">response</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-2-post请求"><a href="#2-2-post请求" class="headerlink" title="2.2 post请求"></a>2.2 post请求</h2><p>post请求中主要就是请求体的位置不一样 在get方法中，数据是通过url传输的，这样就比较不安全 但是在post方法中，通过<code>send()</code>方法传输，数据的传输更安全可靠</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>AJAX POST 请求<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#result</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: solid <span class="number">1px</span> <span class="number">#90b</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取元素</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> result = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;result&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 绑定事件</span></span></span><br><span class="line"><span class="language-javascript">        result.<span class="title function_">addEventListener</span>(<span class="string">&quot;mouseover&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 1.创建对象</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 2.初始化</span></span></span><br><span class="line"><span class="language-javascript">            xhr.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&#x27;http://127.0.0.1:8000/server&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 3.发送</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// xhr.send(&#x27;a=100&amp;b=200&amp;c=300&#x27;);</span></span></span><br><span class="line"><span class="language-javascript">            xhr.<span class="title function_">send</span>(<span class="string">&#x27;a:100&amp;b:200&amp;c:300&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 4.事件绑定</span></span></span><br><span class="line"><span class="language-javascript">            xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;=<span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span>&lt;= <span class="number">300</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                        result.<span class="property">innerHTML</span> = xhr.<span class="property">response</span>;</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-3-express框架使用"><a href="#2-3-express框架使用" class="headerlink" title="2.3 express框架使用"></a>2.3 express框架使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.创建路由规则</span></span><br><span class="line"><span class="comment">// request是对请求报文的封装</span></span><br><span class="line"><span class="comment">// response是对响应报文的封装</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 设置响应头,设置允许跨域</span></span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="comment">// 设置响应体</span></span><br><span class="line">    response.<span class="title function_">send</span>(<span class="string">&quot;hello ajax&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 设置响应头,设置允许跨域</span></span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="comment">// 设置响应体</span></span><br><span class="line">    response.<span class="title function_">send</span>(<span class="string">&quot;hello ajax post&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.监听端口启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务已经启动，8000端口监听中......&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2-4-json请求"><a href="#2-4-json请求" class="headerlink" title="2.4 json请求"></a>2.4 json请求</h2><p>json请求和其他的区别不是很大，其主要改变就是在server端要想要对数据进行响应，需要对数据进行转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/json-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 设置响应头,设置允许跨域</span></span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="comment">// 响应一个数据</span></span><br><span class="line">    <span class="keyword">const</span> data = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;wh&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 对对象进行字符串转换</span></span><br><span class="line">    <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">    <span class="comment">// 设置响应体</span></span><br><span class="line">    response.<span class="title function_">send</span>(str);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>之后在前端，可以通过两种方式来进行数据的显示：</p><ol><li><p>手动对数据进行转化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">response</span>);</span><br><span class="line">result.<span class="property">innerHTML</span> = data.<span class="property">name</span>;</span><br></pre></td></tr></table></figure><p>2.自动对数据进行转化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">// 设置响应体的类型</span></span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&#x27;json&#x27;</span>;</span><br><span class="line"><span class="comment">// 之后在事件绑定中，就可以直接进行显示</span></span><br><span class="line">result.<span class="property">innerHTML</span> = xhr.<span class="property">response</span>.<span class="property">name</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-5-神奇的IE"><a href="#2-5-神奇的IE" class="headerlink" title="2.5 神奇的IE"></a>2.5 神奇的IE</h2><p>IE浏览器在使用ajax过程中会出现缓存问题，当然ie现在已经die了。 但是还是得提一下 其实结果办法也比较简单，就是在前端的初始化阶段设置一个参数时间 <code>xhr.open(&quot;GET&quot;, &#39;https://127.0.0.1:8000/ie?t=&#39;Date.now());</code></p><h2 id="2-6-请求超时与网络异常"><a href="#2-6-请求超时与网络异常" class="headerlink" title="2.6 请求超时与网络异常"></a>2.6 请求超时与网络异常</h2><p>在<code>const xhr = new XMLHttpRequest();</code>和<code>xhr.open(&#39;GET&#39;, &#39;http://127.0.0.1:8000/delay&#39;);</code>之间添加内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置超时取消</span></span><br><span class="line">xhr.<span class="property">timeout</span> = <span class="number">2000</span>;</span><br><span class="line">xhr.<span class="property">ontimeout</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;net error,please try again later&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;your net maybe have some problems&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-7-请求取消的问题"><a href="#2-7-请求取消的问题" class="headerlink" title="2.7 请求取消的问题"></a>2.7 请求取消的问题</h2><p>取消请求可以使用<code>abort()</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="literal">null</span>;</span><br><span class="line">btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    x = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    x.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;http://127.0.0.1:8000&#x27;</span>);</span><br><span class="line">    x.<span class="title function_">send</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    x.<span class="title function_">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过这种方法就可以当点击一个按钮发送请求时，点击另一个按钮就可以取消这个请求</span></span><br></pre></td></tr></table></figure><h2 id="2-8-请求重复的问题"><a href="#2-8-请求重复的问题" class="headerlink" title="2.8 请求重复的问题"></a>2.8 请求重复的问题</h2><p>请求重复问题的核心就是创建一个标识变量，如果这个标识变量为true，则证明请求过程还未结束，不能够接受新的请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;button&quot;</span>)[<span class="number">0</span>]; </span><br><span class="line">        <span class="keyword">let</span> x = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 创建标识变量</span></span><br><span class="line">        <span class="keyword">let</span> isSending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isSending) x.<span class="title function_">abort</span>();</span><br><span class="line">            x = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">            isSending = <span class="literal">true</span>;</span><br><span class="line">            x.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;http://127.0.0.1:8000/delay&#x27;</span>);</span><br><span class="line">            x.<span class="title function_">send</span>();</span><br><span class="line">            x.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">                    <span class="comment">// 修改标识变量</span></span><br><span class="line">                    isSending = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="三、同源策略"><a href="#三、同源策略" class="headerlink" title="三、同源策略"></a>三、同源策略</h1><p>同源策略是一种浏览器的安全策略</p><p>同源：协议、域名、端口号必须完全相同</p><p>违背同源策略就是跨域</p><h2 id="3-1-JSONP"><a href="#3-1-JSONP" class="headerlink" title="3.1 JSONP"></a>3.1 JSONP</h2><p>JSONP是一种非官方的跨域解决方案，只支持GET请求 其利用script标签的跨域能力来发送请求</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params">data</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> result = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            result.<span class="property">innerHTML</span> = data.<span class="property">name</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://127.0.0.1:8000/jsonp-server&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从上面的代码中可以看出，script标签可以通过src链接来实现跨域通信，但是其服务器端回传的必须是一段script代码 比如说想要回传一个参数，可以把参数的显示函数等放在前端，然后服务器端通过调用这个函数就可以啦。 因为其实回传过来的是一段script代码，所以说前端会执行这些前端代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/jsonp-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 响应一个页面</span></span><br><span class="line">    <span class="comment">// response.send(&#x27;console.log(&quot;hello jsonp server&quot;)&#x27;);</span></span><br><span class="line">    <span class="keyword">const</span> data = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;wh&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="string">&#x27;18&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">    response.<span class="title function_">send</span>(<span class="string">`handle(<span class="subst">$&#123;str&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然想要回传参数，需要先将参数转换为json</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建script 标签</span></span><br><span class="line"><span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line"><span class="comment">// 2.设置标签的src属性</span></span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;http://127.0.0.1:8000/check-server&#x27;</span>;</span><br><span class="line"><span class="comment">// 3.将script插入到文档中</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure><p>在正常使用过程中，需要创建script标签，并将其置入src，之后再将script标签插入到文档中使用</p><h2 id="3-2-CORS"><a href="#3-2-CORS" class="headerlink" title="3.2 CORS"></a>3.2 CORS</h2><p>cors(cross-origin resource sharing)，跨域资源共享 是官方的跨域解决方案。它的特点是不需要在客户端做任何特殊的操作。 完全在服务器中进行处理。并且支持get和post请求。 跨域资源共享标准新增了一组HTTP首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源</p><p><strong>CORS通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应后就会对响应放行</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置响应头</span></span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>); <span class="comment">//这个就代表可以跨域运行，并且对所有网页都可以进行</span></span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://example.com&#x27;</span>); <span class="comment">//表示对某个网页进行跨域</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般在开发时会加这些东西</span></span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Method&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br></pre></td></tr></table></figure><p>具体的标准和响应头可以看<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">CORS</a></p><h1 id="四、使用ajax"><a href="#四、使用ajax" class="headerlink" title="四、使用ajax"></a>四、使用ajax</h1><p>本文中使用的主要为express框架，基于node.js和npm、nodemon包使用</p><p>开启服务端的操作为：  </p><p><code>nodemon server.js</code> ——————这个操作能够动态更新服务端代码  </p><p><code>node server.js</code> ——————这个操作每次更新服务端代码都需要重启服务  </p><p>nodemon的下载操作为： <code>npm install -g nodemon</code></p><p><strong>因为新版的node.js中内置了npm，所以不用再下载npm包了</strong></p><p>npm是node.js的一个包管理工具</p><p>查询npm是否下载完成的方式为：<code>npm -v</code> 查询node.js是否下载成功的方式为：<code>node -v</code></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;h2 id=&quot;1-1-AJAX简介&quot;&gt;&lt;a href=&quot;#1-1-AJAX简介&quot; class=&quot;headerlink&quot; title=&quot;1.1 AJAX简介&quot;&gt;&lt;/a&gt;1.1 AJAX简介&lt;/h2&gt;&lt;p&gt;Ajax(Asynchronous JavaScript And XML)，就是异步的JS和XML&lt;/p&gt;
&lt;p&gt;通过Ajax可以在浏览器中向服务器发送异步请求&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其最大的优势就是可以不刷新网页从而获取数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ajax不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式&lt;/p&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>网页的生命周期和cookie</title>
    <link href="http://example.com/2022/07/03/%E7%BD%91%E9%A1%B5%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8Ccookie/"/>
    <id>http://example.com/2022/07/03/%E7%BD%91%E9%A1%B5%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8Ccookie/</id>
    <published>2022-07-03T15:15:33.000Z</published>
    <updated>2023-03-20T08:32:39.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、页面的生命周期"><a href="#一、页面的生命周期" class="headerlink" title="一、页面的生命周期"></a>一、页面的生命周期</h1><p>HTML 页面的生命周期包含三个重要事件：</p><ul><li>DOMContentLoaded —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像<code>&lt;img&gt;</code>和样式表之类的外部资源可能尚未加载完成。</li><li>load —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。</li><li>beforeunload&#x2F;unload —— 当用户正在离开页面时。</li></ul><p>每个事件都是有用的：</p><ul><li>DOMContentLoaded 事件 —— DOM 已经就绪，因此处理程序可以查找 DOM 节点，并初始化接口。</li><li>load 事件 —— 外部资源已加载完成，样式已被应用，图片大小也已知了。</li><li>beforeunload 事件 —— 用户正在离开：我们可以检查用户是否保存了更改，并询问他是否真的要离开。</li><li>unload 事件 —— 用户几乎已经离开了，但是我们仍然可以启动一些操作，例如发送统计数据。</li></ul><h2 id="1-1-DOMContentLoaded"><a href="#1-1-DOMContentLoaded" class="headerlink" title="1.1 DOMContentLoaded"></a>1.1 DOMContentLoaded</h2><p><code>DOMContentLoaded</code>事件发生在<code>document</code>对象上。</p><p>我们必须使用<code>addEventListener</code>来捕获它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, ready);</span><br><span class="line"><span class="comment">// 不是 &quot;document.onDOMContentLoaded = ...&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">ready</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&#x27;DOM is ready&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 图片目前尚未加载完成（除非已经被缓存），所以图片的大小为 0x0</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">`Image size: <span class="subst">$&#123;img.offsetWidth&#125;</span>x<span class="subst">$&#123;img.offsetHeight&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, ready);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://en.js.cx/clipart/train.gif?speed=1&amp;cache=0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为DOMContentLoaded会在文档加载完成后触发，所以它可以查看所有元素，包括<code>&lt;img&gt;</code>等元素，但是不会等待图片加载，所以图片大小是0。</p><p>当浏览器处理一个 HTML 文档，并在文档中遇到<code>&lt;script&gt;</code>标签时，就会在继续构建 DOM 之前运行它。这是一种防范措施，因为脚本可能想要修改 DOM，甚至对其执行 <code>document.write</code>操作，所以<code>DOMContentLoaded</code>必须等待脚本执行结束。</p><p>此规则有两个例外：</p><ol><li>具有<code>async</code>特性（attribute）的脚本不会阻塞<code>DOMContentLoaded</code>，稍后我们会讲到。</li><li>使用<code>document.createElement(&#39;script&#39;)</code>动态生成并添加到网页的脚本也不会阻塞<code>DOMContentLoaded</code>。</li></ol><p><strong>外部样式表不会影响DOM，因此<code>DOMContentLoaded</code>不会等待它们。</strong></p><p>但这里有一个陷阱。如果在样式后面有一个脚本，那么该脚本必须等待样式表加载完成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 在样式表加载完成之前，脚本都不会执行</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(<span class="title function_">getComputedStyle</span>(<span class="variable language_">document</span>.<span class="property">body</span>).<span class="property">marginTop</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>原因是，脚本可能想要获取元素的坐标和其他与样式相关的属性，如上例所示。因此，它必须等待样式加载完成。</p><p><strong>当<code>DOMContentLoaded</code>等待脚本时，它现在也在等待脚本前面的样式。所以说虽然外部样式表不会影响DOM，但是如果外部样式表后存在script脚本， <code>DOMContentLoaded</code>也会等待样式表加载完成</strong></p><h2 id="1-2-浏览器的自动填充"><a href="#1-2-浏览器的自动填充" class="headerlink" title="1.2 浏览器的自动填充"></a>1.2 浏览器的自动填充</h2><p>Firefox，Chrome 和 Opera 都会在<code>DOMContentLoaded</code>中自动填充表单。</p><p>例如，如果页面有一个带有登录名和密码的表单，并且浏览器记住了这些值，那么在 <code>DOMContentLoaded</code>上，浏览器会尝试自动填充它们（如果得到了用户允许）。</p><p>因此，如果<code>DOMContentLoaded</code>被需要加载很长时间的脚本延迟触发，那么自动填充也会等待。你可能在某些网站上看到过（如果你使用浏览器自动填充）—— 登录名&#x2F;密码字段不会立即自动填充，而是在页面被完全加载前会延迟填充。这实际上是 <code>DOMContentLoaded</code>事件之前的延迟。</p><h2 id="1-3-window-onload"><a href="#1-3-window-onload" class="headerlink" title="1.3 window.onload"></a>1.3 window.onload</h2><p>当<strong>整个页面，包括样式、图片和其他资源被加载完成时</strong>，会触发window对象上的<code>load</code>事件。可以通过<code>onload</code>属性获取此事件。</p><p>下面的这个示例正确显示了图片大小，因为<code>window.onload</code>会等待所有图片加载完毕：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 也可以用 window.addEventListener(&#x27;load&#x27;, (event) =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&#x27;Page loaded&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 此时图片已经加载完成</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">`Image size: <span class="subst">$&#123;img.offsetWidth&#125;</span>x<span class="subst">$&#123;img.offsetHeight&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://en.js.cx/clipart/train.gif?speed=1&amp;cache=0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-3-window-onunload"><a href="#1-3-window-onunload" class="headerlink" title="1.3 window.onunload"></a>1.3 window.onunload</h2><p>当访问者离开页面时，window对象上的<code>unload</code>事件就会被触发。我们可以在那里做一些不涉及延迟的操作，例如关闭相关的弹出窗口。 有一个值得注意的特殊情况是发送分析数据。 假设我们收集有关页面使用情况的数据：鼠标点击，滚动，被查看的页面区域等。 自然地，当用户要离开的时候，我们希望通过<code>unload</code>事件将数据保存到我们的服务器上。 有一个特殊的<code>navigator.sendBeacon(url, data)</code>方法可以满足这种需求，<a href="https://w3c.github.io/beacon/">详见规范</a>。 它在后台发送数据，转换到另外一个页面不会有延迟：浏览器离开页面，但仍然在执行<code>sendBeacon</code>。 使用方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> analyticsData = &#123; <span class="comment">/* 带有收集的数据的对象 */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;unload&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  navigator.<span class="title function_">sendBeacon</span>(<span class="string">&quot;/analytics&quot;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(analyticsData));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>请求以 POST 方式发送。</li><li>我们不仅能发送字符串，还能发送表单以及其他格式的数据，但通常它是一个字符串化的对象。</li><li>数据大小限制在 64kb。</li></ul><p>当<code>sendBeacon</code>请求完成时，浏览器可能已经离开了文档，所以就无法获取服务器响应（对于分析数据来说通常为空）。 还有一个<code>keep-alive</code>标志，该标志用于在<code>fetch</code>方法中为通用的网络请求执行此类“离开页面后”的请求。 如果我们要取消跳转到另一页面的操作，在这里做不到。但是我们可以使用另一个事件 ——<code>onbeforeunload</code>。</p><h2 id="1-4-window-onbeforeunload"><a href="#1-4-window-onbeforeunload" class="headerlink" title="1.4 window.onbeforeunload"></a>1.4 window.onbeforeunload</h2><p>如果访问者触发了离开页面的导航（navigation）或试图关闭窗口，<code>beforeunload</code>处理程序将要求进行更多确认。 如果我们要取消事件，浏览器会询问用户是否确定。 你可以通过运行下面这段代码，然后重新加载页面来进行尝试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onbeforeunload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为有些站长通过显示误导性和恶意信息滥用了此事件处理程序。所以，目前一些旧的浏览器可能仍将其显示为消息，但除此之外 —— 无法自定义显示给用户的消息。</p><p><code>event.preventDefault()</code>在<code>beforeunload</code>处理程序中不起作用 这听起来可能很奇怪，但大多数浏览器都会忽略<code>event.preventDefault()</code>。 以下代码可能不起作用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;beforeunload&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 不起作用，所以这个事件处理程序没做任何事儿</span></span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>相反，在这样的处理程序中，应该将<code>event.returnValue</code>设置为一个字符串，以获得类似于上面代码的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;beforeunload&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 起作用，与在 window.onbeforeunload 中 return 值的效果是一样的</span></span><br><span class="line">  event.<span class="property">returnValue</span> = <span class="string">&quot;有未保存的值。确认要离开吗？&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="1-5-readyState"><a href="#1-5-readyState" class="headerlink" title="1.5 readyState"></a>1.5 readyState</h2><p>如果我们在文档加载完成之后设置<code>DOMContentLoaded</code>事件处理程序，会发生什么？ 很自然地，它永远不会运行。 在某些情况下，我们不确定文档是否已经准备就绪。我们希望我们的函数在 DOM 加载完成时执行，无论现在还是以后。</p><p><code>document.readyState</code>属性可以为我们提供当前加载状态的信息。</p><p>它有 3 个可能值：</p><ul><li><code>loading</code> —— 文档正在被加载。</li><li><code>interactive</code> —— 文档被全部读取。</li><li><code>complete</code> —— 文档被全部读取，并且所有资源（例如图片等）都已加载完成。</li></ul><p>所以，我们可以检查<code>document.readyState</code>并设置一个处理程序，或在代码准备就绪时立即执行它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">work</span>(<span class="params"></span>) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">readyState</span> == <span class="string">&#x27;loading&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// 仍在加载，等待事件</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, work);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// DOM 已就绪！</span></span><br><span class="line">  <span class="title function_">work</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个<code>readystatechange</code>事件，会在状态发生改变时触发，因此我们可以打印所有这些状态，就像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前状态</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">readyState</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态改变时打印它</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;readystatechange&#x27;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">readyState</span>));</span><br></pre></td></tr></table></figure><p><code>readystatechange</code>事件是跟踪文档加载状态的另一种机制，它很早就存在了。现在则很少被使用。</p><p>在<code>DOMContentLoaded</code>之前，<code>document.readyState</code>会立即变成<code>interactive</code>。它们俩的意义实际上是相同的。 当所有资源（iframe 和 img）都加载完成后，<code>document.readyState</code>变成 complete。这里我们可以发现，它与<code>img.onload</code>（img 是最后一个资源）和 <code>window.onload</code>几乎同时发生。转换到 complete 状态的意义与<code>window.onload</code>相同。区别在于<code>window.onload</code>始终在所有其他 load 处理程序之后运行。</p><h1 id="二、脚本：async，defer"><a href="#二、脚本：async，defer" class="headerlink" title="二、脚本：async，defer"></a>二、脚本：async，defer</h1><p>现代的网站中，脚本往往比 HTML 更“重”：它们的大小通常更大，处理时间也更长。</p><p>当浏览器加载 HTML 时遇到<code>&lt;script&gt;...&lt;/script&gt;</code>标签，浏览器就不能继续构建 DOM。它必须立刻执行此脚本。对于外部脚本<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code>也是一样的：浏览器必须等脚本下载完，并执行结束，之后才能继续处理剩余的页面。</p><p>这会导致两个重要的问题：</p><ol><li>脚本不能访问到位于它们下面的 DOM 元素，因此，脚本无法给它们添加处理程序等。</li><li>如果页面顶部有一个笨重的脚本，它会“阻塞页面”。在该脚本下载并执行结束前，用户都不能看到页面内容。</li></ol><p>这里有一些解决办法。例如，我们可以把脚本放在页面底部。此时，它可以访问到它上面的元素，并且不会阻塞页面显示内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  ...all content is above the script...</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://javascript.info/article/script-async-defer/long.js?speed=1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是这种解决方案远非完美。例如，浏览器只有在下载了完整的 HTML 文档之后才会注意到该脚本（并且可以开始下载它）。对于长的 HTML 文档来说，这样可能会造成明显的延迟。</p><p>这对于使用高速连接的人来说，这不值一提，他们不会感受到这种延迟。但是这个世界上仍然有很多地区的人们所使用的网络速度很慢，并且使用的是远非完美的移动互联网连接。</p><p>幸运的是，这里有两个<code>&lt;script&gt;</code>特性（attribute）可以为我们解决这个问题：defer 和 async。</p><h2 id="2-1-defer"><a href="#2-1-defer" class="headerlink" title="2.1 defer"></a>2.1 defer</h2><p><code>defer</code>特性告诉浏览器不要等待脚本。相反，浏览器将继续处理 HTML，构建 DOM。脚本会“在后台”下载，然后等 DOM 构建完成后，脚本才会执行。</p><p>这是与上面那个相同的示例，但是带有 defer 特性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>...content before script...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;https://javascript.info/article/script-async-defer/long.js?speed=1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 立即可见 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>...content after script...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以说：</p><ul><li>具有<code>defer</code>特性的脚本不会阻塞页面。</li><li>具有<code>defer</code>特性的脚本总是要等到 DOM 解析完毕，但在<code>DOMContentLoaded</code>事件之前执行。</li></ul><p>因为具有<code>defer</code>特性的脚本不会被等待，但是<code>DOMContentLoaded</code>事件必须等到脚本结束才能进行。</p><p><strong>具有<code>defer</code>特性的脚本保持其相对顺序，就像常规脚本一样。</strong></p><p>浏览器扫描页面寻找脚本，然后并行下载它们，以提高性能。</p><p>如果有两个脚本，一个大一个小，大脚本在前，小脚本在后。但是如果小脚本先被下载完成，但是因为执行的相对顺序，它会排在大脚本后面被执行。</p><p>当我们需要先加载 JavaScript 库，然后再加载依赖于它的脚本时，这可能会很有用。</p><p><strong><code>defer</code>特性仅适用于外部脚本。如果<code>&lt;script&gt;</code>脚本没有 src，则会忽略<code>defer</code>特性。</strong></p><h2 id="2-2-async"><a href="#2-2-async" class="headerlink" title="2.2 async"></a>2.2 async</h2><p><code>async</code>特性与<code>defer</code>有些类似。它也能够让脚本不阻塞页面。但是，在行为上二者有着重要的区别。</p><p><code>async</code>特性意味着脚本是完全独立的：</p><ul><li>浏览器不会因<code>async</code>脚本而阻塞（与<code>defer</code>类似）。</li><li>其他脚本不会等待<code>async</code>脚本加载完成，同样，<code>async</code>脚本也不会等待其他脚本。</li><li><code>DOMContentLoaded</code>和异步脚本不会彼此等待：<ul><li><code>DOMContentLoaded</code>可能会发生在异步脚本之前（如果异步脚本在页面完成后才加载完成）</li><li><code>DOMContentLoaded</code>也可能发生在异步脚本之后（如果异步脚本很短，或者是从 HTTP 缓存中加载的）</li></ul></li></ul><p>换句话说，<code>async</code>脚本会在后台加载，并在加载就绪时运行。DOM 和其他脚本不会等待它们，它们也不会等待其它的东西。<code>async</code>脚本就是一个会在加载完成时执行的完全独立的脚本。</p><ul><li>页面内容立刻显示出来：加载写有 async 的脚本不会阻塞页面渲染。</li><li><code>DOMContentLoaded</code>可能在<code>async</code>之前或之后触发，不能保证谁先谁后。</li><li>较小的脚本 small.js 排在第二位，但可能会比 long.js 这个长脚本先加载完成，所以 small.js 会先执行。虽然，可能是 long.js 先加载完成，如果它被缓存了的话，那么它就会先执行。换句话说，<strong>异步脚本以“加载优先”的顺序执行</strong>。</li></ul><p>当我们将独立的第三方脚本集成到页面时，此时采用异步加载方式是非常棒的：计数器，广告等，因为它们不依赖于我们的脚本，我们的脚本也不应该等待它们：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">&quot;https://google-analytics.com/analytics.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong><code>async</code>特性仅适用于外部脚本。如果<code>&lt;script&gt;</code>脚本没有 src，则会忽略<code>async</code>特性。</strong></p><h2 id="2-3-动态脚本"><a href="#2-3-动态脚本" class="headerlink" title="2.3 动态脚本"></a>2.3 动态脚本</h2><p>此外，还有一种向页面添加脚本的重要的方式。</p><p>我们可以使用 JavaScript 动态地创建一个脚本，并将其附加（append）到文档（document）中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;/article/script-async-defer/long.js&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(script); <span class="comment">// (*)</span></span><br></pre></td></tr></table></figure><p>当脚本被附加到文档 (*) 时，脚本就会立即开始加载。</p><p><strong>默认情况下，动态脚本的行为是“异步”的。</strong></p><p>如果我们显式地设置了<code>script.async=false</code>，则可以改变这个规则。然后脚本将按照脚本在文档中的顺序执行，就像<code>defer</code>那样。</p><h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h2><p>所以说<code>defer</code>是以文档顺序进行解析，而<code>async</code>则是按照加载优先顺序进行解析 <code>defer</code>更适合需要整个DOM的脚本，而<code>async</code>则更合适用于独立脚本</p><p>请注意：如果你使用的是<code>defer</code>或<code>async</code>，那么用户将在脚本加载完成之前先看到页面。 在这种情况下，某些图形组件可能尚未初始化完成。 因此，请记得添加一个“正在加载”的提示，并禁用尚不可用的按钮。以让用户可以清楚地看到，他现在可以在页面上做什么，以及还有什么是正在准备中的。</p><h1 id="三、资源加载"><a href="#三、资源加载" class="headerlink" title="三、资源加载"></a>三、资源加载</h1><p>浏览器允许我们跟踪外部资源的加载 —— 脚本，iframe，图片等。</p><p>这里有两个事件：</p><ul><li>onload —— 成功加载</li><li>onerror —— 出现error</li></ul><p>假设我们需要加载第三方脚本，并调用其中的函数。 我们可以像这样动态加载它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;my.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">append</span>(script);</span><br></pre></td></tr></table></figure><p>……但如何运行在该脚本中声明的函数？我们需要等到该脚本加载完成，之后才能调用它。</p><h2 id="3-1-script-onload-x2F-onerror"><a href="#3-1-script-onload-x2F-onerror" class="headerlink" title="3.1 script.onload&#x2F;onerror"></a>3.1 script.onload&#x2F;onerror</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以从任意域（domain），加载任意脚本</span></span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">append</span>(script);</span><br><span class="line"></span><br><span class="line">script.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 该脚本创建了一个变量 &quot;_&quot;</span></span><br><span class="line">  <span class="title function_">alert</span>( _.<span class="property">VERSION</span> ); <span class="comment">// 显示库的版本</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过onload事件，可以在脚本加载完成后，通过函数来运行脚本中的变量和函数等。</p><p>如果出现错误（比如error 404 或者服务器宕机等），则会被onerror追踪到。</p><p>例如，我们请求一个不存在的脚本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;https://example.com/404.js&quot;</span>; <span class="comment">// 没有这个脚本</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">append</span>(script);</span><br><span class="line"></span><br><span class="line">script.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;Error loading &quot;</span> + <span class="variable language_">this</span>.<span class="property">src</span>); <span class="comment">// Error loading https://example.com/404.js</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>onload&#x2F;onerror 事件仅跟踪加载本身。</strong> 在脚本处理和执行期间可能发生的error超出了这些事件跟踪的范围。也就是说：如果脚本成功加载，则即使脚本中有编程error，也会触发onload事件。如果要跟踪脚本error，可以使用<code>window.onerror</code>全局处理程序。</p><h2 id="3-2-其他资源"><a href="#3-2-其他资源" class="headerlink" title="3.2 其他资源"></a>3.2 其他资源</h2><p><code>load</code>和<code>error</code>事件也适用于其他资源，基本上（basically）适用于具有外部 src 的任何资源。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;https://js.cx/clipart/train.gif&quot;</span>; <span class="comment">// (*)</span></span><br><span class="line"></span><br><span class="line">img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">`Image loaded, size <span class="subst">$&#123;img.width&#125;</span>x<span class="subst">$&#123;img.height&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">img.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;Error occurred while loading image&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>大多数资源在被添加到文档中后，便开始加载。但是<code>&lt;img&gt;</code>是个例外。它要等到获得<code>src (*)</code>后才开始加载。</li><li>对于<code>&lt;iframe&gt;</code>来说，iframe加载完成时会触发<code>iframe.onload</code>事件，无论是成功加载还是出现error。</li></ul><h2 id="3-3-跨源策略"><a href="#3-3-跨源策略" class="headerlink" title="3.3 跨源策略"></a>3.3 跨源策略</h2><p>这里有一条规则：来自一个网站的脚本无法访问其他网站的内容。例如，位于<code>https://facebook.com</code>的脚本无法读取位于<code>https://gmail.com</code>的用户邮箱。</p><p>或者，更确切地说，一个源（域&#x2F;端口&#x2F;协议三者）无法获取另一个源（origin）的内容。因此，即使我们有一个子域，或者仅仅是另一个端口，这都是不同的源，彼此无法相互访问。 这个规则还影响其他域的资源。 如果我们使用的是来自其他域的脚本，并且该脚本中存在 error，那么我们无法获取 error 的详细信息。</p><p>因为有很多服务（我们也可以构建自己的服务）使用<code>window.onerror</code>监听全局 error，保存 error 并提供访问和分析 error 的接口。这很好，因为我们可以看到由用户触发的实际中的 error。但是，如果一个脚本来自于另一个源（origin），则没有太多有关 error 的信息。</p><p>要允许跨源访问，<code>&lt;script&gt;</code>标签需要具有 crossorigin 特性（attribute），并且远程服务器必须提供特殊的 header。</p><ol><li>无<code>crossorigin</code>特性 —— 禁止访问。</li><li><code>crossorigin=&quot;anonymous&quot;</code> —— 如果服务器的响应带有包含 * 或我们的源（origin）的 header <code>Access-Control-Allow-Origin</code>，则允许访问。浏览器不会将授权信息和 cookie 发送到远程服务器。</li><li><code>crossorigin=&quot;use-credentials&quot;</code> —— 如果服务器发送回带有我们的源的 header <code>Access-Control-Allow-Origin</code> 和 <code>Access-Control-Allow-Credentials: true</code>，则允许访问。浏览器会将授权信息和 cookie 发送到远程服务器。</li></ol><p>关于cookie的相关知识会在下面进行介绍。</p><h1 id="四、cookie"><a href="#四、cookie" class="headerlink" title="四、cookie"></a>四、cookie</h1><p>Cookie 是直接存储在浏览器中的一小串数据。它们是 HTTP 协议的一部分。 Cookie 通常是由Web服务器使用响应<code>Set-Cookie HTTP-header</code>设置的。然后浏览器使用<code>Cookie HTTP-header</code>将它们自动添加到（几乎）每个对相同域的请求中。</p><p>最常见的用处之一就是身份验证：</p><ol><li>登录后，服务器在响应中使用<code>Set-Cookie HTTP-header</code>来设置具有唯一“会话标识符（session identifier）”的 cookie。</li><li>下次当请求被发送到同一个域时，浏览器会使用<code>Cookie HTTP-header</code>通过网络发送 cookie。</li><li>所以服务器知道是谁发起了请求。</li></ol><p>我们还可以使用<code>document.cookie</code>属性从浏览器访问 cookie。</p><h2 id="4-1-document-cookie"><a href="#4-1-document-cookie" class="headerlink" title="4.1 document.cookie"></a>4.1 document.cookie</h2><p><code>document.cookie</code>的值由<code>name=value</code>对组成，以 ; 分隔。每一个都是独立的 cookie。 为了找到一个特定的 cookie，我们可以以 ; 作为分隔，将<code>document.cookie</code>分开，然后找到对应的名字。我们可以使用正则表达式或者数组函数来实现。</p><p><strong>可以使用document.cookie来更新cookie的值。但是这种写入操作只会更新其中提到的 cookie，而不会涉及其他 cookie</strong></p><p>从技术上讲，cookie 的名称和值可以是任何字符。为了保持有效的格式，它们应该使用内建的<code>encodeURIComponent</code>函数对其进行转义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特殊字符（空格），需要编码</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;my name&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> value = <span class="string">&quot;John Smith&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 cookie 编码为 my%20name=John%20Smith</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>); <span class="comment">// ...; my%20name=John%20Smith</span></span><br></pre></td></tr></table></figure><p>cookie的限制：</p><ul><li><code>encodeURIComponent</code>编码后的 name&#x3D;value 对，大小不能超过 4KB。因此，我们不能在一个 cookie 中保存大的东西。</li><li>每个域的 cookie 总数不得超过 20+ 左右，具体限制取决于浏览器。</li></ul><h2 id="4-2-cookie的选项"><a href="#4-2-cookie的选项" class="headerlink" title="4.2 cookie的选项"></a>4.2 cookie的选项</h2><p><code>document.cookie = &quot;user=John; path=/; expires=Tue, 19 Jan 2038 03:14:07 GMT&quot;</code></p><ul><li><p>path: path&#x3D;&#x2F;mypath。</p><ul><li>url 路径前缀必须是绝对路径。它使得该路径下的页面可以访问该 cookie。默认为当前路径。</li><li>如果一个 cookie 带有<code>path=/admin</code>设置，那么该 cookie 在<code>/admin</code>和<code>/admin/something</code>下都是可见的，但是在<code>/home</code>或<code>/adminpage</code>下不可见。</li><li>通常，我们应该将path设置为根目录：<code>path=/</code>，以使 cookie 对此网站的所有页面可见。</li></ul></li><li><p>domain:domain&#x3D;site.com</p><ul><li><p>domain 控制了可访问 cookie 的域。但是在实际中，有一些限制。我们无法设置任何域。</p></li><li><p>无法从另一个二级域访问 cookie，因此<code>other.com</code>永远不会收到在<code>site.com</code>设置的 cookie。</p></li><li><p>这是一项安全限制，为了允许我们将敏感数据存储在应该仅在一个站点上可用的 cookie 中。</p></li><li><p>默认情况下，cookie 只有在设置的域下才能被访问到。</p></li><li><p>请注意，默认情况下，cookie 也不会共享给子域，例如<code>forum.site.com</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果我们在 site.com 网站上设置了 cookie……</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;user=John&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……在 forum.site.com 域下我们无法访问它</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>); <span class="comment">// 没有 user</span></span><br></pre></td></tr></table></figure></li><li><p><strong>所以说，如果想要在子域上访问父域的cookie，则需要通过<code>domain</code>来将<code>domain=site.com</code>，这样就将父域设置为了根域，从而所有子域都能够访问到这样的cookie</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 site.com</span></span><br><span class="line"><span class="comment">// 使 cookie 可以被在任何子域 *.site.com 访问：</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;user=John; domain=site.com&quot;</span></span><br><span class="line"><span class="comment">// 之后</span></span><br><span class="line"><span class="comment">// 在 forum.site.com</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>); <span class="comment">// 有 cookie user=John</span></span><br></pre></td></tr></table></figure></li><li><p>出于历史原因,<code>domain=.site.com</code>（site.com 前面有一个点符号）也以相同的方式工作，允许从子域访问 cookie。这是一个旧的表示方式，如果我们需要支持非常旧的浏览器，那么应该使用它</p></li></ul></li><li><p>expires,max-age</p><ul><li><p>默认情况下，如果一个 cookie 没有设置这两个参数中的任何一个，那么在关闭浏览器之后，它就会消失。此类 cookie 被称为 “session cookie”。</p></li><li><p>为了让 cookie 在浏览器关闭后仍然存在，我们可以设置 expires 或 max-age 选项中的一个。<code>expires=Tue, 19 Jan 2038 03:14:07 GMT</code></p></li><li><p>cookie 的过期时间定义了浏览器会自动清除该 cookie 的时间。</p></li><li><p>日期必须完全采用 GMT 时区的这种格式。我们可以使用<code>date.toUTCString</code>来获取。</p></li><li><p>如果我们将<code>expires</code>设置为过去的时间，则 cookie 会被删除。</p></li><li><p><code>max-age</code>是<code>expires</code>的替代选项，指明了 cookie 的过期时间距离当前时间的秒数。</p></li><li><p>如果将其设置为 0 或负数，则 cookie 会被删除：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// cookie 会在一小时后失效</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;user=John; max-age=3600&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><p>&#x2F;&#x2F; 删除 cookie（让它立即过期） document.cookie &#x3D; “user&#x3D;John; max-age&#x3D;0”;</p></li><li><p>secure</p><ul><li>Cookie 应只能被通过 HTTPS 传输。</li><li><strong>默认情况下，如果我们在<code>http://site.com</code>上设置了 cookie，那么该 cookie 也会出现在<code>https://site.com</code>上，反之亦然。</strong></li><li>也就是说，cookie 是基于域的，它们不区分协议。</li><li>使用此选项，如果一个 cookie 是通过<code>https://site.com</code>设置的，那么它不会在相同域的 HTTP 环境下出现，例如 <code>http://site.com</code>。所以，如果一个 cookie 包含绝不应该通过未加密的 HTTP 协议发送的敏感内容，那么就应该设置 secure 标识</li></ul></li><li><p>samesite</p><ul><li>这是另外一个关于安全的特性。它旨在防止 XSRF（跨网站请求伪造）攻击。</li><li>当<code>samesite=strict</code>时，如果用户来自同一网站之外，那么设置了 <code>samesite=strict</code>的 cookie 永远不会被发送。</li><li><code>samesite=lax</code>是一种更轻松的方法，该方法还可以防止 XSRF 攻击，并且不会破坏用户体验。</li><li>宽松（lax）模式，和 strict 模式类似，当从外部来到网站，则禁止浏览器发送 cookie，但是增加了一个例外。</li><li>如果以下两个条件均成立，则会发送含 samesite&#x3D;lax 的 cookie：</li><li><ol><li>HTTP 方法是“安全的”（例如 GET 方法，而不是 POST）。</li></ol></li><li>所有安全的 HTTP 方法详见<a href="https://datatracker.ietf.org/doc/html/rfc7231">RFC7231规范</a>。基本上，这些都是用于读取而不是写入数据的方法。它们不得执行任何更改数据的操作。跟随链接始终是 GET，是安全的方法。<ol start="2"><li>该操作执行顶级导航（更改浏览器地址栏中的 URL）。</li></ol></li><li>这通常是成立的，但是如果导航是在一个<code>&lt;iframe&gt;</code>中执行的，那么它就不是顶级的。此外，用于网络请求的 JavaScript 方法不会执行任何导航，因此它们不适合。</li><li>所以，<code>samesite=lax</code>所做的是基本上允许最常见的“前往 URL”操作携带 cookie。例如，从笔记中打开网站链接就满足这些条件。</li><li>但是，任何更复杂的事儿，例如来自另一个网站的网络请求或表单提交都会丢失 cookie。</li><li>如果这种情况适合你，那么添加<code>samesite=lax</code>将不会破坏用户体验并且可以增加保护。</li><li><strong>samesite会被到 2017 年左右的旧版本浏览器忽略（不兼容）。</strong></li><li>所以可以将 samesite 与其他保护措施（例如 XSRF token）一起使用，例如 xsrf token，这样可以多增加一层保护，将来，当旧版本的浏览器淘汰时，我们可能就可以删除 xsrf token 这种方式了。</li></ul></li><li><p>httpOnly</p><ul><li>Web 服务器使用<code>Set-Cookie header</code>来设置 cookie。并且，它可以设置 <code>httpOnly</code>选项。</li><li>这个选项禁止任何 JavaScript 访问 cookie。我们使用<code>document.cookie</code>看不到此类 cookie，也无法对此类 cookie 进行操作。</li><li>这个的主要作用就是保护浏览器被入侵而造成的用户信息的泄露</li></ul></li></ul><h2 id="4-3-cookie函数"><a href="#4-3-cookie函数" class="headerlink" title="4.3 cookie函数"></a>4.3 cookie函数</h2><p>这里有一组有关 cookie 操作的函数，比手动修改 document.cookie 方便得多。</p><p>有很多这种 cookie 库，所以这些函数只用于演示。虽然它们都能正常使用。</p><h3 id="4-3-1-getCookie-name"><a href="#4-3-1-getCookie-name" class="headerlink" title="4.3.1 getCookie(name)"></a>4.3.1 getCookie(name)</h3><p>获取 cookie 最简短的方式是使用 正则表达式。 getCookie(name) 函数返回具有给定 name 的 cookie：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回具有给定 name 的 cookie，</span></span><br><span class="line"><span class="comment">// 如果没找到，则返回 undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getCookie</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> matches = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">match</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>(</span><br><span class="line">    <span class="string">&quot;(?:^; )&quot;</span> + name.<span class="title function_">replace</span>(<span class="regexp">/([\.$?*&#123;&#125;\(\)\[\]\\\/\+^])/g</span>, <span class="string">&#x27;\\$1&#x27;</span>) + <span class="string">&quot;=([^;]*)&quot;</span></span><br><span class="line">  ));</span><br><span class="line">  <span class="keyword">return</span> matches ? <span class="built_in">decodeURIComponent</span>(matches[<span class="number">1</span>]) : <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 new RegExp 是动态生成的，以匹配 ; name&#x3D;。</p><p>请注意 cookie 的值是经过编码的，所以 getCookie 使用了内建方法 <code>decodeURIComponent</code>函数对其进行解码。</p><h3 id="4-3-2-setCookie-name-value-options"><a href="#4-3-2-setCookie-name-value-options" class="headerlink" title="4.3.2 setCookie(name, value,options)"></a>4.3.2 setCookie(name, value,options)</h3><p>将 cookie 的 name 设置为具有默认值 path&#x3D;&#x2F;（可以修改以添加其他默认值）和给定值 value：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setCookie</span>(<span class="params">name, value, options = &#123;&#125;</span>) &#123;</span><br><span class="line"></span><br><span class="line">  options = &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="comment">// 如果需要，可以在这里添加其他默认值</span></span><br><span class="line">    ...options</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">expires</span> <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">    options.<span class="property">expires</span> = options.<span class="property">expires</span>.<span class="title function_">toUTCString</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updatedCookie = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">&quot;=&quot;</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> optionKey <span class="keyword">in</span> options) &#123;</span><br><span class="line">    updatedCookie += <span class="string">&quot;; &quot;</span> + optionKey;</span><br><span class="line">    <span class="keyword">let</span> optionValue = options[optionKey];</span><br><span class="line">    <span class="keyword">if</span> (optionValue !== <span class="literal">true</span>) &#123;</span><br><span class="line">      updatedCookie += <span class="string">&quot;=&quot;</span> + optionValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">cookie</span> = updatedCookie;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用范例：</span></span><br><span class="line"><span class="title function_">setCookie</span>(<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;John&#x27;</span>, &#123;<span class="attr">secure</span>: <span class="literal">true</span>, <span class="string">&#x27;max-age&#x27;</span>: <span class="number">3600</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-3-3-deleteCookie-name"><a href="#4-3-3-deleteCookie-name" class="headerlink" title="4.3.3 deleteCookie(name)"></a>4.3.3 deleteCookie(name)</h3><p>要删除一个 cookie，我们可以给它设置一个负的过期时间来调用它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deleteCookie</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title function_">setCookie</span>(name, <span class="string">&quot;&quot;</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;max-age&#x27;</span>: -<span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>请注意：当我们更新或删除一个 cookie 时，我们应该使用和设置 cookie 时相同的路径和域选项。</strong></p><h2 id="4-4-第三方cookie"><a href="#4-4-第三方cookie" class="headerlink" title="4.4 第三方cookie"></a>4.4 第三方cookie</h2><p>如果 cookie 是由用户所访问的页面的域以外的域放置的，则称其为第三方 cookie。</p><p>由于它的性质，第三方 cookie 通常用于跟踪和广告服务。它们被绑定在原始域上，因此 ads.com 可以在不同网站之间跟踪同一用户，如果这些网站都可以访问 ads.com 的话。</p><p>当然，有些人不喜欢被跟踪，因此浏览器允许禁止此类 cookie。</p><p>此外，一些现代浏览器对此类 cookie 采取特殊策略：</p><ul><li>Safari 浏览器完全不允许第三方 cookie。</li><li>Firefox 浏览器附带了一个第三方域的黑名单，它阻止了来自名单内的域的第三方 cookie。</li></ul><h2 id="4-5-GDPR"><a href="#4-5-GDPR" class="headerlink" title="4.5 GDPR"></a>4.5 GDPR</h2><p>欧洲有一项名为 GDPR 的立法，该法规针对网站尊重用户实施了一系列规则。其中之一就是需要明确的许可才可以跟踪用户的 cookie。</p><p><strong>所以说很多网站要用户来同意使用cookie，但是感觉国内网站根本没有这个东西-。-</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、页面的生命周期&quot;&gt;&lt;a href=&quot;#一、页面的生命周期&quot; class=&quot;headerlink&quot; title=&quot;一、页面的生命周期&quot;&gt;&lt;/a&gt;一、页面的生命周期&lt;/h1&gt;&lt;p&gt;HTML 页面的生命周期包含三个重要事件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOMCont</summary>
      
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>js补充知识</title>
    <link href="http://example.com/2022/06/22/js%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2022/06/22/js%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/</id>
    <published>2022-06-22T05:44:19.000Z</published>
    <updated>2023-03-20T08:32:35.762Z</updated>
    
    <content type="html"><![CDATA[<h3 id="现代模式"><a href="#现代模式" class="headerlink" title="现代模式"></a>现代模式</h3><p>现代模式<code>&quot;use strict&quot;;</code>当它处于脚本文件的顶部时，则整个脚本文件都将以“现代”模式进行工作。 <code>&quot;use strict&quot;</code>可以被放在函数体的开头。这样则可以只在该函数中启用严格模式。 但通常人们会在整个脚本中启用严格模式。</p><span id="more"></span><h3 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h3><p>用<code>let</code>来声明一个变量，原来用<code>var</code>来声明变量是一种比较古老的方式 <code>let message = &quot;hello&quot;;</code> 一个变量应该只能被声明一次，之后只进行引用</p><p>声明一个常数（不变）变量，可以使用 <code>const</code> 而非 <code>let</code>,常量不能被修改，否则会报错 一个普遍的做法是将常量用作别名，以便记住那些在执行之前就已知的难以记住的值。例如使用大写字母和下划线来命名这些常量。</p><h4 id="let-和-var的区别"><a href="#let-和-var的区别" class="headerlink" title="let 和 var的区别"></a>let 和 var的区别</h4><p>var没有块级作用域，它只存在于函数作用域和全局作用域，所以如果有一个代码块的话，等于var会创建一个全局变量。 而let只会存在在代码块内。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> test = <span class="literal">true</span>; <span class="comment">// 使用 &quot;var&quot; 而不是 &quot;let&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(test); <span class="comment">// true，变量在 if 结束后仍存在</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> test = <span class="literal">true</span>; <span class="comment">// 使用 &quot;let&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(test); <span class="comment">// ReferenceError: test is not defined</span></span><br></pre></td></tr></table></figure><p><strong>var能够穿透if，for和其它代码块。</strong></p><p>如果我们用 let 在同一作用域下将同一个变量声明两次，则会出现错误。 使用 var，我们可以重复声明一个变量，不管多少次都行。如果我们对一个已经声明的变量使用var，这条新的声明语句会被忽略。 <strong>var 变量声明在函数开头就会被处理（脚本启动对应全局变量）。</strong></p><h3 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h3><p>numbe类型无法大于大于 (2^53-1)（即 9007199254740991），或小于 -(2^53-1) 的整数。这是其内部表示形式导致的技术限制。 可以通过将 n 附加到整数字段的末尾来创建 BigInt 值。 <code>const bigInt = 1234567890123456789012345678901234567890n;</code></p><h3 id="通过反引号对字符串嵌入"><a href="#通过反引号对字符串嵌入" class="headerlink" title="通过反引号对字符串嵌入"></a>通过反引号对字符串嵌入</h3><p>反引号是<strong>功能扩展</strong>引号。它们允许我们通过将变量和表达式包装在<code>$&#123;...&#125;</code>中，来将它们嵌入到字符串中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">`the result is <span class="subst">$&#123;<span class="number">1</span> + <span class="number">2</span>&#125;</span>`</span> ); <span class="comment">// the result is 3</span></span><br></pre></td></tr></table></figure><h3 id="for-in-和for-of-的区别"><a href="#for-in-和for-of-的区别" class="headerlink" title="for in 和for of 的区别"></a>for in 和for of 的区别</h3><p>for in 和for of 都是遍历对象里的每一项，那么他们有什么区别呢？ 区别1： for of无法循环遍历对象 区别2： <strong>for in循环遍历的是数组的索引，for of循环遍历的是数组的值</strong></p><p><strong>可以应用 for..of 的对象被称为 可迭代的。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;nick&#x27;</span>,<span class="string">&#x27;freddy&#x27;</span>,<span class="string">&#x27;mike&#x27;</span>,<span class="string">&#x27;james&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key);   <span class="comment">//输出的是0,1,2,3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----------分割线-----------&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> arr)&#123;   </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);  <span class="comment">//输出的是nick&#x27;,&#x27;freddy&#x27;,&#x27;mike&#x27;,&#x27;james&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别3： for in 会遍历自定义属性，for of不会</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;nick&#x27;</span>,<span class="string">&#x27;freddy&#x27;</span>,<span class="string">&#x27;mike&#x27;</span>,<span class="string">&#x27;james&#x27;</span>];</span><br><span class="line">arr.<span class="property">name</span> = <span class="string">&quot;数组&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key+<span class="string">&#x27;: &#x27;</span>+arr[key]);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----------分割线-----------&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> arr)&#123;   </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给数组添加一个自定义属性name，并且赋值”数组”。然后进行遍历输出的，会发现新定义的属性也被for in输出来了，而for of并不会对name进行输出。</p><h3 id="对象的一些补充知识"><a href="#对象的一些补充知识" class="headerlink" title="对象的一些补充知识"></a>对象的一些补充知识</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    name = <span class="string">&quot;john&quot;</span>,</span><br><span class="line">    age = <span class="number">30</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>列表中的最后一个属性应以逗号结尾,这叫做尾随（trailing）或悬挂（hanging）逗号。这样便于我们添加、删除和移动属性，因为所有的行都是相似的。 通过方括号同样可以对对象进行操作 比如说<code>user[&quot;like birds&quot;] = true;</code>或者是<code>delete user[&quot;like birds&quot;]</code>就可以通过方括号来对对象进行增删查改，并且可以适用于任何字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> key = <span class="title function_">prompt</span>(<span class="string">&quot;What do you want to know about the user?&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问变量</span></span><br><span class="line"><span class="title function_">alert</span>( user[key] ); <span class="comment">// John（如果输入 &quot;name&quot;）</span></span><br></pre></td></tr></table></figure><p>又或者可以通过变量<code>key</code>来访问属性。而点符号则不能使用 key只能访问user中存在的属性，如果属性不存在则显示undefined，这里的key会指向name</p><p>对象的克隆和合并可以使用<code>Object.assign(dest, [src1, src2, src3...])</code>方法 第一个参数 dest 是指目标对象。 更后面的参数 src1, …, srcN（可按需传递多个参数）是源对象。 该方法将所有源对象的属性拷贝到目标对象 dest 中。换句话说，从第二个开始的所有参数的属性都被拷贝到第一个参数的对象中。 调用结果返回 dest。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> permissions1 = &#123; <span class="attr">canView</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> permissions2 = &#123; <span class="attr">canEdit</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 permissions1 和 permissions2 中的所有属性都拷贝到 user 中</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(user, permissions1, permissions2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 user = &#123; name: &quot;John&quot;, canView: true, canEdit: true &#125;</span></span><br></pre></td></tr></table></figure><p>如果被拷贝的属性的属性名已经存在，那么它会被覆盖：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(user, &#123; <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">name</span>); <span class="comment">// 现在 user = &#123; name: &quot;Pete&quot; &#125;</span></span><br></pre></td></tr></table></figure><p>我们也可以用 Object.assign 代替 for..in 循环来进行简单克隆：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clone = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, user);</span><br></pre></td></tr></table></figure><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>symbol表示唯一的标识符。 Symbol 保证是唯一的。即使我们创建了许多具有相同描述的 Symbol，它们的值也是不同。描述只是一个标签，不影响任何东西。 例如，这里有两个描述相同的 Symbol —— 它们不相等：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id1 = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> id2 = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(id1 == id2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>Symbol 不会被自动转换为字符串</strong> 如果我们真的想显示一个 Symbol，我们需要在它上面调用 <code>.toString()</code>，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(id.<span class="title function_">toString</span>()); <span class="comment">// Symbol(id)，现在它有效了</span></span><br></pre></td></tr></table></figure><p>或者获取 symbol.description 属性，只显示描述（description）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(id.<span class="property">description</span>); <span class="comment">// id</span></span><br></pre></td></tr></table></figure><p><strong>Symbol 允许我们创建对象的“隐藏”属性，代码的任何其他部分都不能意外访问或重写这些属性。</strong></p><h3 id="数字、字符串、数组的补充"><a href="#数字、字符串、数组的补充" class="headerlink" title="数字、字符串、数组的补充"></a>数字、字符串、数组的补充</h3><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>假如我们需要表示 10 亿。显然，我们可以这样写： <code>MARKDOWN_HASH3c0128960a8d24c0e2a3faa7cb76fcf5MARKDOWN_HASH_</code> <em>我们也可以使用下划线</em> 作为分隔符： <code>MARKDOWN_HASH132377f2ba50b82cc7752c46a838738dMARKDOWN_HASH_</code> <em>这里的下划线</em> 扮演了“语法糖”的角色，使得数字具有更强的可读性。JavaScript 引擎会直接忽略数字之间的 _，所以 上面两个例子其实是一样的。 在 JavaScript 中，我们可以通过在数字后面附加字母 “e” 并指定零的个数来缩短数字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> billion = <span class="number">1e9</span>;  <span class="comment">// 10 亿，字面意思：数字 1 后面跟 9 个 0</span></span><br><span class="line"><span class="keyword">let</span> mcs = <span class="number">1e-6</span>; <span class="comment">// 1 的左边有 6 个 0 --&gt;0.000001</span></span><br></pre></td></tr></table></figure><p>方法 num.toString(base) 返回在给定 base 进制数字系统中 num 的字符串表示形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( num.<span class="title function_">toString</span>(<span class="number">16</span>) );  <span class="comment">// ff</span></span><br><span class="line"><span class="title function_">alert</span>( num.<span class="title function_">toString</span>(<span class="number">2</span>) );   <span class="comment">// 11111111</span></span><br></pre></td></tr></table></figure><p>函数 toFixed(n) 将数字舍入到小数点后 n 位，并以<strong>字符串形式</strong>返回结果。 因为toFixed 的结果是一个字符串。如果小数部分比所需要的短，则在结尾添加零：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">12.34</span>;</span><br><span class="line"><span class="title function_">alert</span>( num.<span class="title function_">toFixed</span>(<span class="number">5</span>) ); <span class="comment">// &quot;12.34000&quot;，在结尾添加了 0，以达到小数点后五位</span></span><br></pre></td></tr></table></figure><p>所以说如果使用toFixed来转换，可以使用一元加号或Number()调用，将其转换为数字：<code>+num.toFixed(5)</code></p><p><strong>因为在js中进行小数操作时，很有可能出现精度损失，所以在处理小数时避免相等性检查。</strong></p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p><code>str.charAt[pos]</code>可以获取在pos位置的字符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`Hello`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个字符</span></span><br><span class="line"><span class="title function_">alert</span>( str[<span class="number">0</span>] ); <span class="comment">// H</span></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">charAt</span>(<span class="number">0</span>) ); <span class="comment">// H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一个字符</span></span><br><span class="line"><span class="title function_">alert</span>( str[str.<span class="property">length</span> - <span class="number">1</span>] ); <span class="comment">// o</span></span><br></pre></td></tr></table></figure><p><strong><code>str.charCodeAt[pos]</code>可以获取在pos位置的字符的Unicode编码</strong></p><p>toLowerCase() 和 toUpperCase() 方法可以改变大小写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&#x27;Interface&#x27;</span>.<span class="title function_">toUpperCase</span>() ); <span class="comment">// INTERFACE</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&#x27;Interface&#x27;</span>.<span class="title function_">toLowerCase</span>() ); <span class="comment">// interface</span></span><br></pre></td></tr></table></figure><p><code>str.indexOf()</code> 和<code>str.lastIndexOf()</code>用于查找字符串中某个字符或字符串的位置 如果找到则返回位置，没找到则返回-1。 不同的是，indexOf是从头开始寻找，lastIndexOf是从尾部开始寻找，但是这两种方法返回的值都是正向的。</p><p>更现代的方法 str.includes(substr, pos) 根据 str 中是否包含 substr 来返回 true&#x2F;false。 <strong>如果我们需要检测匹配，但不需要它的位置，那么这是正确的选择</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Widget with id&quot;</span>.<span class="title function_">includes</span>(<span class="string">&quot;Widget&quot;</span>) ); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Hello&quot;</span>.<span class="title function_">includes</span>(<span class="string">&quot;Bye&quot;</span>) ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>str.includes 的第二个可选参数是开始搜索的起始位置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Midget&quot;</span>.<span class="title function_">includes</span>(<span class="string">&quot;id&quot;</span>) ); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Midget&quot;</span>.<span class="title function_">includes</span>(<span class="string">&quot;id&quot;</span>, <span class="number">3</span>) ); <span class="comment">// false, 从位置 3 开始没有 &quot;id&quot;</span></span><br></pre></td></tr></table></figure><p>方法 str.startsWith 和 str.endsWith 的功能与其名称所表示的意思相同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Widget&quot;</span>.<span class="title function_">startsWith</span>(<span class="string">&quot;Wid&quot;</span>) ); <span class="comment">// true，&quot;Widget&quot; 以 &quot;Wid&quot; 开始</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Widget&quot;</span>.<span class="title function_">endsWith</span>(<span class="string">&quot;get&quot;</span>) ); <span class="comment">// true，&quot;Widget&quot; 以 &quot;get&quot; 结束</span></span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>通过数组来实现队列和栈 <strong>队列(queque)：</strong> push 在末端添加一个元素. shift 取出队列首端的一个元素，整个队列往前移，这样原先排第二的元素现在排在了第一。 这两种操作数组都支持。 队列的应用在实践中经常会碰到。例如需要在屏幕上显示消息队列。 <strong>栈：</strong> push 在末端添加一个元素. pop 从末端取出一个元素. 所以新元素的添加和取出都是从“末端”开始的。 栈通常被被形容成一叠卡片：要么在最上面添加卡片，要么从最上面拿走卡片： 对于栈来说，最后放进去的内容是最先接收的，也叫做 LIFO（Last-In-First-Out），即后进先出法则。而与队列相对应的叫做 FIFO（First-In-First-Out），即先进先出。 JavaScript 中的数组既可以用作队列，也可以用作栈。它们允许你从首端&#x2F;末端来添加&#x2F;删除元素。 这在计算机科学中，允许这样的操作的数据结构被称为<strong>双端队列（deque）</strong>。</p><p><strong>不能够使用&#x3D;&#x3D;来比较数组</strong> JavaScript 中的数组与其它一些编程语言的不同，不应该使用 &#x3D;&#x3D; 运算符比较 JavaScript 中的数组。 该运算符不会对数组进行特殊处理，它会像处理任意对象那样处理数组。 所以，<strong>如果我们使用 &#x3D;&#x3D; 来比较数组，除非我们比较的是两个引用同一数组的变量，否则它们永远不相等。</strong></p><h4 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h4><p><code>arr.find(function(item, index, array) &#123;如果返回 true，则返回 item 并停止迭代。对于假值（falsy）的情况，则返回 undefined&#125;)</code>可以找到具有特定条件的对象。 item 是元素。index 是它的索引。array 是数组本身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> users = [</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&quot;Mary&quot;</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = users.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span> == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">name</span>); <span class="comment">// John</span></span><br></pre></td></tr></table></figure><p>感觉同理可得如果想要看这个数组是不是全零数组，也可以使用这个来判断 <code>arr.find(item =&gt; item !=0)</code></p><p><code>arr.findIndex</code>方法（与 arr.find 方法）基本上是一样的，但它返回找到元素的索引，而不是元素本身。并且在未找到任何内容时返回 -1。</p><p>find 方法搜索的是使函数返回 true 的第一个（单个）元素。 如果需要匹配的有很多，我们可以使用 arr.filter(fn)。 语法与 find 大致相同，但是 filter 返回的是所有匹配元素组成的数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> users = [</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&quot;Mary&quot;</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回前两个用户的数组</span></span><br><span class="line"><span class="keyword">let</span> someUsers = users.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span> &lt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(someUsers.<span class="property">length</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><strong>map方法</strong>是最有用也最常用的方法 它对数组的每个元素都调用函数，并返回结果数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将每个元素转换为它的字符串长度</span></span><br><span class="line"><span class="keyword">let</span> lengths = [<span class="string">&quot;Bilbo&quot;</span>, <span class="string">&quot;Gandalf&quot;</span>, <span class="string">&quot;Nazgul&quot;</span>].<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">length</span>);</span><br><span class="line"><span class="title function_">alert</span>(lengths); <span class="comment">// 5,7,6</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个数组，数组的每个元素里又有一个子数组</span></span><br><span class="line"><span class="keyword">let</span> r = <span class="number">4</span>,c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(r).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(c).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>排序算法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums1.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a-b);</span><br><span class="line">nums2.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b-a);</span><br></pre></td></tr></table></figure><p>全新的对数字排序方法，本质还是一个函数，但是表示的更加方便了</p><p>通过<code>arr.some(fn)/arr.every(fn)</code>检查数组 与 map 类似，对数组的每个元素调用函数 fn。如果任何&#x2F;所有结果为 true，则返回 true，否则返回 false。 这两个方法的行为类似于 和 &amp;&amp; 运算符：如果 fn 返回一个真值，arr.some() 立即返回 true 并停止迭代其余数组项；如果 fn 返回一个假值，arr.every() 立即返回 false 并停止对其余数组项的迭代。 我们可以使用 every 来比较数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arraysEqual</span>(<span class="params">arr1, arr2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr1.<span class="property">length</span> === arr2.<span class="property">length</span> &amp;&amp; arr1.<span class="title function_">every</span>(<span class="function">(<span class="params">value, index</span>) =&gt;</span> value === arr2[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>( <span class="title function_">arraysEqual</span>([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>])); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>arr.fill(value, start, end) —— 从索引 start 到 end，用重复的 value 填充数组 <strong>一般用于制作全0或全1矩阵</strong></p><p>arr.flat(depth)&#x2F;arr.flatMap(fn) 从多维数组创建一个新的扁平数组。</p><p>有一个全局方法<code>Array.from</code>可以接受一个可迭代或类数组的值，并从中获取一个“真正的”数组。 <code>Array.from(obj[, mapFn, thisArg])</code>其完整语法允许我们提供一个可选的“映射（mapping）”函数。 可选的第二个参数 mapFn 可以是一个函数，该函数会在对象中的元素被添加到数组前，被应用于每个元素，此外 thisArg 允许我们为该函数设置 this。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">range = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 求每个数的平方</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(range, <span class="function"><span class="params">num</span> =&gt;</span> num * num);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(arr); <span class="comment">// 1,4,9,16,25</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;𝒳😂&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 str 拆分为字符数组</span></span><br><span class="line"><span class="keyword">let</span> chars = <span class="title class_">Array</span>.<span class="title function_">from</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(chars[<span class="number">0</span>]); <span class="comment">// 𝒳</span></span><br><span class="line"><span class="title function_">alert</span>(chars[<span class="number">1</span>]); <span class="comment">// 😂</span></span><br><span class="line"><span class="title function_">alert</span>(chars.<span class="property">length</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>与 str.split 方法不同，它依赖于字符串的可迭代特性。因此，就像 for..of 一样，可以正确地处理代理对（surrogate pair）。（译注：代理对也就是 UTF-16 扩展字符。） 技术上来讲，它和下面这段代码做的是相同的事：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;𝒳😂&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> chars = []; <span class="comment">// Array.from 内部执行相同的循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> str) &#123;</span><br><span class="line">  chars.<span class="title function_">push</span>(char);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(chars);</span><br></pre></td></tr></table></figure><p>……但 Array.from 精简很多。 我们甚至可以基于 Array.from 创建代理感知（surrogate-aware）的slice 方法（译注：也就是能够处理 UTF-16 扩展字符的 slice 方法）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">slice</span>(<span class="params">str, start, end</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(str).<span class="title function_">slice</span>(start, end).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;𝒳😂𩷶&#x27;</span>;</span><br><span class="line"><span class="title function_">alert</span>( <span class="title function_">slice</span>(str, <span class="number">1</span>, <span class="number">3</span>) ); <span class="comment">// 😂𩷶</span></span><br><span class="line"><span class="comment">// 原生方法不支持识别代理对（译注：UTF-16 扩展字符）</span></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">3</span>) ); <span class="comment">// 乱码（两个不同 UTF-16 扩展字符碎片拼接的结果）</span></span><br></pre></td></tr></table></figure><h3 id="Map-and-Set（映射和集合）"><a href="#Map-and-Set（映射和集合）" class="headerlink" title="Map and Set（映射和集合）"></a>Map and Set（映射和集合）</h3><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>Map 是一个带键的数据项的集合，就像一个 Object 一样。 但是它们最大的差别是 Map 允许任何类型的键（key）。</p><ul><li><p>new Map() —— 创建 map。</p></li><li><p>map.set(key, value) —— 根据键存储值。 每一次 map.set 调用都会返回 map 本身，所以我们可以进行“链式”调用：</p></li><li><p>map.get(key) —— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined。</p></li><li><p>map.has(key) —— 如果 key 存在则返回 true，否则返回 false。</p></li><li><p>map.delete(key) —— 删除指定键的值。</p></li><li><p>map.clear() —— 清空 map。</p></li><li><p>map.size —— 返回当前元素个数。 map的重点是key，其主要的操作都是对key进行的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br></pre></td></tr></table></figure></li></ul><p>map.set(‘1’, ‘str1’); &#x2F;&#x2F; 字符串键 map.set(1, ‘num1’); &#x2F;&#x2F; 数字键 map.set(true, ‘bool1’); &#x2F;&#x2F; 布尔值键 &#x2F;&#x2F; Map 则会保留键的类型，所以下面这两个结果不同： alert( map.get(1) ); &#x2F;&#x2F; ‘num1’ alert( map.get(‘1’) ); &#x2F;&#x2F; ‘str1’</p><p>alert( map.size ); &#x2F;&#x2F; 3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">使用对象作为键是 Map 最值得注意和重要的功能之一。在 Object 中，我们则无法使用对象作为键。在 Object 中使用字符串作为键是可以的，但我们无法使用另一个 Object 作为 Object 中的键。</span><br><span class="line"></span><br><span class="line">- map.keys() —— 遍历并返回所有的键（returns an iterable for keys），</span><br><span class="line">- map.values() —— 遍历并返回所有的值（returns an iterable for values），</span><br><span class="line">- map.entries() —— 遍历并返回所有的实体（returns an iterable for entries）[key, value]，for..of 在默认情况下使用的就是这个。</span><br><span class="line">```js</span><br><span class="line">let recipeMap = new Map([</span><br><span class="line">  [&#x27;cucumber&#x27;, 500],</span><br><span class="line">  [&#x27;tomatoes&#x27;, 350],</span><br><span class="line">  [&#x27;onion&#x27;,    50]</span><br><span class="line">]);</span><br><span class="line">// 遍历所有的键（vegetables）</span><br><span class="line">for (let vegetable of recipeMap.keys()) &#123;</span><br><span class="line">  alert(vegetable); // cucumber, tomatoes, onion</span><br><span class="line">&#125;</span><br><span class="line">// 遍历所有的值（amounts）</span><br><span class="line">for (let amount of recipeMap.values()) &#123;</span><br><span class="line">  alert(amount); // 500, 350, 50</span><br><span class="line">&#125;</span><br><span class="line">// 遍历所有的实体 [key, value]</span><br><span class="line">for (let entry of recipeMap) &#123; // 与 recipeMap.entries() 相同</span><br><span class="line">  alert(entry); // cucumber,500 (and so on)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不管使用什么方法，返回的都是一个可迭代对象，而不是一个数组，如果想要将返回的对象转变为一个数组，需要使用<code>Array.from(map.keys())</code></p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Set 是一个特殊的类型集合 —— “值的集合”（没有键），它的每一个值只能出现一次。</p><ul><li><p>new Set(iterable) —— 创建一个 set，如果提供了一个 iterable 对象（通常是数组），将会从数组里面复制值到 set 中。</p></li><li><p>set.add(value) —— 添加一个值，返回 set 本身</p></li><li><p>set.delete(value) —— 删除值，如果 value 在这个方法调用的时候存在则返回 true ，否则返回 false。</p></li><li><p>set.has(value) —— 如果 value 在 set 中，返回 true，否则返回 false。</p></li><li><p>set.clear() —— 清空 set。</p></li><li><p>set.size —— 返回元素个数。 <strong>它的主要特点是，重复使用同一个值调用 set.add(value) 并不会发生什么改变。这就是 Set 里面的每一个值只出现一次的原因。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="keyword">let</span> john = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> pete = &#123; <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mary = &#123; <span class="attr">name</span>: <span class="string">&quot;Mary&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// visits，一些访客来访好几次</span></span><br><span class="line">set.<span class="title function_">add</span>(john);</span><br><span class="line">set.<span class="title function_">add</span>(pete);</span><br><span class="line">set.<span class="title function_">add</span>(mary);</span><br><span class="line">set.<span class="title function_">add</span>(john);</span><br><span class="line">set.<span class="title function_">add</span>(mary);</span><br><span class="line"><span class="comment">// set 只保留不重复的值</span></span><br><span class="line"><span class="title function_">alert</span>( set.<span class="property">size</span> ); <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> user <span class="keyword">of</span> set) &#123;</span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">name</span>); <span class="comment">// John（然后 Pete 和 Mary）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Set 的替代方法可以是一个用户数组，用 arr.find 在每次插入值时检查是否重复。但是这样性能会很差，因为这个方法会遍历整个数组来检查每个元素。Set 内部对唯一性检查进行了更好的优化。</p></li></ul><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>JSON（JavaScript Object Notation）是表示值和对象的通用格式。在 RFC 4627 标准中有对其的描述。最初它是为 JavaScript 而创建的，但许多其他编程语言也有用于处理它的库。因此，当客户端使用 JavaScript 而服务器端是使用 Ruby&#x2F;PHP&#x2F;Java 等语言编写的时，使用 JSON 可以很容易地进行数据交换。</p><ul><li><code>JSON.stringify</code>将对象转换为 JSON。 方法 JSON.stringify() 接收对象并将其转换为字符串。</li><li><code>JSON.parse</code>将 JSON 转换回对象。</li></ul><h4 id="json的编码"><a href="#json的编码" class="headerlink" title="json的编码"></a>json的编码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> student = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">isAdmin</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">courses</span>: [<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;css&#x27;</span>, <span class="string">&#x27;js&#x27;</span>],</span><br><span class="line">  <span class="attr">wife</span>: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> json = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(student);</span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> json); <span class="comment">// we&#x27;ve got a string!</span></span><br><span class="line"><span class="title function_">alert</span>(json);</span><br><span class="line"><span class="comment">/* JSON 编码的对象：</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;name&quot;: &quot;John&quot;,</span></span><br><span class="line"><span class="comment">  &quot;age&quot;: 30,</span></span><br><span class="line"><span class="comment">  &quot;isAdmin&quot;: false,</span></span><br><span class="line"><span class="comment">  &quot;courses&quot;: [&quot;html&quot;, &quot;css&quot;, &quot;js&quot;],</span></span><br><span class="line"><span class="comment">  &quot;wife&quot;: null</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>得到的json字符串是一个被称为JSON编码（JSON-encoded）或序列化（serialized）或字符串化（stringified）或编组化（marshalled）的对象。 我们现在已经准备好通过有线发送它或将其放入普通数据存储。 JSON 编码的对象与对象字面量有几个重要的区别： 字符串使用双引号。JSON 中没有单引号或反引号。所以 ‘John’ 被转换为 “John”。 对象属性名称也是双引号的。这是强制性的。所以 age:30 被转换成 “age”:30。 <strong>JSON 是语言无关的纯数据规范，因此一些特定于 JavaScript 的对象属性会被 JSON.stringify 跳过。</strong> 函数属性（方法）。Symbol 类型的键和值。存储 undefined 的属性。会被跳过</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字在 JSON 还是数字</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="number">1</span>) ) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 字符串在 JSON 中还是字符串，只是被双引号扩起来</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="string">&#x27;test&#x27;</span>) ) <span class="comment">// &quot;test&quot;</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="literal">true</span>) ); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="title class_">JSON</span>.<span class="title function_">stringify</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) ); <span class="comment">// [1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123; <span class="comment">// 被忽略</span></span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>)]: <span class="number">123</span>, <span class="comment">// 被忽略</span></span><br><span class="line">  <span class="attr">something</span>: <span class="literal">undefined</span> <span class="comment">// 被忽略</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">alert</span>( <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(user) ); <span class="comment">// &#123;&#125;（空对象）</span></span><br></pre></td></tr></table></figure><p>并且json支持嵌套对象转换并进行自动转码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> meetup = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;Conference&quot;</span>,</span><br><span class="line">  <span class="attr">room</span>: &#123;</span><br><span class="line">    <span class="attr">number</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="attr">participants</span>: [<span class="string">&quot;john&quot;</span>, <span class="string">&quot;ann&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">alert</span>( <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(meetup) );</span><br><span class="line"><span class="comment">/* 整个解构都被字符串化了</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;title&quot;:&quot;Conference&quot;,</span></span><br><span class="line"><span class="comment">  &quot;room&quot;:&#123;&quot;number&quot;:23,&quot;participants&quot;:[&quot;john&quot;,&quot;ann&quot;]&#125;,</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>JSON.stringify</code>的完整语法是： <code>let json = JSON.stringify(value,[replacer, space])</code> value:要编码的值。 replacer:要编码的属性数组或映射函数 function(key, value)。 space:用于格式化的空格数量 如果space&#x3D;2则等于告诉JavaScript在多行中显示嵌套的对象，对象内部缩进2个空格。 <strong>spaces 参数仅用于日志记录和美化输出。</strong> 大部分情况，JSON.stringify仅与第一个参数一起使用。但是，如果我们需要微调替换过程，比如过滤掉循环引用，我们可以使用JSON.stringify的第二个参数。 如果我们传递一个属性数组给它，那么只有这些属性会被编码。</p><p>像 toString 进行字符串转换，对象也可以提供 toJSON 方法来进行 JSON 转换。如果可用，JSON.stringify 会自动调用它。</p><h4 id="json的解码"><a href="#json的解码" class="headerlink" title="json的解码"></a>json的解码</h4><p><code>let value = JSON.parse(str, [reviver]);</code> str:要解析的 JSON 字符串。 reviver:可选的函数 function(key,value)，该函数将为每个 (key, value) 对调用，并可以对值进行转换。</p><p>JSON 不支持注释。向 JSON 添加注释无效。 还有另一种名为 JSON5 的格式，它允许未加引号的键，也允许注释等。但这是一个独立的库，不在语言的规范中。 常规的 JSON 格式严格，并不是因为它的开发者很懒，而是为了实现简单，可靠且快速地实现解析算法。</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p><code>let func = (arg1, arg2, ..., argN) =&gt; expression;</code> 箭头函数左边是接受的参数，并对右边求值并返回 如果我们只有一个参数，还可以省略掉参数外的圆括号，使代码更短。<code>let double = n =&gt; n * 2;</code> 如果没有参数，括号则是空的（但括号必须保留）：<code>let sayHi = () =&gt; alert(&quot;Hello!&quot;);</code></p><p><strong>箭头函数对于简单的单行行为（action）来说非常方便，尤其是当我们懒得打太多字的时候。</strong> 带花括号：(…args) &#x3D;&gt; { body } — 花括号允许我们在函数中编写多个语句，但是我们需要显式地 return 来返回一些内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">a, b</span>) =&gt; &#123;  <span class="comment">// 花括号表示开始一个多行函数</span></span><br><span class="line">  <span class="keyword">let</span> result = a + b;</span><br><span class="line">  <span class="keyword">return</span> result; <span class="comment">// 如果我们使用了花括号，那么我们需要一个显式的 “return”</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( <span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>) ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><strong>箭头函数没有 this。如果访问 this，则会从外部获取。</strong> <strong>不具有 this 自然也就意味着另一个限制：箭头函数不能用作构造器（constructor）。不能用 new 调用它们。</strong> <strong>箭头函数也没有 arguments 变量。</strong></p><h3 id="调度setTimeout-amp-setInterval"><a href="#调度setTimeout-amp-setInterval" class="headerlink" title="调度setTimeout &amp; setInterval"></a>调度setTimeout &amp; setInterval</h3><p>有时我们并不想立即执行一个函数，而是等待特定一段时间之后再执行。这就是所谓的“计划调用（scheduling a call）”。 setTimeout 允许我们将函数推迟到一段时间间隔之后再执行。 setInterval 允许我们重复运行一个函数，从一段时间间隔之后开始运行，之后以该时间间隔连续重复运行该函数。 <code>let timerId = setTimeout(funccode, [delay], [arg1], [arg2], ...)</code> <code>funccode</code>想要执行的函数或代码字符串。 一般传入的都是函数。由于某些历史原因，支持传入代码字符串，但是不建议这样做。 <code>delay</code>执行前的延时，以毫秒为单位（1000 毫秒 &#x3D; 1 秒），默认值是 0； <code>arg1，arg2…</code>要传入被执行函数（或代码字符串）的参数列表（IE9 以下不支持）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(sayHi, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>需要注意的是，setTimeout()里的function不能加()，以上面为例，需要使用sayHi而不能使用sayHi()，因为这个方法是对函数的引用。</p><p><strong>任何 setTimeout 都只会在当前代码执行完毕之后才会执行。</strong></p><p><strong>可以用clearTimeout来取消调度</strong> setTimeout 在调用时会返回一个“定时器标识符（timer identifier）”，在我们的例子中是 timerId，我们可以使用它来取消执行。</p><p><code>setInterval</code>方法和<code>setTimeout</code>的语法相同：<code>let timerId = setInterval(funccode, [delay], [arg1], [arg2], ...)</code> 所有参数的意义也是相同的。不过与 setTimeout 只执行一次不同，setInterval 是每间隔给定的时间周期性执行。 想要阻止后续调用，我们需要调用 clearInterval(timerId)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每 2 秒重复一次</span></span><br><span class="line"><span class="keyword">let</span> timerId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="title function_">alert</span>(<span class="string">&#x27;tick&#x27;</span>), <span class="number">2000</span>);</span><br><span class="line"><span class="comment">// 5 秒之后停止</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="built_in">clearInterval</span>(timerId); <span class="title function_">alert</span>(<span class="string">&#x27;stop&#x27;</span>); &#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>在大多数浏览器中，包括Chrome和Firefox，在显示alert&#x2F;confirm&#x2F;prompt弹窗时，内部的定时器仍旧会继续“嘀嗒”。 所以，在运行上面的代码时，如果在一定时间内没有关掉alert弹窗，那么在你关闭弹窗后，下一个 alert 会立即显示。两次alert之间的时间间隔将小于2秒。</p><p><strong>嵌套的 setTimeout 能够精确地设置两次执行之间的延时，而 setInterval 却不能。</strong></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;现代模式&quot;&gt;&lt;a href=&quot;#现代模式&quot; class=&quot;headerlink&quot; title=&quot;现代模式&quot;&gt;&lt;/a&gt;现代模式&lt;/h3&gt;&lt;p&gt;现代模式&lt;code&gt;&amp;quot;use strict&amp;quot;;&lt;/code&gt;当它处于脚本文件的顶部时，则整个脚本文件都将以“现代”模式进行工作。 &lt;code&gt;&amp;quot;use strict&amp;quot;&lt;/code&gt;可以被放在函数体的开头。这样则可以只在该函数中启用严格模式。 但通常人们会在整个脚本中启用严格模式。&lt;/p&gt;</summary>
    
    
    
    <category term="前端知识" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
</feed>
