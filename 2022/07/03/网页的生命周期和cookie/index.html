<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.14.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="一、页面的生命周期HTML 页面的生命周期包含三个重要事件：  DOMContentLoaded —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像&lt;img&gt;和样式表之类的外部资源可能尚未加载完成。 load —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。 beforeunload&#x2F;unload —— 当用户正在离开页面时。  每个事">
<meta property="og:type" content="article">
<meta property="og:title" content="网页的生命周期和cookie">
<meta property="og:url" content="http://example.com/2022/07/03/%E7%BD%91%E9%A1%B5%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8Ccookie/index.html">
<meta property="og:site_name" content="小吴的Blog">
<meta property="og:description" content="一、页面的生命周期HTML 页面的生命周期包含三个重要事件：  DOMContentLoaded —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像&lt;img&gt;和样式表之类的外部资源可能尚未加载完成。 load —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。 beforeunload&#x2F;unload —— 当用户正在离开页面时。  每个事">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-03T15:15:33.000Z">
<meta property="article:modified_time" content="2023-03-20T08:32:39.692Z">
<meta property="article:author" content="Wh&amp;CC">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2022/07/03/%E7%BD%91%E9%A1%B5%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8Ccookie/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/07/03/%E7%BD%91%E9%A1%B5%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8Ccookie/","path":"2022/07/03/网页的生命周期和cookie/","title":"网页的生命周期和cookie"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>网页的生命周期和cookie | 小吴的Blog</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="小吴的Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">小吴的Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.</span> <span class="nav-text">一、页面的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-DOMContentLoaded"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 DOMContentLoaded</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 浏览器的自动填充</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-window-onload"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 window.onload</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-window-onunload"><span class="nav-number">1.4.</span> <span class="nav-text">1.3 window.onunload</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-window-onbeforeunload"><span class="nav-number">1.5.</span> <span class="nav-text">1.4 window.onbeforeunload</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-readyState"><span class="nav-number">1.6.</span> <span class="nav-text">1.5 readyState</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E8%84%9A%E6%9C%AC%EF%BC%9Aasync%EF%BC%8Cdefer"><span class="nav-number">2.</span> <span class="nav-text">二、脚本：async，defer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-defer"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 defer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-async"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 async</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E5%8A%A8%E6%80%81%E8%84%9A%E6%9C%AC"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 动态脚本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E6%80%BB%E7%BB%93"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD"><span class="nav-number">3.</span> <span class="nav-text">三、资源加载</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-script-onload-x2F-onerror"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 script.onload&#x2F;onerror</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 其他资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E8%B7%A8%E6%BA%90%E7%AD%96%E7%95%A5"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 跨源策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81cookie"><span class="nav-number">4.</span> <span class="nav-text">四、cookie</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-document-cookie"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 document.cookie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-cookie%E7%9A%84%E9%80%89%E9%A1%B9"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 cookie的选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-cookie%E5%87%BD%E6%95%B0"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 cookie函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-getCookie-name"><span class="nav-number">4.3.1.</span> <span class="nav-text">4.3.1 getCookie(name)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-setCookie-name-value-options"><span class="nav-number">4.3.2.</span> <span class="nav-text">4.3.2 setCookie(name, value,options)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-3-deleteCookie-name"><span class="nav-number">4.3.3.</span> <span class="nav-text">4.3.3 deleteCookie(name)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E7%AC%AC%E4%B8%89%E6%96%B9cookie"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 第三方cookie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-GDPR"><span class="nav-number">4.5.</span> <span class="nav-text">4.5 GDPR</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wh&CC"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Wh&CC</p>
  <div class="site-description" itemprop="description">Per aspera ad astra</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/sacrifice-w" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;sacrifice-w" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:761612239@qq.com" title="E-Mail → mailto:761612239@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/03/%E7%BD%91%E9%A1%B5%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8Ccookie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wh&CC">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小吴的Blog">
      <meta itemprop="description" content="Per aspera ad astra">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="网页的生命周期和cookie | 小吴的Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          网页的生命周期和cookie
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-03 23:15:33" itemprop="dateCreated datePublished" datetime="2022-07-03T23:15:33+08:00">2022-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-20 16:32:39" itemprop="dateModified" datetime="2023-03-20T16:32:39+08:00">2023-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">前端知识</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="一、页面的生命周期"><a href="#一、页面的生命周期" class="headerlink" title="一、页面的生命周期"></a>一、页面的生命周期</h1><p>HTML 页面的生命周期包含三个重要事件：</p>
<ul>
<li>DOMContentLoaded —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像<code>&lt;img&gt;</code>和样式表之类的外部资源可能尚未加载完成。</li>
<li>load —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。</li>
<li>beforeunload&#x2F;unload —— 当用户正在离开页面时。</li>
</ul>
<p>每个事件都是有用的：</p>
<ul>
<li>DOMContentLoaded 事件 —— DOM 已经就绪，因此处理程序可以查找 DOM 节点，并初始化接口。</li>
<li>load 事件 —— 外部资源已加载完成，样式已被应用，图片大小也已知了。</li>
<li>beforeunload 事件 —— 用户正在离开：我们可以检查用户是否保存了更改，并询问他是否真的要离开。</li>
<li>unload 事件 —— 用户几乎已经离开了，但是我们仍然可以启动一些操作，例如发送统计数据。</li>
</ul>
<h2 id="1-1-DOMContentLoaded"><a href="#1-1-DOMContentLoaded" class="headerlink" title="1.1 DOMContentLoaded"></a>1.1 DOMContentLoaded</h2><p><code>DOMContentLoaded</code>事件发生在<code>document</code>对象上。</p>
<p>我们必须使用<code>addEventListener</code>来捕获它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, ready);</span><br><span class="line"><span class="comment">// 不是 &quot;document.onDOMContentLoaded = ...&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">ready</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&#x27;DOM is ready&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 图片目前尚未加载完成（除非已经被缓存），所以图片的大小为 0x0</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">`Image size: <span class="subst">$&#123;img.offsetWidth&#125;</span>x<span class="subst">$&#123;img.offsetHeight&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, ready);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://en.js.cx/clipart/train.gif?speed=1&amp;cache=0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为DOMContentLoaded会在文档加载完成后触发，所以它可以查看所有元素，包括<code>&lt;img&gt;</code>等元素，但是不会等待图片加载，所以图片大小是0。</p>
<p>当浏览器处理一个 HTML 文档，并在文档中遇到<code>&lt;script&gt;</code>标签时，就会在继续构建 DOM 之前运行它。这是一种防范措施，因为脚本可能想要修改 DOM，甚至对其执行 <code>document.write</code>操作，所以<code>DOMContentLoaded</code>必须等待脚本执行结束。</p>
<p>此规则有两个例外：</p>
<ol>
<li>具有<code>async</code>特性（attribute）的脚本不会阻塞<code>DOMContentLoaded</code>，稍后我们会讲到。</li>
<li>使用<code>document.createElement(&#39;script&#39;)</code>动态生成并添加到网页的脚本也不会阻塞<code>DOMContentLoaded</code>。</li>
</ol>
<p><strong>外部样式表不会影响DOM，因此<code>DOMContentLoaded</code>不会等待它们。</strong></p>
<p>但这里有一个陷阱。如果在样式后面有一个脚本，那么该脚本必须等待样式表加载完成：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 在样式表加载完成之前，脚本都不会执行</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(<span class="title function_">getComputedStyle</span>(<span class="variable language_">document</span>.<span class="property">body</span>).<span class="property">marginTop</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>原因是，脚本可能想要获取元素的坐标和其他与样式相关的属性，如上例所示。因此，它必须等待样式加载完成。</p>
<p><strong>当<code>DOMContentLoaded</code>等待脚本时，它现在也在等待脚本前面的样式。所以说虽然外部样式表不会影响DOM，但是如果外部样式表后存在script脚本， <code>DOMContentLoaded</code>也会等待样式表加载完成</strong></p>
<h2 id="1-2-浏览器的自动填充"><a href="#1-2-浏览器的自动填充" class="headerlink" title="1.2 浏览器的自动填充"></a>1.2 浏览器的自动填充</h2><p>Firefox，Chrome 和 Opera 都会在<code>DOMContentLoaded</code>中自动填充表单。</p>
<p>例如，如果页面有一个带有登录名和密码的表单，并且浏览器记住了这些值，那么在 <code>DOMContentLoaded</code>上，浏览器会尝试自动填充它们（如果得到了用户允许）。</p>
<p>因此，如果<code>DOMContentLoaded</code>被需要加载很长时间的脚本延迟触发，那么自动填充也会等待。你可能在某些网站上看到过（如果你使用浏览器自动填充）—— 登录名&#x2F;密码字段不会立即自动填充，而是在页面被完全加载前会延迟填充。这实际上是 <code>DOMContentLoaded</code>事件之前的延迟。</p>
<h2 id="1-3-window-onload"><a href="#1-3-window-onload" class="headerlink" title="1.3 window.onload"></a>1.3 window.onload</h2><p>当<strong>整个页面，包括样式、图片和其他资源被加载完成时</strong>，会触发window对象上的<code>load</code>事件。可以通过<code>onload</code>属性获取此事件。</p>
<p>下面的这个示例正确显示了图片大小，因为<code>window.onload</code>会等待所有图片加载完毕：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 也可以用 window.addEventListener(&#x27;load&#x27;, (event) =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&#x27;Page loaded&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 此时图片已经加载完成</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">`Image size: <span class="subst">$&#123;img.offsetWidth&#125;</span>x<span class="subst">$&#123;img.offsetHeight&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://en.js.cx/clipart/train.gif?speed=1&amp;cache=0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-window-onunload"><a href="#1-3-window-onunload" class="headerlink" title="1.3 window.onunload"></a>1.3 window.onunload</h2><p>当访问者离开页面时，window对象上的<code>unload</code>事件就会被触发。我们可以在那里做一些不涉及延迟的操作，例如关闭相关的弹出窗口。 有一个值得注意的特殊情况是发送分析数据。 假设我们收集有关页面使用情况的数据：鼠标点击，滚动，被查看的页面区域等。 自然地，当用户要离开的时候，我们希望通过<code>unload</code>事件将数据保存到我们的服务器上。 有一个特殊的<code>navigator.sendBeacon(url, data)</code>方法可以满足这种需求，<a target="_blank" rel="noopener" href="https://w3c.github.io/beacon/">详见规范</a>。 它在后台发送数据，转换到另外一个页面不会有延迟：浏览器离开页面，但仍然在执行<code>sendBeacon</code>。 使用方式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> analyticsData = &#123; <span class="comment">/* 带有收集的数据的对象 */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;unload&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  navigator.<span class="title function_">sendBeacon</span>(<span class="string">&quot;/analytics&quot;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(analyticsData));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>请求以 POST 方式发送。</li>
<li>我们不仅能发送字符串，还能发送表单以及其他格式的数据，但通常它是一个字符串化的对象。</li>
<li>数据大小限制在 64kb。</li>
</ul>
<p>当<code>sendBeacon</code>请求完成时，浏览器可能已经离开了文档，所以就无法获取服务器响应（对于分析数据来说通常为空）。 还有一个<code>keep-alive</code>标志，该标志用于在<code>fetch</code>方法中为通用的网络请求执行此类“离开页面后”的请求。 如果我们要取消跳转到另一页面的操作，在这里做不到。但是我们可以使用另一个事件 ——<code>onbeforeunload</code>。</p>
<h2 id="1-4-window-onbeforeunload"><a href="#1-4-window-onbeforeunload" class="headerlink" title="1.4 window.onbeforeunload"></a>1.4 window.onbeforeunload</h2><p>如果访问者触发了离开页面的导航（navigation）或试图关闭窗口，<code>beforeunload</code>处理程序将要求进行更多确认。 如果我们要取消事件，浏览器会询问用户是否确定。 你可以通过运行下面这段代码，然后重新加载页面来进行尝试：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onbeforeunload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为有些站长通过显示误导性和恶意信息滥用了此事件处理程序。所以，目前一些旧的浏览器可能仍将其显示为消息，但除此之外 —— 无法自定义显示给用户的消息。</p>
<p><code>event.preventDefault()</code>在<code>beforeunload</code>处理程序中不起作用 这听起来可能很奇怪，但大多数浏览器都会忽略<code>event.preventDefault()</code>。 以下代码可能不起作用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;beforeunload&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 不起作用，所以这个事件处理程序没做任何事儿</span></span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>相反，在这样的处理程序中，应该将<code>event.returnValue</code>设置为一个字符串，以获得类似于上面代码的结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;beforeunload&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 起作用，与在 window.onbeforeunload 中 return 值的效果是一样的</span></span><br><span class="line">  event.<span class="property">returnValue</span> = <span class="string">&quot;有未保存的值。确认要离开吗？&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="1-5-readyState"><a href="#1-5-readyState" class="headerlink" title="1.5 readyState"></a>1.5 readyState</h2><p>如果我们在文档加载完成之后设置<code>DOMContentLoaded</code>事件处理程序，会发生什么？ 很自然地，它永远不会运行。 在某些情况下，我们不确定文档是否已经准备就绪。我们希望我们的函数在 DOM 加载完成时执行，无论现在还是以后。</p>
<p><code>document.readyState</code>属性可以为我们提供当前加载状态的信息。</p>
<p>它有 3 个可能值：</p>
<ul>
<li><code>loading</code> —— 文档正在被加载。</li>
<li><code>interactive</code> —— 文档被全部读取。</li>
<li><code>complete</code> —— 文档被全部读取，并且所有资源（例如图片等）都已加载完成。</li>
</ul>
<p>所以，我们可以检查<code>document.readyState</code>并设置一个处理程序，或在代码准备就绪时立即执行它。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">work</span>(<span class="params"></span>) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">readyState</span> == <span class="string">&#x27;loading&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// 仍在加载，等待事件</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, work);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// DOM 已就绪！</span></span><br><span class="line">  <span class="title function_">work</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个<code>readystatechange</code>事件，会在状态发生改变时触发，因此我们可以打印所有这些状态，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前状态</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">readyState</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态改变时打印它</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;readystatechange&#x27;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">readyState</span>));</span><br></pre></td></tr></table></figure>

<p><code>readystatechange</code>事件是跟踪文档加载状态的另一种机制，它很早就存在了。现在则很少被使用。</p>
<p>在<code>DOMContentLoaded</code>之前，<code>document.readyState</code>会立即变成<code>interactive</code>。它们俩的意义实际上是相同的。 当所有资源（iframe 和 img）都加载完成后，<code>document.readyState</code>变成 complete。这里我们可以发现，它与<code>img.onload</code>（img 是最后一个资源）和 <code>window.onload</code>几乎同时发生。转换到 complete 状态的意义与<code>window.onload</code>相同。区别在于<code>window.onload</code>始终在所有其他 load 处理程序之后运行。</p>
<h1 id="二、脚本：async，defer"><a href="#二、脚本：async，defer" class="headerlink" title="二、脚本：async，defer"></a>二、脚本：async，defer</h1><p>现代的网站中，脚本往往比 HTML 更“重”：它们的大小通常更大，处理时间也更长。</p>
<p>当浏览器加载 HTML 时遇到<code>&lt;script&gt;...&lt;/script&gt;</code>标签，浏览器就不能继续构建 DOM。它必须立刻执行此脚本。对于外部脚本<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code>也是一样的：浏览器必须等脚本下载完，并执行结束，之后才能继续处理剩余的页面。</p>
<p>这会导致两个重要的问题：</p>
<ol>
<li>脚本不能访问到位于它们下面的 DOM 元素，因此，脚本无法给它们添加处理程序等。</li>
<li>如果页面顶部有一个笨重的脚本，它会“阻塞页面”。在该脚本下载并执行结束前，用户都不能看到页面内容。</li>
</ol>
<p>这里有一些解决办法。例如，我们可以把脚本放在页面底部。此时，它可以访问到它上面的元素，并且不会阻塞页面显示内容：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  ...all content is above the script...</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://javascript.info/article/script-async-defer/long.js?speed=1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是这种解决方案远非完美。例如，浏览器只有在下载了完整的 HTML 文档之后才会注意到该脚本（并且可以开始下载它）。对于长的 HTML 文档来说，这样可能会造成明显的延迟。</p>
<p>这对于使用高速连接的人来说，这不值一提，他们不会感受到这种延迟。但是这个世界上仍然有很多地区的人们所使用的网络速度很慢，并且使用的是远非完美的移动互联网连接。</p>
<p>幸运的是，这里有两个<code>&lt;script&gt;</code>特性（attribute）可以为我们解决这个问题：defer 和 async。</p>
<h2 id="2-1-defer"><a href="#2-1-defer" class="headerlink" title="2.1 defer"></a>2.1 defer</h2><p><code>defer</code>特性告诉浏览器不要等待脚本。相反，浏览器将继续处理 HTML，构建 DOM。脚本会“在后台”下载，然后等 DOM 构建完成后，脚本才会执行。</p>
<p>这是与上面那个相同的示例，但是带有 defer 特性：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>...content before script...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;https://javascript.info/article/script-async-defer/long.js?speed=1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 立即可见 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>...content after script...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>所以说：</p>
<ul>
<li>具有<code>defer</code>特性的脚本不会阻塞页面。</li>
<li>具有<code>defer</code>特性的脚本总是要等到 DOM 解析完毕，但在<code>DOMContentLoaded</code>事件之前执行。</li>
</ul>
<p>因为具有<code>defer</code>特性的脚本不会被等待，但是<code>DOMContentLoaded</code>事件必须等到脚本结束才能进行。</p>
<p><strong>具有<code>defer</code>特性的脚本保持其相对顺序，就像常规脚本一样。</strong></p>
<p>浏览器扫描页面寻找脚本，然后并行下载它们，以提高性能。</p>
<p>如果有两个脚本，一个大一个小，大脚本在前，小脚本在后。但是如果小脚本先被下载完成，但是因为执行的相对顺序，它会排在大脚本后面被执行。</p>
<p>当我们需要先加载 JavaScript 库，然后再加载依赖于它的脚本时，这可能会很有用。</p>
<p><strong><code>defer</code>特性仅适用于外部脚本。如果<code>&lt;script&gt;</code>脚本没有 src，则会忽略<code>defer</code>特性。</strong></p>
<h2 id="2-2-async"><a href="#2-2-async" class="headerlink" title="2.2 async"></a>2.2 async</h2><p><code>async</code>特性与<code>defer</code>有些类似。它也能够让脚本不阻塞页面。但是，在行为上二者有着重要的区别。</p>
<p><code>async</code>特性意味着脚本是完全独立的：</p>
<ul>
<li>浏览器不会因<code>async</code>脚本而阻塞（与<code>defer</code>类似）。</li>
<li>其他脚本不会等待<code>async</code>脚本加载完成，同样，<code>async</code>脚本也不会等待其他脚本。</li>
<li><code>DOMContentLoaded</code>和异步脚本不会彼此等待：<ul>
<li><code>DOMContentLoaded</code>可能会发生在异步脚本之前（如果异步脚本在页面完成后才加载完成）</li>
<li><code>DOMContentLoaded</code>也可能发生在异步脚本之后（如果异步脚本很短，或者是从 HTTP 缓存中加载的）</li>
</ul>
</li>
</ul>
<p>换句话说，<code>async</code>脚本会在后台加载，并在加载就绪时运行。DOM 和其他脚本不会等待它们，它们也不会等待其它的东西。<code>async</code>脚本就是一个会在加载完成时执行的完全独立的脚本。</p>
<ul>
<li>页面内容立刻显示出来：加载写有 async 的脚本不会阻塞页面渲染。</li>
<li><code>DOMContentLoaded</code>可能在<code>async</code>之前或之后触发，不能保证谁先谁后。</li>
<li>较小的脚本 small.js 排在第二位，但可能会比 long.js 这个长脚本先加载完成，所以 small.js 会先执行。虽然，可能是 long.js 先加载完成，如果它被缓存了的话，那么它就会先执行。换句话说，<strong>异步脚本以“加载优先”的顺序执行</strong>。</li>
</ul>
<p>当我们将独立的第三方脚本集成到页面时，此时采用异步加载方式是非常棒的：计数器，广告等，因为它们不依赖于我们的脚本，我们的脚本也不应该等待它们：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">&quot;https://google-analytics.com/analytics.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong><code>async</code>特性仅适用于外部脚本。如果<code>&lt;script&gt;</code>脚本没有 src，则会忽略<code>async</code>特性。</strong></p>
<h2 id="2-3-动态脚本"><a href="#2-3-动态脚本" class="headerlink" title="2.3 动态脚本"></a>2.3 动态脚本</h2><p>此外，还有一种向页面添加脚本的重要的方式。</p>
<p>我们可以使用 JavaScript 动态地创建一个脚本，并将其附加（append）到文档（document）中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;/article/script-async-defer/long.js&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(script); <span class="comment">// (*)</span></span><br></pre></td></tr></table></figure>

<p>当脚本被附加到文档 (*) 时，脚本就会立即开始加载。</p>
<p><strong>默认情况下，动态脚本的行为是“异步”的。</strong></p>
<p>如果我们显式地设置了<code>script.async=false</code>，则可以改变这个规则。然后脚本将按照脚本在文档中的顺序执行，就像<code>defer</code>那样。</p>
<h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h2><p>所以说<code>defer</code>是以文档顺序进行解析，而<code>async</code>则是按照加载优先顺序进行解析 <code>defer</code>更适合需要整个DOM的脚本，而<code>async</code>则更合适用于独立脚本</p>
<p>请注意：如果你使用的是<code>defer</code>或<code>async</code>，那么用户将在脚本加载完成之前先看到页面。 在这种情况下，某些图形组件可能尚未初始化完成。 因此，请记得添加一个“正在加载”的提示，并禁用尚不可用的按钮。以让用户可以清楚地看到，他现在可以在页面上做什么，以及还有什么是正在准备中的。</p>
<h1 id="三、资源加载"><a href="#三、资源加载" class="headerlink" title="三、资源加载"></a>三、资源加载</h1><p>浏览器允许我们跟踪外部资源的加载 —— 脚本，iframe，图片等。</p>
<p>这里有两个事件：</p>
<ul>
<li>onload —— 成功加载</li>
<li>onerror —— 出现error</li>
</ul>
<p>假设我们需要加载第三方脚本，并调用其中的函数。 我们可以像这样动态加载它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;my.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">append</span>(script);</span><br></pre></td></tr></table></figure>

<p>……但如何运行在该脚本中声明的函数？我们需要等到该脚本加载完成，之后才能调用它。</p>
<h2 id="3-1-script-onload-x2F-onerror"><a href="#3-1-script-onload-x2F-onerror" class="headerlink" title="3.1 script.onload&#x2F;onerror"></a>3.1 script.onload&#x2F;onerror</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以从任意域（domain），加载任意脚本</span></span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">append</span>(script);</span><br><span class="line"></span><br><span class="line">script.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 该脚本创建了一个变量 &quot;_&quot;</span></span><br><span class="line">  <span class="title function_">alert</span>( _.<span class="property">VERSION</span> ); <span class="comment">// 显示库的版本</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过onload事件，可以在脚本加载完成后，通过函数来运行脚本中的变量和函数等。</p>
<p>如果出现错误（比如error 404 或者服务器宕机等），则会被onerror追踪到。</p>
<p>例如，我们请求一个不存在的脚本：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;https://example.com/404.js&quot;</span>; <span class="comment">// 没有这个脚本</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">append</span>(script);</span><br><span class="line"></span><br><span class="line">script.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;Error loading &quot;</span> + <span class="variable language_">this</span>.<span class="property">src</span>); <span class="comment">// Error loading https://example.com/404.js</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>onload&#x2F;onerror 事件仅跟踪加载本身。</strong> 在脚本处理和执行期间可能发生的error超出了这些事件跟踪的范围。也就是说：如果脚本成功加载，则即使脚本中有编程error，也会触发onload事件。如果要跟踪脚本error，可以使用<code>window.onerror</code>全局处理程序。</p>
<h2 id="3-2-其他资源"><a href="#3-2-其他资源" class="headerlink" title="3.2 其他资源"></a>3.2 其他资源</h2><p><code>load</code>和<code>error</code>事件也适用于其他资源，基本上（basically）适用于具有外部 src 的任何资源。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;https://js.cx/clipart/train.gif&quot;</span>; <span class="comment">// (*)</span></span><br><span class="line"></span><br><span class="line">img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">`Image loaded, size <span class="subst">$&#123;img.width&#125;</span>x<span class="subst">$&#123;img.height&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">img.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;Error occurred while loading image&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>大多数资源在被添加到文档中后，便开始加载。但是<code>&lt;img&gt;</code>是个例外。它要等到获得<code>src (*)</code>后才开始加载。</li>
<li>对于<code>&lt;iframe&gt;</code>来说，iframe加载完成时会触发<code>iframe.onload</code>事件，无论是成功加载还是出现error。</li>
</ul>
<h2 id="3-3-跨源策略"><a href="#3-3-跨源策略" class="headerlink" title="3.3 跨源策略"></a>3.3 跨源策略</h2><p>这里有一条规则：来自一个网站的脚本无法访问其他网站的内容。例如，位于<code>https://facebook.com</code>的脚本无法读取位于<code>https://gmail.com</code>的用户邮箱。</p>
<p>或者，更确切地说，一个源（域&#x2F;端口&#x2F;协议三者）无法获取另一个源（origin）的内容。因此，即使我们有一个子域，或者仅仅是另一个端口，这都是不同的源，彼此无法相互访问。 这个规则还影响其他域的资源。 如果我们使用的是来自其他域的脚本，并且该脚本中存在 error，那么我们无法获取 error 的详细信息。</p>
<p>因为有很多服务（我们也可以构建自己的服务）使用<code>window.onerror</code>监听全局 error，保存 error 并提供访问和分析 error 的接口。这很好，因为我们可以看到由用户触发的实际中的 error。但是，如果一个脚本来自于另一个源（origin），则没有太多有关 error 的信息。</p>
<p>要允许跨源访问，<code>&lt;script&gt;</code>标签需要具有 crossorigin 特性（attribute），并且远程服务器必须提供特殊的 header。</p>
<ol>
<li>无<code>crossorigin</code>特性 —— 禁止访问。</li>
<li><code>crossorigin=&quot;anonymous&quot;</code> —— 如果服务器的响应带有包含 * 或我们的源（origin）的 header <code>Access-Control-Allow-Origin</code>，则允许访问。浏览器不会将授权信息和 cookie 发送到远程服务器。</li>
<li><code>crossorigin=&quot;use-credentials&quot;</code> —— 如果服务器发送回带有我们的源的 header <code>Access-Control-Allow-Origin</code> 和 <code>Access-Control-Allow-Credentials: true</code>，则允许访问。浏览器会将授权信息和 cookie 发送到远程服务器。</li>
</ol>
<p>关于cookie的相关知识会在下面进行介绍。</p>
<h1 id="四、cookie"><a href="#四、cookie" class="headerlink" title="四、cookie"></a>四、cookie</h1><p>Cookie 是直接存储在浏览器中的一小串数据。它们是 HTTP 协议的一部分。 Cookie 通常是由Web服务器使用响应<code>Set-Cookie HTTP-header</code>设置的。然后浏览器使用<code>Cookie HTTP-header</code>将它们自动添加到（几乎）每个对相同域的请求中。</p>
<p>最常见的用处之一就是身份验证：</p>
<ol>
<li>登录后，服务器在响应中使用<code>Set-Cookie HTTP-header</code>来设置具有唯一“会话标识符（session identifier）”的 cookie。</li>
<li>下次当请求被发送到同一个域时，浏览器会使用<code>Cookie HTTP-header</code>通过网络发送 cookie。</li>
<li>所以服务器知道是谁发起了请求。</li>
</ol>
<p>我们还可以使用<code>document.cookie</code>属性从浏览器访问 cookie。</p>
<h2 id="4-1-document-cookie"><a href="#4-1-document-cookie" class="headerlink" title="4.1 document.cookie"></a>4.1 document.cookie</h2><p><code>document.cookie</code>的值由<code>name=value</code>对组成，以 ; 分隔。每一个都是独立的 cookie。 为了找到一个特定的 cookie，我们可以以 ; 作为分隔，将<code>document.cookie</code>分开，然后找到对应的名字。我们可以使用正则表达式或者数组函数来实现。</p>
<p><strong>可以使用document.cookie来更新cookie的值。但是这种写入操作只会更新其中提到的 cookie，而不会涉及其他 cookie</strong></p>
<p>从技术上讲，cookie 的名称和值可以是任何字符。为了保持有效的格式，它们应该使用内建的<code>encodeURIComponent</code>函数对其进行转义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特殊字符（空格），需要编码</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;my name&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> value = <span class="string">&quot;John Smith&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 cookie 编码为 my%20name=John%20Smith</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>); <span class="comment">// ...; my%20name=John%20Smith</span></span><br></pre></td></tr></table></figure>

<p>cookie的限制：</p>
<ul>
<li><code>encodeURIComponent</code>编码后的 name&#x3D;value 对，大小不能超过 4KB。因此，我们不能在一个 cookie 中保存大的东西。</li>
<li>每个域的 cookie 总数不得超过 20+ 左右，具体限制取决于浏览器。</li>
</ul>
<h2 id="4-2-cookie的选项"><a href="#4-2-cookie的选项" class="headerlink" title="4.2 cookie的选项"></a>4.2 cookie的选项</h2><p><code>document.cookie = &quot;user=John; path=/; expires=Tue, 19 Jan 2038 03:14:07 GMT&quot;</code></p>
<ul>
<li><p>path: path&#x3D;&#x2F;mypath。</p>
<ul>
<li>url 路径前缀必须是绝对路径。它使得该路径下的页面可以访问该 cookie。默认为当前路径。</li>
<li>如果一个 cookie 带有<code>path=/admin</code>设置，那么该 cookie 在<code>/admin</code>和<code>/admin/something</code>下都是可见的，但是在<code>/home</code>或<code>/adminpage</code>下不可见。</li>
<li>通常，我们应该将path设置为根目录：<code>path=/</code>，以使 cookie 对此网站的所有页面可见。</li>
</ul>
</li>
<li><p>domain:domain&#x3D;site.com</p>
<ul>
<li><p>domain 控制了可访问 cookie 的域。但是在实际中，有一些限制。我们无法设置任何域。</p>
</li>
<li><p>无法从另一个二级域访问 cookie，因此<code>other.com</code>永远不会收到在<code>site.com</code>设置的 cookie。</p>
</li>
<li><p>这是一项安全限制，为了允许我们将敏感数据存储在应该仅在一个站点上可用的 cookie 中。</p>
</li>
<li><p>默认情况下，cookie 只有在设置的域下才能被访问到。</p>
</li>
<li><p>请注意，默认情况下，cookie 也不会共享给子域，例如<code>forum.site.com</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果我们在 site.com 网站上设置了 cookie……</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;user=John&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……在 forum.site.com 域下我们无法访问它</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>); <span class="comment">// 没有 user</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>所以说，如果想要在子域上访问父域的cookie，则需要通过<code>domain</code>来将<code>domain=site.com</code>，这样就将父域设置为了根域，从而所有子域都能够访问到这样的cookie</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 site.com</span></span><br><span class="line"><span class="comment">// 使 cookie 可以被在任何子域 *.site.com 访问：</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;user=John; domain=site.com&quot;</span></span><br><span class="line"><span class="comment">// 之后</span></span><br><span class="line"><span class="comment">// 在 forum.site.com</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>); <span class="comment">// 有 cookie user=John</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>出于历史原因,<code>domain=.site.com</code>（site.com 前面有一个点符号）也以相同的方式工作，允许从子域访问 cookie。这是一个旧的表示方式，如果我们需要支持非常旧的浏览器，那么应该使用它</p>
</li>
</ul>
</li>
<li><p>expires,max-age</p>
<ul>
<li><p>默认情况下，如果一个 cookie 没有设置这两个参数中的任何一个，那么在关闭浏览器之后，它就会消失。此类 cookie 被称为 “session cookie”。</p>
</li>
<li><p>为了让 cookie 在浏览器关闭后仍然存在，我们可以设置 expires 或 max-age 选项中的一个。<code>expires=Tue, 19 Jan 2038 03:14:07 GMT</code></p>
</li>
<li><p>cookie 的过期时间定义了浏览器会自动清除该 cookie 的时间。</p>
</li>
<li><p>日期必须完全采用 GMT 时区的这种格式。我们可以使用<code>date.toUTCString</code>来获取。</p>
</li>
<li><p>如果我们将<code>expires</code>设置为过去的时间，则 cookie 会被删除。</p>
</li>
<li><p><code>max-age</code>是<code>expires</code>的替代选项，指明了 cookie 的过期时间距离当前时间的秒数。</p>
</li>
<li><p>如果将其设置为 0 或负数，则 cookie 会被删除：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// cookie 会在一小时后失效</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;user=John; max-age=3600&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>&#x2F;&#x2F; 删除 cookie（让它立即过期） document.cookie &#x3D; “user&#x3D;John; max-age&#x3D;0”;</p>
</li>
<li><p>secure</p>
<ul>
<li>Cookie 应只能被通过 HTTPS 传输。</li>
<li><strong>默认情况下，如果我们在<code>http://site.com</code>上设置了 cookie，那么该 cookie 也会出现在<code>https://site.com</code>上，反之亦然。</strong></li>
<li>也就是说，cookie 是基于域的，它们不区分协议。</li>
<li>使用此选项，如果一个 cookie 是通过<code>https://site.com</code>设置的，那么它不会在相同域的 HTTP 环境下出现，例如 <code>http://site.com</code>。所以，如果一个 cookie 包含绝不应该通过未加密的 HTTP 协议发送的敏感内容，那么就应该设置 secure 标识</li>
</ul>
</li>
<li><p>samesite</p>
<ul>
<li>这是另外一个关于安全的特性。它旨在防止 XSRF（跨网站请求伪造）攻击。</li>
<li>当<code>samesite=strict</code>时，如果用户来自同一网站之外，那么设置了 <code>samesite=strict</code>的 cookie 永远不会被发送。</li>
<li><code>samesite=lax</code>是一种更轻松的方法，该方法还可以防止 XSRF 攻击，并且不会破坏用户体验。</li>
<li>宽松（lax）模式，和 strict 模式类似，当从外部来到网站，则禁止浏览器发送 cookie，但是增加了一个例外。</li>
<li>如果以下两个条件均成立，则会发送含 samesite&#x3D;lax 的 cookie：</li>
<li><ol>
<li>HTTP 方法是“安全的”（例如 GET 方法，而不是 POST）。</li>
</ol>
</li>
<li>所有安全的 HTTP 方法详见<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7231">RFC7231规范</a>。基本上，这些都是用于读取而不是写入数据的方法。它们不得执行任何更改数据的操作。跟随链接始终是 GET，是安全的方法。<ol start="2">
<li>该操作执行顶级导航（更改浏览器地址栏中的 URL）。</li>
</ol>
</li>
<li>这通常是成立的，但是如果导航是在一个<code>&lt;iframe&gt;</code>中执行的，那么它就不是顶级的。此外，用于网络请求的 JavaScript 方法不会执行任何导航，因此它们不适合。</li>
<li>所以，<code>samesite=lax</code>所做的是基本上允许最常见的“前往 URL”操作携带 cookie。例如，从笔记中打开网站链接就满足这些条件。</li>
<li>但是，任何更复杂的事儿，例如来自另一个网站的网络请求或表单提交都会丢失 cookie。</li>
<li>如果这种情况适合你，那么添加<code>samesite=lax</code>将不会破坏用户体验并且可以增加保护。</li>
<li><strong>samesite会被到 2017 年左右的旧版本浏览器忽略（不兼容）。</strong></li>
<li>所以可以将 samesite 与其他保护措施（例如 XSRF token）一起使用，例如 xsrf token，这样可以多增加一层保护，将来，当旧版本的浏览器淘汰时，我们可能就可以删除 xsrf token 这种方式了。</li>
</ul>
</li>
<li><p>httpOnly</p>
<ul>
<li>Web 服务器使用<code>Set-Cookie header</code>来设置 cookie。并且，它可以设置 <code>httpOnly</code>选项。</li>
<li>这个选项禁止任何 JavaScript 访问 cookie。我们使用<code>document.cookie</code>看不到此类 cookie，也无法对此类 cookie 进行操作。</li>
<li>这个的主要作用就是保护浏览器被入侵而造成的用户信息的泄露</li>
</ul>
</li>
</ul>
<h2 id="4-3-cookie函数"><a href="#4-3-cookie函数" class="headerlink" title="4.3 cookie函数"></a>4.3 cookie函数</h2><p>这里有一组有关 cookie 操作的函数，比手动修改 document.cookie 方便得多。</p>
<p>有很多这种 cookie 库，所以这些函数只用于演示。虽然它们都能正常使用。</p>
<h3 id="4-3-1-getCookie-name"><a href="#4-3-1-getCookie-name" class="headerlink" title="4.3.1 getCookie(name)"></a>4.3.1 getCookie(name)</h3><p>获取 cookie 最简短的方式是使用 正则表达式。 getCookie(name) 函数返回具有给定 name 的 cookie：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回具有给定 name 的 cookie，</span></span><br><span class="line"><span class="comment">// 如果没找到，则返回 undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getCookie</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> matches = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">match</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>(</span><br><span class="line">    <span class="string">&quot;(?:^; )&quot;</span> + name.<span class="title function_">replace</span>(<span class="regexp">/([\.$?*&#123;&#125;\(\)\[\]\\\/\+^])/g</span>, <span class="string">&#x27;\\$1&#x27;</span>) + <span class="string">&quot;=([^;]*)&quot;</span></span><br><span class="line">  ));</span><br><span class="line">  <span class="keyword">return</span> matches ? <span class="built_in">decodeURIComponent</span>(matches[<span class="number">1</span>]) : <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 new RegExp 是动态生成的，以匹配 ; name&#x3D;。</p>
<p>请注意 cookie 的值是经过编码的，所以 getCookie 使用了内建方法 <code>decodeURIComponent</code>函数对其进行解码。</p>
<h3 id="4-3-2-setCookie-name-value-options"><a href="#4-3-2-setCookie-name-value-options" class="headerlink" title="4.3.2 setCookie(name, value,options)"></a>4.3.2 setCookie(name, value,options)</h3><p>将 cookie 的 name 设置为具有默认值 path&#x3D;&#x2F;（可以修改以添加其他默认值）和给定值 value：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setCookie</span>(<span class="params">name, value, options = &#123;&#125;</span>) &#123;</span><br><span class="line"></span><br><span class="line">  options = &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="comment">// 如果需要，可以在这里添加其他默认值</span></span><br><span class="line">    ...options</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">expires</span> <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">    options.<span class="property">expires</span> = options.<span class="property">expires</span>.<span class="title function_">toUTCString</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updatedCookie = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">&quot;=&quot;</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> optionKey <span class="keyword">in</span> options) &#123;</span><br><span class="line">    updatedCookie += <span class="string">&quot;; &quot;</span> + optionKey;</span><br><span class="line">    <span class="keyword">let</span> optionValue = options[optionKey];</span><br><span class="line">    <span class="keyword">if</span> (optionValue !== <span class="literal">true</span>) &#123;</span><br><span class="line">      updatedCookie += <span class="string">&quot;=&quot;</span> + optionValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">cookie</span> = updatedCookie;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用范例：</span></span><br><span class="line"><span class="title function_">setCookie</span>(<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;John&#x27;</span>, &#123;<span class="attr">secure</span>: <span class="literal">true</span>, <span class="string">&#x27;max-age&#x27;</span>: <span class="number">3600</span>&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="4-3-3-deleteCookie-name"><a href="#4-3-3-deleteCookie-name" class="headerlink" title="4.3.3 deleteCookie(name)"></a>4.3.3 deleteCookie(name)</h3><p>要删除一个 cookie，我们可以给它设置一个负的过期时间来调用它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deleteCookie</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title function_">setCookie</span>(name, <span class="string">&quot;&quot;</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;max-age&#x27;</span>: -<span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>请注意：当我们更新或删除一个 cookie 时，我们应该使用和设置 cookie 时相同的路径和域选项。</strong></p>
<h2 id="4-4-第三方cookie"><a href="#4-4-第三方cookie" class="headerlink" title="4.4 第三方cookie"></a>4.4 第三方cookie</h2><p>如果 cookie 是由用户所访问的页面的域以外的域放置的，则称其为第三方 cookie。</p>
<p>由于它的性质，第三方 cookie 通常用于跟踪和广告服务。它们被绑定在原始域上，因此 ads.com 可以在不同网站之间跟踪同一用户，如果这些网站都可以访问 ads.com 的话。</p>
<p>当然，有些人不喜欢被跟踪，因此浏览器允许禁止此类 cookie。</p>
<p>此外，一些现代浏览器对此类 cookie 采取特殊策略：</p>
<ul>
<li>Safari 浏览器完全不允许第三方 cookie。</li>
<li>Firefox 浏览器附带了一个第三方域的黑名单，它阻止了来自名单内的域的第三方 cookie。</li>
</ul>
<h2 id="4-5-GDPR"><a href="#4-5-GDPR" class="headerlink" title="4.5 GDPR"></a>4.5 GDPR</h2><p>欧洲有一项名为 GDPR 的立法，该法规针对网站尊重用户实施了一系列规则。其中之一就是需要明确的许可才可以跟踪用户的 cookie。</p>
<p><strong>所以说很多网站要用户来同意使用cookie，但是感觉国内网站根本没有这个东西-。-</strong></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/06/22/js%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/" rel="prev" title="js补充知识">
                  <i class="fa fa-chevron-left"></i> js补充知识
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/07/07/Ajax%E8%AF%A6%E8%A7%A3/" rel="next" title="AJAX详解">
                  AJAX详解 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wh&CC</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
